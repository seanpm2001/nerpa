// This file is generated by rust-protobuf 2.22.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `p4/v1/p4runtime.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_1;

#[derive(PartialEq,Clone,Default)]
pub struct WriteRequest {
    // message fields
    pub device_id: u64,
    pub role_id: u64,
    pub election_id: ::protobuf::SingularPtrField<Uint128>,
    pub updates: ::protobuf::RepeatedField<Update>,
    pub atomicity: WriteRequest_Atomicity,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WriteRequest {
    fn default() -> &'a WriteRequest {
        <WriteRequest as ::protobuf::Message>::default_instance()
    }
}

impl WriteRequest {
    pub fn new() -> WriteRequest {
        ::std::default::Default::default()
    }

    // uint64 device_id = 1;


    pub fn get_device_id(&self) -> u64 {
        self.device_id
    }
    pub fn clear_device_id(&mut self) {
        self.device_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: u64) {
        self.device_id = v;
    }

    // uint64 role_id = 2;


    pub fn get_role_id(&self) -> u64 {
        self.role_id
    }
    pub fn clear_role_id(&mut self) {
        self.role_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = v;
    }

    // .p4.v1.Uint128 election_id = 3;


    pub fn get_election_id(&self) -> &Uint128 {
        self.election_id.as_ref().unwrap_or_else(|| <Uint128 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_election_id(&mut self) {
        self.election_id.clear();
    }

    pub fn has_election_id(&self) -> bool {
        self.election_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_election_id(&mut self, v: Uint128) {
        self.election_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_election_id(&mut self) -> &mut Uint128 {
        if self.election_id.is_none() {
            self.election_id.set_default();
        }
        self.election_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_election_id(&mut self) -> Uint128 {
        self.election_id.take().unwrap_or_else(|| Uint128::new())
    }

    // repeated .p4.v1.Update updates = 4;


    pub fn get_updates(&self) -> &[Update] {
        &self.updates
    }
    pub fn clear_updates(&mut self) {
        self.updates.clear();
    }

    // Param is passed by value, moved
    pub fn set_updates(&mut self, v: ::protobuf::RepeatedField<Update>) {
        self.updates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_updates(&mut self) -> &mut ::protobuf::RepeatedField<Update> {
        &mut self.updates
    }

    // Take field
    pub fn take_updates(&mut self) -> ::protobuf::RepeatedField<Update> {
        ::std::mem::replace(&mut self.updates, ::protobuf::RepeatedField::new())
    }

    // .p4.v1.WriteRequest.Atomicity atomicity = 5;


    pub fn get_atomicity(&self) -> WriteRequest_Atomicity {
        self.atomicity
    }
    pub fn clear_atomicity(&mut self) {
        self.atomicity = WriteRequest_Atomicity::CONTINUE_ON_ERROR;
    }

    // Param is passed by value, moved
    pub fn set_atomicity(&mut self, v: WriteRequest_Atomicity) {
        self.atomicity = v;
    }
}

impl ::protobuf::Message for WriteRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.election_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.device_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.role_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.election_id)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.updates)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.atomicity, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.device_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.device_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.role_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.role_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.election_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.atomicity != WriteRequest_Atomicity::CONTINUE_ON_ERROR {
            my_size += ::protobuf::rt::enum_size(5, self.atomicity);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.device_id != 0 {
            os.write_uint64(1, self.device_id)?;
        }
        if self.role_id != 0 {
            os.write_uint64(2, self.role_id)?;
        }
        if let Some(ref v) = self.election_id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.updates {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.atomicity != WriteRequest_Atomicity::CONTINUE_ON_ERROR {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.atomicity))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteRequest {
        WriteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "device_id",
                |m: &WriteRequest| { &m.device_id },
                |m: &mut WriteRequest| { &mut m.device_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "role_id",
                |m: &WriteRequest| { &m.role_id },
                |m: &mut WriteRequest| { &mut m.role_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Uint128>>(
                "election_id",
                |m: &WriteRequest| { &m.election_id },
                |m: &mut WriteRequest| { &mut m.election_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Update>>(
                "updates",
                |m: &WriteRequest| { &m.updates },
                |m: &mut WriteRequest| { &mut m.updates },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WriteRequest_Atomicity>>(
                "atomicity",
                |m: &WriteRequest| { &m.atomicity },
                |m: &mut WriteRequest| { &mut m.atomicity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WriteRequest>(
                "WriteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WriteRequest {
        static instance: ::protobuf::rt::LazyV2<WriteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WriteRequest::new)
    }
}

impl ::protobuf::Clear for WriteRequest {
    fn clear(&mut self) {
        self.device_id = 0;
        self.role_id = 0;
        self.election_id.clear();
        self.updates.clear();
        self.atomicity = WriteRequest_Atomicity::CONTINUE_ON_ERROR;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WriteRequest_Atomicity {
    CONTINUE_ON_ERROR = 0,
    ROLLBACK_ON_ERROR = 1,
    DATAPLANE_ATOMIC = 2,
}

impl ::protobuf::ProtobufEnum for WriteRequest_Atomicity {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WriteRequest_Atomicity> {
        match value {
            0 => ::std::option::Option::Some(WriteRequest_Atomicity::CONTINUE_ON_ERROR),
            1 => ::std::option::Option::Some(WriteRequest_Atomicity::ROLLBACK_ON_ERROR),
            2 => ::std::option::Option::Some(WriteRequest_Atomicity::DATAPLANE_ATOMIC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WriteRequest_Atomicity] = &[
            WriteRequest_Atomicity::CONTINUE_ON_ERROR,
            WriteRequest_Atomicity::ROLLBACK_ON_ERROR,
            WriteRequest_Atomicity::DATAPLANE_ATOMIC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<WriteRequest_Atomicity>("WriteRequest.Atomicity", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for WriteRequest_Atomicity {
}

impl ::std::default::Default for WriteRequest_Atomicity {
    fn default() -> Self {
        WriteRequest_Atomicity::CONTINUE_ON_ERROR
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteRequest_Atomicity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WriteResponse {
    fn default() -> &'a WriteResponse {
        <WriteResponse as ::protobuf::Message>::default_instance()
    }
}

impl WriteResponse {
    pub fn new() -> WriteResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for WriteResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteResponse {
        WriteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WriteResponse>(
                "WriteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WriteResponse {
        static instance: ::protobuf::rt::LazyV2<WriteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WriteResponse::new)
    }
}

impl ::protobuf::Clear for WriteResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadRequest {
    // message fields
    pub device_id: u64,
    pub entities: ::protobuf::RepeatedField<Entity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadRequest {
    fn default() -> &'a ReadRequest {
        <ReadRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReadRequest {
    pub fn new() -> ReadRequest {
        ::std::default::Default::default()
    }

    // uint64 device_id = 1;


    pub fn get_device_id(&self) -> u64 {
        self.device_id
    }
    pub fn clear_device_id(&mut self) {
        self.device_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: u64) {
        self.device_id = v;
    }

    // repeated .p4.v1.Entity entities = 2;


    pub fn get_entities(&self) -> &[Entity] {
        &self.entities
    }
    pub fn clear_entities(&mut self) {
        self.entities.clear();
    }

    // Param is passed by value, moved
    pub fn set_entities(&mut self, v: ::protobuf::RepeatedField<Entity>) {
        self.entities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entities(&mut self) -> &mut ::protobuf::RepeatedField<Entity> {
        &mut self.entities
    }

    // Take field
    pub fn take_entities(&mut self) -> ::protobuf::RepeatedField<Entity> {
        ::std::mem::replace(&mut self.entities, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ReadRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.entities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.device_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.device_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.device_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.entities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.device_id != 0 {
            os.write_uint64(1, self.device_id)?;
        }
        for v in &self.entities {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadRequest {
        ReadRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "device_id",
                |m: &ReadRequest| { &m.device_id },
                |m: &mut ReadRequest| { &mut m.device_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Entity>>(
                "entities",
                |m: &ReadRequest| { &m.entities },
                |m: &mut ReadRequest| { &mut m.entities },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadRequest>(
                "ReadRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadRequest {
        static instance: ::protobuf::rt::LazyV2<ReadRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadRequest::new)
    }
}

impl ::protobuf::Clear for ReadRequest {
    fn clear(&mut self) {
        self.device_id = 0;
        self.entities.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadResponse {
    // message fields
    pub entities: ::protobuf::RepeatedField<Entity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadResponse {
    fn default() -> &'a ReadResponse {
        <ReadResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReadResponse {
    pub fn new() -> ReadResponse {
        ::std::default::Default::default()
    }

    // repeated .p4.v1.Entity entities = 1;


    pub fn get_entities(&self) -> &[Entity] {
        &self.entities
    }
    pub fn clear_entities(&mut self) {
        self.entities.clear();
    }

    // Param is passed by value, moved
    pub fn set_entities(&mut self, v: ::protobuf::RepeatedField<Entity>) {
        self.entities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entities(&mut self) -> &mut ::protobuf::RepeatedField<Entity> {
        &mut self.entities
    }

    // Take field
    pub fn take_entities(&mut self) -> ::protobuf::RepeatedField<Entity> {
        ::std::mem::replace(&mut self.entities, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ReadResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.entities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entities {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadResponse {
        ReadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Entity>>(
                "entities",
                |m: &ReadResponse| { &m.entities },
                |m: &mut ReadResponse| { &mut m.entities },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadResponse>(
                "ReadResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadResponse {
        static instance: ::protobuf::rt::LazyV2<ReadResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadResponse::new)
    }
}

impl ::protobuf::Clear for ReadResponse {
    fn clear(&mut self) {
        self.entities.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Update {
    // message fields
    pub field_type: Update_Type,
    pub entity: ::protobuf::SingularPtrField<Entity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Update {
    fn default() -> &'a Update {
        <Update as ::protobuf::Message>::default_instance()
    }
}

impl Update {
    pub fn new() -> Update {
        ::std::default::Default::default()
    }

    // .p4.v1.Update.Type type = 1;


    pub fn get_field_type(&self) -> Update_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Update_Type::UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Update_Type) {
        self.field_type = v;
    }

    // .p4.v1.Entity entity = 2;


    pub fn get_entity(&self) -> &Entity {
        self.entity.as_ref().unwrap_or_else(|| <Entity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: Entity) {
        self.entity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut Entity {
        if self.entity.is_none() {
            self.entity.set_default();
        }
        self.entity.as_mut().unwrap()
    }

    // Take field
    pub fn take_entity(&mut self) -> Entity {
        self.entity.take().unwrap_or_else(|| Entity::new())
    }
}

impl ::protobuf::Message for Update {
    fn is_initialized(&self) -> bool {
        for v in &self.entity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.entity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Update_Type::UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if let Some(ref v) = self.entity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Update_Type::UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let Some(ref v) = self.entity.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Update {
        Update::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Update_Type>>(
                "type",
                |m: &Update| { &m.field_type },
                |m: &mut Update| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Entity>>(
                "entity",
                |m: &Update| { &m.entity },
                |m: &mut Update| { &mut m.entity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Update>(
                "Update",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Update {
        static instance: ::protobuf::rt::LazyV2<Update> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Update::new)
    }
}

impl ::protobuf::Clear for Update {
    fn clear(&mut self) {
        self.field_type = Update_Type::UNSPECIFIED;
        self.entity.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Update {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Update {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Update_Type {
    UNSPECIFIED = 0,
    INSERT = 1,
    MODIFY = 2,
    DELETE = 3,
}

impl ::protobuf::ProtobufEnum for Update_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Update_Type> {
        match value {
            0 => ::std::option::Option::Some(Update_Type::UNSPECIFIED),
            1 => ::std::option::Option::Some(Update_Type::INSERT),
            2 => ::std::option::Option::Some(Update_Type::MODIFY),
            3 => ::std::option::Option::Some(Update_Type::DELETE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Update_Type] = &[
            Update_Type::UNSPECIFIED,
            Update_Type::INSERT,
            Update_Type::MODIFY,
            Update_Type::DELETE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Update_Type>("Update.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Update_Type {
}

impl ::std::default::Default for Update_Type {
    fn default() -> Self {
        Update_Type::UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Update_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Entity {
    // message oneof groups
    pub entity: ::std::option::Option<Entity_oneof_entity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Entity {
    fn default() -> &'a Entity {
        <Entity as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Entity_oneof_entity {
    extern_entry(ExternEntry),
    table_entry(TableEntry),
    action_profile_member(ActionProfileMember),
    action_profile_group(ActionProfileGroup),
    meter_entry(MeterEntry),
    direct_meter_entry(DirectMeterEntry),
    counter_entry(CounterEntry),
    direct_counter_entry(DirectCounterEntry),
    packet_replication_engine_entry(PacketReplicationEngineEntry),
    value_set_entry(ValueSetEntry),
    register_entry(RegisterEntry),
    digest_entry(DigestEntry),
}

impl Entity {
    pub fn new() -> Entity {
        ::std::default::Default::default()
    }

    // .p4.v1.ExternEntry extern_entry = 1;


    pub fn get_extern_entry(&self) -> &ExternEntry {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::extern_entry(ref v)) => v,
            _ => <ExternEntry as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_extern_entry(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_extern_entry(&self) -> bool {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::extern_entry(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_extern_entry(&mut self, v: ExternEntry) {
        self.entity = ::std::option::Option::Some(Entity_oneof_entity::extern_entry(v))
    }

    // Mutable pointer to the field.
    pub fn mut_extern_entry(&mut self) -> &mut ExternEntry {
        if let ::std::option::Option::Some(Entity_oneof_entity::extern_entry(_)) = self.entity {
        } else {
            self.entity = ::std::option::Option::Some(Entity_oneof_entity::extern_entry(ExternEntry::new()));
        }
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::extern_entry(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_extern_entry(&mut self) -> ExternEntry {
        if self.has_extern_entry() {
            match self.entity.take() {
                ::std::option::Option::Some(Entity_oneof_entity::extern_entry(v)) => v,
                _ => panic!(),
            }
        } else {
            ExternEntry::new()
        }
    }

    // .p4.v1.TableEntry table_entry = 2;


    pub fn get_table_entry(&self) -> &TableEntry {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::table_entry(ref v)) => v,
            _ => <TableEntry as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_table_entry(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_table_entry(&self) -> bool {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::table_entry(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_table_entry(&mut self, v: TableEntry) {
        self.entity = ::std::option::Option::Some(Entity_oneof_entity::table_entry(v))
    }

    // Mutable pointer to the field.
    pub fn mut_table_entry(&mut self) -> &mut TableEntry {
        if let ::std::option::Option::Some(Entity_oneof_entity::table_entry(_)) = self.entity {
        } else {
            self.entity = ::std::option::Option::Some(Entity_oneof_entity::table_entry(TableEntry::new()));
        }
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::table_entry(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_table_entry(&mut self) -> TableEntry {
        if self.has_table_entry() {
            match self.entity.take() {
                ::std::option::Option::Some(Entity_oneof_entity::table_entry(v)) => v,
                _ => panic!(),
            }
        } else {
            TableEntry::new()
        }
    }

    // .p4.v1.ActionProfileMember action_profile_member = 3;


    pub fn get_action_profile_member(&self) -> &ActionProfileMember {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::action_profile_member(ref v)) => v,
            _ => <ActionProfileMember as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_action_profile_member(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_action_profile_member(&self) -> bool {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::action_profile_member(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_profile_member(&mut self, v: ActionProfileMember) {
        self.entity = ::std::option::Option::Some(Entity_oneof_entity::action_profile_member(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_profile_member(&mut self) -> &mut ActionProfileMember {
        if let ::std::option::Option::Some(Entity_oneof_entity::action_profile_member(_)) = self.entity {
        } else {
            self.entity = ::std::option::Option::Some(Entity_oneof_entity::action_profile_member(ActionProfileMember::new()));
        }
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::action_profile_member(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_profile_member(&mut self) -> ActionProfileMember {
        if self.has_action_profile_member() {
            match self.entity.take() {
                ::std::option::Option::Some(Entity_oneof_entity::action_profile_member(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionProfileMember::new()
        }
    }

    // .p4.v1.ActionProfileGroup action_profile_group = 4;


    pub fn get_action_profile_group(&self) -> &ActionProfileGroup {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::action_profile_group(ref v)) => v,
            _ => <ActionProfileGroup as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_action_profile_group(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_action_profile_group(&self) -> bool {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::action_profile_group(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_profile_group(&mut self, v: ActionProfileGroup) {
        self.entity = ::std::option::Option::Some(Entity_oneof_entity::action_profile_group(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_profile_group(&mut self) -> &mut ActionProfileGroup {
        if let ::std::option::Option::Some(Entity_oneof_entity::action_profile_group(_)) = self.entity {
        } else {
            self.entity = ::std::option::Option::Some(Entity_oneof_entity::action_profile_group(ActionProfileGroup::new()));
        }
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::action_profile_group(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_profile_group(&mut self) -> ActionProfileGroup {
        if self.has_action_profile_group() {
            match self.entity.take() {
                ::std::option::Option::Some(Entity_oneof_entity::action_profile_group(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionProfileGroup::new()
        }
    }

    // .p4.v1.MeterEntry meter_entry = 5;


    pub fn get_meter_entry(&self) -> &MeterEntry {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::meter_entry(ref v)) => v,
            _ => <MeterEntry as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_meter_entry(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_meter_entry(&self) -> bool {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::meter_entry(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_meter_entry(&mut self, v: MeterEntry) {
        self.entity = ::std::option::Option::Some(Entity_oneof_entity::meter_entry(v))
    }

    // Mutable pointer to the field.
    pub fn mut_meter_entry(&mut self) -> &mut MeterEntry {
        if let ::std::option::Option::Some(Entity_oneof_entity::meter_entry(_)) = self.entity {
        } else {
            self.entity = ::std::option::Option::Some(Entity_oneof_entity::meter_entry(MeterEntry::new()));
        }
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::meter_entry(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_meter_entry(&mut self) -> MeterEntry {
        if self.has_meter_entry() {
            match self.entity.take() {
                ::std::option::Option::Some(Entity_oneof_entity::meter_entry(v)) => v,
                _ => panic!(),
            }
        } else {
            MeterEntry::new()
        }
    }

    // .p4.v1.DirectMeterEntry direct_meter_entry = 6;


    pub fn get_direct_meter_entry(&self) -> &DirectMeterEntry {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::direct_meter_entry(ref v)) => v,
            _ => <DirectMeterEntry as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_direct_meter_entry(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_direct_meter_entry(&self) -> bool {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::direct_meter_entry(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_direct_meter_entry(&mut self, v: DirectMeterEntry) {
        self.entity = ::std::option::Option::Some(Entity_oneof_entity::direct_meter_entry(v))
    }

    // Mutable pointer to the field.
    pub fn mut_direct_meter_entry(&mut self) -> &mut DirectMeterEntry {
        if let ::std::option::Option::Some(Entity_oneof_entity::direct_meter_entry(_)) = self.entity {
        } else {
            self.entity = ::std::option::Option::Some(Entity_oneof_entity::direct_meter_entry(DirectMeterEntry::new()));
        }
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::direct_meter_entry(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_direct_meter_entry(&mut self) -> DirectMeterEntry {
        if self.has_direct_meter_entry() {
            match self.entity.take() {
                ::std::option::Option::Some(Entity_oneof_entity::direct_meter_entry(v)) => v,
                _ => panic!(),
            }
        } else {
            DirectMeterEntry::new()
        }
    }

    // .p4.v1.CounterEntry counter_entry = 7;


    pub fn get_counter_entry(&self) -> &CounterEntry {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::counter_entry(ref v)) => v,
            _ => <CounterEntry as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_counter_entry(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_counter_entry(&self) -> bool {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::counter_entry(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_counter_entry(&mut self, v: CounterEntry) {
        self.entity = ::std::option::Option::Some(Entity_oneof_entity::counter_entry(v))
    }

    // Mutable pointer to the field.
    pub fn mut_counter_entry(&mut self) -> &mut CounterEntry {
        if let ::std::option::Option::Some(Entity_oneof_entity::counter_entry(_)) = self.entity {
        } else {
            self.entity = ::std::option::Option::Some(Entity_oneof_entity::counter_entry(CounterEntry::new()));
        }
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::counter_entry(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_counter_entry(&mut self) -> CounterEntry {
        if self.has_counter_entry() {
            match self.entity.take() {
                ::std::option::Option::Some(Entity_oneof_entity::counter_entry(v)) => v,
                _ => panic!(),
            }
        } else {
            CounterEntry::new()
        }
    }

    // .p4.v1.DirectCounterEntry direct_counter_entry = 8;


    pub fn get_direct_counter_entry(&self) -> &DirectCounterEntry {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::direct_counter_entry(ref v)) => v,
            _ => <DirectCounterEntry as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_direct_counter_entry(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_direct_counter_entry(&self) -> bool {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::direct_counter_entry(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_direct_counter_entry(&mut self, v: DirectCounterEntry) {
        self.entity = ::std::option::Option::Some(Entity_oneof_entity::direct_counter_entry(v))
    }

    // Mutable pointer to the field.
    pub fn mut_direct_counter_entry(&mut self) -> &mut DirectCounterEntry {
        if let ::std::option::Option::Some(Entity_oneof_entity::direct_counter_entry(_)) = self.entity {
        } else {
            self.entity = ::std::option::Option::Some(Entity_oneof_entity::direct_counter_entry(DirectCounterEntry::new()));
        }
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::direct_counter_entry(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_direct_counter_entry(&mut self) -> DirectCounterEntry {
        if self.has_direct_counter_entry() {
            match self.entity.take() {
                ::std::option::Option::Some(Entity_oneof_entity::direct_counter_entry(v)) => v,
                _ => panic!(),
            }
        } else {
            DirectCounterEntry::new()
        }
    }

    // .p4.v1.PacketReplicationEngineEntry packet_replication_engine_entry = 9;


    pub fn get_packet_replication_engine_entry(&self) -> &PacketReplicationEngineEntry {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::packet_replication_engine_entry(ref v)) => v,
            _ => <PacketReplicationEngineEntry as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_packet_replication_engine_entry(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_packet_replication_engine_entry(&self) -> bool {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::packet_replication_engine_entry(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_packet_replication_engine_entry(&mut self, v: PacketReplicationEngineEntry) {
        self.entity = ::std::option::Option::Some(Entity_oneof_entity::packet_replication_engine_entry(v))
    }

    // Mutable pointer to the field.
    pub fn mut_packet_replication_engine_entry(&mut self) -> &mut PacketReplicationEngineEntry {
        if let ::std::option::Option::Some(Entity_oneof_entity::packet_replication_engine_entry(_)) = self.entity {
        } else {
            self.entity = ::std::option::Option::Some(Entity_oneof_entity::packet_replication_engine_entry(PacketReplicationEngineEntry::new()));
        }
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::packet_replication_engine_entry(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_packet_replication_engine_entry(&mut self) -> PacketReplicationEngineEntry {
        if self.has_packet_replication_engine_entry() {
            match self.entity.take() {
                ::std::option::Option::Some(Entity_oneof_entity::packet_replication_engine_entry(v)) => v,
                _ => panic!(),
            }
        } else {
            PacketReplicationEngineEntry::new()
        }
    }

    // .p4.v1.ValueSetEntry value_set_entry = 10;


    pub fn get_value_set_entry(&self) -> &ValueSetEntry {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::value_set_entry(ref v)) => v,
            _ => <ValueSetEntry as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_value_set_entry(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_value_set_entry(&self) -> bool {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::value_set_entry(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value_set_entry(&mut self, v: ValueSetEntry) {
        self.entity = ::std::option::Option::Some(Entity_oneof_entity::value_set_entry(v))
    }

    // Mutable pointer to the field.
    pub fn mut_value_set_entry(&mut self) -> &mut ValueSetEntry {
        if let ::std::option::Option::Some(Entity_oneof_entity::value_set_entry(_)) = self.entity {
        } else {
            self.entity = ::std::option::Option::Some(Entity_oneof_entity::value_set_entry(ValueSetEntry::new()));
        }
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::value_set_entry(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_value_set_entry(&mut self) -> ValueSetEntry {
        if self.has_value_set_entry() {
            match self.entity.take() {
                ::std::option::Option::Some(Entity_oneof_entity::value_set_entry(v)) => v,
                _ => panic!(),
            }
        } else {
            ValueSetEntry::new()
        }
    }

    // .p4.v1.RegisterEntry register_entry = 11;


    pub fn get_register_entry(&self) -> &RegisterEntry {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::register_entry(ref v)) => v,
            _ => <RegisterEntry as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_register_entry(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_register_entry(&self) -> bool {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::register_entry(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_register_entry(&mut self, v: RegisterEntry) {
        self.entity = ::std::option::Option::Some(Entity_oneof_entity::register_entry(v))
    }

    // Mutable pointer to the field.
    pub fn mut_register_entry(&mut self) -> &mut RegisterEntry {
        if let ::std::option::Option::Some(Entity_oneof_entity::register_entry(_)) = self.entity {
        } else {
            self.entity = ::std::option::Option::Some(Entity_oneof_entity::register_entry(RegisterEntry::new()));
        }
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::register_entry(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_register_entry(&mut self) -> RegisterEntry {
        if self.has_register_entry() {
            match self.entity.take() {
                ::std::option::Option::Some(Entity_oneof_entity::register_entry(v)) => v,
                _ => panic!(),
            }
        } else {
            RegisterEntry::new()
        }
    }

    // .p4.v1.DigestEntry digest_entry = 12;


    pub fn get_digest_entry(&self) -> &DigestEntry {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::digest_entry(ref v)) => v,
            _ => <DigestEntry as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_digest_entry(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_digest_entry(&self) -> bool {
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::digest_entry(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_digest_entry(&mut self, v: DigestEntry) {
        self.entity = ::std::option::Option::Some(Entity_oneof_entity::digest_entry(v))
    }

    // Mutable pointer to the field.
    pub fn mut_digest_entry(&mut self) -> &mut DigestEntry {
        if let ::std::option::Option::Some(Entity_oneof_entity::digest_entry(_)) = self.entity {
        } else {
            self.entity = ::std::option::Option::Some(Entity_oneof_entity::digest_entry(DigestEntry::new()));
        }
        match self.entity {
            ::std::option::Option::Some(Entity_oneof_entity::digest_entry(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_digest_entry(&mut self) -> DigestEntry {
        if self.has_digest_entry() {
            match self.entity.take() {
                ::std::option::Option::Some(Entity_oneof_entity::digest_entry(v)) => v,
                _ => panic!(),
            }
        } else {
            DigestEntry::new()
        }
    }
}

impl ::protobuf::Message for Entity {
    fn is_initialized(&self) -> bool {
        if let Some(Entity_oneof_entity::extern_entry(ref v)) = self.entity {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Entity_oneof_entity::table_entry(ref v)) = self.entity {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Entity_oneof_entity::action_profile_member(ref v)) = self.entity {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Entity_oneof_entity::action_profile_group(ref v)) = self.entity {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Entity_oneof_entity::meter_entry(ref v)) = self.entity {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Entity_oneof_entity::direct_meter_entry(ref v)) = self.entity {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Entity_oneof_entity::counter_entry(ref v)) = self.entity {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Entity_oneof_entity::direct_counter_entry(ref v)) = self.entity {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Entity_oneof_entity::packet_replication_engine_entry(ref v)) = self.entity {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Entity_oneof_entity::value_set_entry(ref v)) = self.entity {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Entity_oneof_entity::register_entry(ref v)) = self.entity {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Entity_oneof_entity::digest_entry(ref v)) = self.entity {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.entity = ::std::option::Option::Some(Entity_oneof_entity::extern_entry(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.entity = ::std::option::Option::Some(Entity_oneof_entity::table_entry(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.entity = ::std::option::Option::Some(Entity_oneof_entity::action_profile_member(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.entity = ::std::option::Option::Some(Entity_oneof_entity::action_profile_group(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.entity = ::std::option::Option::Some(Entity_oneof_entity::meter_entry(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.entity = ::std::option::Option::Some(Entity_oneof_entity::direct_meter_entry(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.entity = ::std::option::Option::Some(Entity_oneof_entity::counter_entry(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.entity = ::std::option::Option::Some(Entity_oneof_entity::direct_counter_entry(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.entity = ::std::option::Option::Some(Entity_oneof_entity::packet_replication_engine_entry(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.entity = ::std::option::Option::Some(Entity_oneof_entity::value_set_entry(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.entity = ::std::option::Option::Some(Entity_oneof_entity::register_entry(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.entity = ::std::option::Option::Some(Entity_oneof_entity::digest_entry(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.entity {
            match v {
                &Entity_oneof_entity::extern_entry(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Entity_oneof_entity::table_entry(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Entity_oneof_entity::action_profile_member(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Entity_oneof_entity::action_profile_group(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Entity_oneof_entity::meter_entry(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Entity_oneof_entity::direct_meter_entry(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Entity_oneof_entity::counter_entry(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Entity_oneof_entity::direct_counter_entry(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Entity_oneof_entity::packet_replication_engine_entry(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Entity_oneof_entity::value_set_entry(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Entity_oneof_entity::register_entry(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Entity_oneof_entity::digest_entry(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.entity {
            match v {
                &Entity_oneof_entity::extern_entry(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Entity_oneof_entity::table_entry(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Entity_oneof_entity::action_profile_member(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Entity_oneof_entity::action_profile_group(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Entity_oneof_entity::meter_entry(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Entity_oneof_entity::direct_meter_entry(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Entity_oneof_entity::counter_entry(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Entity_oneof_entity::direct_counter_entry(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Entity_oneof_entity::packet_replication_engine_entry(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Entity_oneof_entity::value_set_entry(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Entity_oneof_entity::register_entry(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Entity_oneof_entity::digest_entry(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Entity {
        Entity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ExternEntry>(
                "extern_entry",
                Entity::has_extern_entry,
                Entity::get_extern_entry,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TableEntry>(
                "table_entry",
                Entity::has_table_entry,
                Entity::get_table_entry,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionProfileMember>(
                "action_profile_member",
                Entity::has_action_profile_member,
                Entity::get_action_profile_member,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionProfileGroup>(
                "action_profile_group",
                Entity::has_action_profile_group,
                Entity::get_action_profile_group,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MeterEntry>(
                "meter_entry",
                Entity::has_meter_entry,
                Entity::get_meter_entry,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DirectMeterEntry>(
                "direct_meter_entry",
                Entity::has_direct_meter_entry,
                Entity::get_direct_meter_entry,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CounterEntry>(
                "counter_entry",
                Entity::has_counter_entry,
                Entity::get_counter_entry,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DirectCounterEntry>(
                "direct_counter_entry",
                Entity::has_direct_counter_entry,
                Entity::get_direct_counter_entry,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PacketReplicationEngineEntry>(
                "packet_replication_engine_entry",
                Entity::has_packet_replication_engine_entry,
                Entity::get_packet_replication_engine_entry,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ValueSetEntry>(
                "value_set_entry",
                Entity::has_value_set_entry,
                Entity::get_value_set_entry,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RegisterEntry>(
                "register_entry",
                Entity::has_register_entry,
                Entity::get_register_entry,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DigestEntry>(
                "digest_entry",
                Entity::has_digest_entry,
                Entity::get_digest_entry,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Entity>(
                "Entity",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Entity {
        static instance: ::protobuf::rt::LazyV2<Entity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Entity::new)
    }
}

impl ::protobuf::Clear for Entity {
    fn clear(&mut self) {
        self.entity = ::std::option::Option::None;
        self.entity = ::std::option::Option::None;
        self.entity = ::std::option::Option::None;
        self.entity = ::std::option::Option::None;
        self.entity = ::std::option::Option::None;
        self.entity = ::std::option::Option::None;
        self.entity = ::std::option::Option::None;
        self.entity = ::std::option::Option::None;
        self.entity = ::std::option::Option::None;
        self.entity = ::std::option::Option::None;
        self.entity = ::std::option::Option::None;
        self.entity = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Entity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Entity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExternEntry {
    // message fields
    pub extern_type_id: u32,
    pub extern_id: u32,
    pub entry: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExternEntry {
    fn default() -> &'a ExternEntry {
        <ExternEntry as ::protobuf::Message>::default_instance()
    }
}

impl ExternEntry {
    pub fn new() -> ExternEntry {
        ::std::default::Default::default()
    }

    // uint32 extern_type_id = 1;


    pub fn get_extern_type_id(&self) -> u32 {
        self.extern_type_id
    }
    pub fn clear_extern_type_id(&mut self) {
        self.extern_type_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_extern_type_id(&mut self, v: u32) {
        self.extern_type_id = v;
    }

    // uint32 extern_id = 2;


    pub fn get_extern_id(&self) -> u32 {
        self.extern_id
    }
    pub fn clear_extern_id(&mut self) {
        self.extern_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_extern_id(&mut self, v: u32) {
        self.extern_id = v;
    }

    // .google.protobuf.Any entry = 3;


    pub fn get_entry(&self) -> &::protobuf::well_known_types::Any {
        self.entry.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_entry(&mut self) {
        self.entry.clear();
    }

    pub fn has_entry(&self) -> bool {
        self.entry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entry(&mut self, v: ::protobuf::well_known_types::Any) {
        self.entry = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entry(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.entry.is_none() {
            self.entry.set_default();
        }
        self.entry.as_mut().unwrap()
    }

    // Take field
    pub fn take_entry(&mut self) -> ::protobuf::well_known_types::Any {
        self.entry.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for ExternEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.entry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.extern_type_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.extern_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.entry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.extern_type_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.extern_type_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.extern_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.extern_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.extern_type_id != 0 {
            os.write_uint32(1, self.extern_type_id)?;
        }
        if self.extern_id != 0 {
            os.write_uint32(2, self.extern_id)?;
        }
        if let Some(ref v) = self.entry.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternEntry {
        ExternEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "extern_type_id",
                |m: &ExternEntry| { &m.extern_type_id },
                |m: &mut ExternEntry| { &mut m.extern_type_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "extern_id",
                |m: &ExternEntry| { &m.extern_id },
                |m: &mut ExternEntry| { &mut m.extern_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "entry",
                |m: &ExternEntry| { &m.entry },
                |m: &mut ExternEntry| { &mut m.entry },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExternEntry>(
                "ExternEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternEntry {
        static instance: ::protobuf::rt::LazyV2<ExternEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExternEntry::new)
    }
}

impl ::protobuf::Clear for ExternEntry {
    fn clear(&mut self) {
        self.extern_type_id = 0;
        self.extern_id = 0;
        self.entry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TableEntry {
    // message fields
    pub table_id: u32,
    pub field_match: ::protobuf::RepeatedField<FieldMatch>,
    pub action: ::protobuf::SingularPtrField<TableAction>,
    pub priority: i32,
    pub controller_metadata: u64,
    pub meter_config: ::protobuf::SingularPtrField<MeterConfig>,
    pub counter_data: ::protobuf::SingularPtrField<CounterData>,
    pub is_default_action: bool,
    pub idle_timeout_ns: i64,
    pub time_since_last_hit: ::protobuf::SingularPtrField<TableEntry_IdleTimeout>,
    pub metadata: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TableEntry {
    fn default() -> &'a TableEntry {
        <TableEntry as ::protobuf::Message>::default_instance()
    }
}

impl TableEntry {
    pub fn new() -> TableEntry {
        ::std::default::Default::default()
    }

    // uint32 table_id = 1;


    pub fn get_table_id(&self) -> u32 {
        self.table_id
    }
    pub fn clear_table_id(&mut self) {
        self.table_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_table_id(&mut self, v: u32) {
        self.table_id = v;
    }

    // repeated .p4.v1.FieldMatch match = 2;


    pub fn get_field_match(&self) -> &[FieldMatch] {
        &self.field_match
    }
    pub fn clear_field_match(&mut self) {
        self.field_match.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_match(&mut self, v: ::protobuf::RepeatedField<FieldMatch>) {
        self.field_match = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field_match(&mut self) -> &mut ::protobuf::RepeatedField<FieldMatch> {
        &mut self.field_match
    }

    // Take field
    pub fn take_field_match(&mut self) -> ::protobuf::RepeatedField<FieldMatch> {
        ::std::mem::replace(&mut self.field_match, ::protobuf::RepeatedField::new())
    }

    // .p4.v1.TableAction action = 3;


    pub fn get_action(&self) -> &TableAction {
        self.action.as_ref().unwrap_or_else(|| <TableAction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: TableAction) {
        self.action = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut TableAction {
        if self.action.is_none() {
            self.action.set_default();
        }
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> TableAction {
        self.action.take().unwrap_or_else(|| TableAction::new())
    }

    // int32 priority = 4;


    pub fn get_priority(&self) -> i32 {
        self.priority
    }
    pub fn clear_priority(&mut self) {
        self.priority = 0;
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: i32) {
        self.priority = v;
    }

    // uint64 controller_metadata = 5;


    pub fn get_controller_metadata(&self) -> u64 {
        self.controller_metadata
    }
    pub fn clear_controller_metadata(&mut self) {
        self.controller_metadata = 0;
    }

    // Param is passed by value, moved
    pub fn set_controller_metadata(&mut self, v: u64) {
        self.controller_metadata = v;
    }

    // .p4.v1.MeterConfig meter_config = 6;


    pub fn get_meter_config(&self) -> &MeterConfig {
        self.meter_config.as_ref().unwrap_or_else(|| <MeterConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_meter_config(&mut self) {
        self.meter_config.clear();
    }

    pub fn has_meter_config(&self) -> bool {
        self.meter_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meter_config(&mut self, v: MeterConfig) {
        self.meter_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_meter_config(&mut self) -> &mut MeterConfig {
        if self.meter_config.is_none() {
            self.meter_config.set_default();
        }
        self.meter_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_meter_config(&mut self) -> MeterConfig {
        self.meter_config.take().unwrap_or_else(|| MeterConfig::new())
    }

    // .p4.v1.CounterData counter_data = 7;


    pub fn get_counter_data(&self) -> &CounterData {
        self.counter_data.as_ref().unwrap_or_else(|| <CounterData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_counter_data(&mut self) {
        self.counter_data.clear();
    }

    pub fn has_counter_data(&self) -> bool {
        self.counter_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_counter_data(&mut self, v: CounterData) {
        self.counter_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_counter_data(&mut self) -> &mut CounterData {
        if self.counter_data.is_none() {
            self.counter_data.set_default();
        }
        self.counter_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_counter_data(&mut self) -> CounterData {
        self.counter_data.take().unwrap_or_else(|| CounterData::new())
    }

    // bool is_default_action = 8;


    pub fn get_is_default_action(&self) -> bool {
        self.is_default_action
    }
    pub fn clear_is_default_action(&mut self) {
        self.is_default_action = false;
    }

    // Param is passed by value, moved
    pub fn set_is_default_action(&mut self, v: bool) {
        self.is_default_action = v;
    }

    // int64 idle_timeout_ns = 9;


    pub fn get_idle_timeout_ns(&self) -> i64 {
        self.idle_timeout_ns
    }
    pub fn clear_idle_timeout_ns(&mut self) {
        self.idle_timeout_ns = 0;
    }

    // Param is passed by value, moved
    pub fn set_idle_timeout_ns(&mut self, v: i64) {
        self.idle_timeout_ns = v;
    }

    // .p4.v1.TableEntry.IdleTimeout time_since_last_hit = 10;


    pub fn get_time_since_last_hit(&self) -> &TableEntry_IdleTimeout {
        self.time_since_last_hit.as_ref().unwrap_or_else(|| <TableEntry_IdleTimeout as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time_since_last_hit(&mut self) {
        self.time_since_last_hit.clear();
    }

    pub fn has_time_since_last_hit(&self) -> bool {
        self.time_since_last_hit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_since_last_hit(&mut self, v: TableEntry_IdleTimeout) {
        self.time_since_last_hit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_since_last_hit(&mut self) -> &mut TableEntry_IdleTimeout {
        if self.time_since_last_hit.is_none() {
            self.time_since_last_hit.set_default();
        }
        self.time_since_last_hit.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_since_last_hit(&mut self) -> TableEntry_IdleTimeout {
        self.time_since_last_hit.take().unwrap_or_else(|| TableEntry_IdleTimeout::new())
    }

    // bytes metadata = 11;


    pub fn get_metadata(&self) -> &[u8] {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.metadata, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TableEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.field_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.action {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.meter_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.counter_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.time_since_last_hit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.table_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.field_match)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.action)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.priority = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.controller_metadata = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.meter_config)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.counter_data)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_default_action = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.idle_timeout_ns = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_since_last_hit)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.table_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.table_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.field_match {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.priority != 0 {
            my_size += ::protobuf::rt::value_size(4, self.priority, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.controller_metadata != 0 {
            my_size += ::protobuf::rt::value_size(5, self.controller_metadata, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.meter_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.counter_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_default_action != false {
            my_size += 2;
        }
        if self.idle_timeout_ns != 0 {
            my_size += ::protobuf::rt::value_size(9, self.idle_timeout_ns, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.time_since_last_hit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.metadata.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.metadata);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.table_id != 0 {
            os.write_uint32(1, self.table_id)?;
        }
        for v in &self.field_match {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.action.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.priority != 0 {
            os.write_int32(4, self.priority)?;
        }
        if self.controller_metadata != 0 {
            os.write_uint64(5, self.controller_metadata)?;
        }
        if let Some(ref v) = self.meter_config.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.counter_data.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_default_action != false {
            os.write_bool(8, self.is_default_action)?;
        }
        if self.idle_timeout_ns != 0 {
            os.write_int64(9, self.idle_timeout_ns)?;
        }
        if let Some(ref v) = self.time_since_last_hit.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.metadata.is_empty() {
            os.write_bytes(11, &self.metadata)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TableEntry {
        TableEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "table_id",
                |m: &TableEntry| { &m.table_id },
                |m: &mut TableEntry| { &mut m.table_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldMatch>>(
                "match",
                |m: &TableEntry| { &m.field_match },
                |m: &mut TableEntry| { &mut m.field_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableAction>>(
                "action",
                |m: &TableEntry| { &m.action },
                |m: &mut TableEntry| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "priority",
                |m: &TableEntry| { &m.priority },
                |m: &mut TableEntry| { &mut m.priority },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "controller_metadata",
                |m: &TableEntry| { &m.controller_metadata },
                |m: &mut TableEntry| { &mut m.controller_metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MeterConfig>>(
                "meter_config",
                |m: &TableEntry| { &m.meter_config },
                |m: &mut TableEntry| { &mut m.meter_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CounterData>>(
                "counter_data",
                |m: &TableEntry| { &m.counter_data },
                |m: &mut TableEntry| { &mut m.counter_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_default_action",
                |m: &TableEntry| { &m.is_default_action },
                |m: &mut TableEntry| { &mut m.is_default_action },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "idle_timeout_ns",
                |m: &TableEntry| { &m.idle_timeout_ns },
                |m: &mut TableEntry| { &mut m.idle_timeout_ns },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableEntry_IdleTimeout>>(
                "time_since_last_hit",
                |m: &TableEntry| { &m.time_since_last_hit },
                |m: &mut TableEntry| { &mut m.time_since_last_hit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "metadata",
                |m: &TableEntry| { &m.metadata },
                |m: &mut TableEntry| { &mut m.metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TableEntry>(
                "TableEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TableEntry {
        static instance: ::protobuf::rt::LazyV2<TableEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TableEntry::new)
    }
}

impl ::protobuf::Clear for TableEntry {
    fn clear(&mut self) {
        self.table_id = 0;
        self.field_match.clear();
        self.action.clear();
        self.priority = 0;
        self.controller_metadata = 0;
        self.meter_config.clear();
        self.counter_data.clear();
        self.is_default_action = false;
        self.idle_timeout_ns = 0;
        self.time_since_last_hit.clear();
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TableEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TableEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TableEntry_IdleTimeout {
    // message fields
    pub elapsed_ns: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TableEntry_IdleTimeout {
    fn default() -> &'a TableEntry_IdleTimeout {
        <TableEntry_IdleTimeout as ::protobuf::Message>::default_instance()
    }
}

impl TableEntry_IdleTimeout {
    pub fn new() -> TableEntry_IdleTimeout {
        ::std::default::Default::default()
    }

    // int64 elapsed_ns = 1;


    pub fn get_elapsed_ns(&self) -> i64 {
        self.elapsed_ns
    }
    pub fn clear_elapsed_ns(&mut self) {
        self.elapsed_ns = 0;
    }

    // Param is passed by value, moved
    pub fn set_elapsed_ns(&mut self, v: i64) {
        self.elapsed_ns = v;
    }
}

impl ::protobuf::Message for TableEntry_IdleTimeout {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.elapsed_ns = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.elapsed_ns != 0 {
            my_size += ::protobuf::rt::value_size(1, self.elapsed_ns, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.elapsed_ns != 0 {
            os.write_int64(1, self.elapsed_ns)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TableEntry_IdleTimeout {
        TableEntry_IdleTimeout::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "elapsed_ns",
                |m: &TableEntry_IdleTimeout| { &m.elapsed_ns },
                |m: &mut TableEntry_IdleTimeout| { &mut m.elapsed_ns },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TableEntry_IdleTimeout>(
                "TableEntry.IdleTimeout",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TableEntry_IdleTimeout {
        static instance: ::protobuf::rt::LazyV2<TableEntry_IdleTimeout> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TableEntry_IdleTimeout::new)
    }
}

impl ::protobuf::Clear for TableEntry_IdleTimeout {
    fn clear(&mut self) {
        self.elapsed_ns = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TableEntry_IdleTimeout {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TableEntry_IdleTimeout {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FieldMatch {
    // message fields
    pub field_id: u32,
    // message oneof groups
    pub field_match_type: ::std::option::Option<FieldMatch_oneof_field_match_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FieldMatch {
    fn default() -> &'a FieldMatch {
        <FieldMatch as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum FieldMatch_oneof_field_match_type {
    exact(FieldMatch_Exact),
    ternary(FieldMatch_Ternary),
    lpm(FieldMatch_LPM),
    range(FieldMatch_Range),
    optional(FieldMatch_Optional),
    other(::protobuf::well_known_types::Any),
}

impl FieldMatch {
    pub fn new() -> FieldMatch {
        ::std::default::Default::default()
    }

    // uint32 field_id = 1;


    pub fn get_field_id(&self) -> u32 {
        self.field_id
    }
    pub fn clear_field_id(&mut self) {
        self.field_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_id(&mut self, v: u32) {
        self.field_id = v;
    }

    // .p4.v1.FieldMatch.Exact exact = 2;


    pub fn get_exact(&self) -> &FieldMatch_Exact {
        match self.field_match_type {
            ::std::option::Option::Some(FieldMatch_oneof_field_match_type::exact(ref v)) => v,
            _ => <FieldMatch_Exact as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_exact(&mut self) {
        self.field_match_type = ::std::option::Option::None;
    }

    pub fn has_exact(&self) -> bool {
        match self.field_match_type {
            ::std::option::Option::Some(FieldMatch_oneof_field_match_type::exact(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_exact(&mut self, v: FieldMatch_Exact) {
        self.field_match_type = ::std::option::Option::Some(FieldMatch_oneof_field_match_type::exact(v))
    }

    // Mutable pointer to the field.
    pub fn mut_exact(&mut self) -> &mut FieldMatch_Exact {
        if let ::std::option::Option::Some(FieldMatch_oneof_field_match_type::exact(_)) = self.field_match_type {
        } else {
            self.field_match_type = ::std::option::Option::Some(FieldMatch_oneof_field_match_type::exact(FieldMatch_Exact::new()));
        }
        match self.field_match_type {
            ::std::option::Option::Some(FieldMatch_oneof_field_match_type::exact(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_exact(&mut self) -> FieldMatch_Exact {
        if self.has_exact() {
            match self.field_match_type.take() {
                ::std::option::Option::Some(FieldMatch_oneof_field_match_type::exact(v)) => v,
                _ => panic!(),
            }
        } else {
            FieldMatch_Exact::new()
        }
    }

    // .p4.v1.FieldMatch.Ternary ternary = 3;


    pub fn get_ternary(&self) -> &FieldMatch_Ternary {
        match self.field_match_type {
            ::std::option::Option::Some(FieldMatch_oneof_field_match_type::ternary(ref v)) => v,
            _ => <FieldMatch_Ternary as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_ternary(&mut self) {
        self.field_match_type = ::std::option::Option::None;
    }

    pub fn has_ternary(&self) -> bool {
        match self.field_match_type {
            ::std::option::Option::Some(FieldMatch_oneof_field_match_type::ternary(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ternary(&mut self, v: FieldMatch_Ternary) {
        self.field_match_type = ::std::option::Option::Some(FieldMatch_oneof_field_match_type::ternary(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ternary(&mut self) -> &mut FieldMatch_Ternary {
        if let ::std::option::Option::Some(FieldMatch_oneof_field_match_type::ternary(_)) = self.field_match_type {
        } else {
            self.field_match_type = ::std::option::Option::Some(FieldMatch_oneof_field_match_type::ternary(FieldMatch_Ternary::new()));
        }
        match self.field_match_type {
            ::std::option::Option::Some(FieldMatch_oneof_field_match_type::ternary(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ternary(&mut self) -> FieldMatch_Ternary {
        if self.has_ternary() {
            match self.field_match_type.take() {
                ::std::option::Option::Some(FieldMatch_oneof_field_match_type::ternary(v)) => v,
                _ => panic!(),
            }
        } else {
            FieldMatch_Ternary::new()
        }
    }

    // .p4.v1.FieldMatch.LPM lpm = 4;


    pub fn get_lpm(&self) -> &FieldMatch_LPM {
        match self.field_match_type {
            ::std::option::Option::Some(FieldMatch_oneof_field_match_type::lpm(ref v)) => v,
            _ => <FieldMatch_LPM as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_lpm(&mut self) {
        self.field_match_type = ::std::option::Option::None;
    }

    pub fn has_lpm(&self) -> bool {
        match self.field_match_type {
            ::std::option::Option::Some(FieldMatch_oneof_field_match_type::lpm(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_lpm(&mut self, v: FieldMatch_LPM) {
        self.field_match_type = ::std::option::Option::Some(FieldMatch_oneof_field_match_type::lpm(v))
    }

    // Mutable pointer to the field.
    pub fn mut_lpm(&mut self) -> &mut FieldMatch_LPM {
        if let ::std::option::Option::Some(FieldMatch_oneof_field_match_type::lpm(_)) = self.field_match_type {
        } else {
            self.field_match_type = ::std::option::Option::Some(FieldMatch_oneof_field_match_type::lpm(FieldMatch_LPM::new()));
        }
        match self.field_match_type {
            ::std::option::Option::Some(FieldMatch_oneof_field_match_type::lpm(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_lpm(&mut self) -> FieldMatch_LPM {
        if self.has_lpm() {
            match self.field_match_type.take() {
                ::std::option::Option::Some(FieldMatch_oneof_field_match_type::lpm(v)) => v,
                _ => panic!(),
            }
        } else {
            FieldMatch_LPM::new()
        }
    }

    // .p4.v1.FieldMatch.Range range = 6;


    pub fn get_range(&self) -> &FieldMatch_Range {
        match self.field_match_type {
            ::std::option::Option::Some(FieldMatch_oneof_field_match_type::range(ref v)) => v,
            _ => <FieldMatch_Range as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_range(&mut self) {
        self.field_match_type = ::std::option::Option::None;
    }

    pub fn has_range(&self) -> bool {
        match self.field_match_type {
            ::std::option::Option::Some(FieldMatch_oneof_field_match_type::range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: FieldMatch_Range) {
        self.field_match_type = ::std::option::Option::Some(FieldMatch_oneof_field_match_type::range(v))
    }

    // Mutable pointer to the field.
    pub fn mut_range(&mut self) -> &mut FieldMatch_Range {
        if let ::std::option::Option::Some(FieldMatch_oneof_field_match_type::range(_)) = self.field_match_type {
        } else {
            self.field_match_type = ::std::option::Option::Some(FieldMatch_oneof_field_match_type::range(FieldMatch_Range::new()));
        }
        match self.field_match_type {
            ::std::option::Option::Some(FieldMatch_oneof_field_match_type::range(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_range(&mut self) -> FieldMatch_Range {
        if self.has_range() {
            match self.field_match_type.take() {
                ::std::option::Option::Some(FieldMatch_oneof_field_match_type::range(v)) => v,
                _ => panic!(),
            }
        } else {
            FieldMatch_Range::new()
        }
    }

    // .p4.v1.FieldMatch.Optional optional = 7;


    pub fn get_optional(&self) -> &FieldMatch_Optional {
        match self.field_match_type {
            ::std::option::Option::Some(FieldMatch_oneof_field_match_type::optional(ref v)) => v,
            _ => <FieldMatch_Optional as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_optional(&mut self) {
        self.field_match_type = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        match self.field_match_type {
            ::std::option::Option::Some(FieldMatch_oneof_field_match_type::optional(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: FieldMatch_Optional) {
        self.field_match_type = ::std::option::Option::Some(FieldMatch_oneof_field_match_type::optional(v))
    }

    // Mutable pointer to the field.
    pub fn mut_optional(&mut self) -> &mut FieldMatch_Optional {
        if let ::std::option::Option::Some(FieldMatch_oneof_field_match_type::optional(_)) = self.field_match_type {
        } else {
            self.field_match_type = ::std::option::Option::Some(FieldMatch_oneof_field_match_type::optional(FieldMatch_Optional::new()));
        }
        match self.field_match_type {
            ::std::option::Option::Some(FieldMatch_oneof_field_match_type::optional(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_optional(&mut self) -> FieldMatch_Optional {
        if self.has_optional() {
            match self.field_match_type.take() {
                ::std::option::Option::Some(FieldMatch_oneof_field_match_type::optional(v)) => v,
                _ => panic!(),
            }
        } else {
            FieldMatch_Optional::new()
        }
    }

    // .google.protobuf.Any other = 100;


    pub fn get_other(&self) -> &::protobuf::well_known_types::Any {
        match self.field_match_type {
            ::std::option::Option::Some(FieldMatch_oneof_field_match_type::other(ref v)) => v,
            _ => <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_other(&mut self) {
        self.field_match_type = ::std::option::Option::None;
    }

    pub fn has_other(&self) -> bool {
        match self.field_match_type {
            ::std::option::Option::Some(FieldMatch_oneof_field_match_type::other(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_other(&mut self, v: ::protobuf::well_known_types::Any) {
        self.field_match_type = ::std::option::Option::Some(FieldMatch_oneof_field_match_type::other(v))
    }

    // Mutable pointer to the field.
    pub fn mut_other(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if let ::std::option::Option::Some(FieldMatch_oneof_field_match_type::other(_)) = self.field_match_type {
        } else {
            self.field_match_type = ::std::option::Option::Some(FieldMatch_oneof_field_match_type::other(::protobuf::well_known_types::Any::new()));
        }
        match self.field_match_type {
            ::std::option::Option::Some(FieldMatch_oneof_field_match_type::other(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_other(&mut self) -> ::protobuf::well_known_types::Any {
        if self.has_other() {
            match self.field_match_type.take() {
                ::std::option::Option::Some(FieldMatch_oneof_field_match_type::other(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Any::new()
        }
    }
}

impl ::protobuf::Message for FieldMatch {
    fn is_initialized(&self) -> bool {
        if let Some(FieldMatch_oneof_field_match_type::exact(ref v)) = self.field_match_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FieldMatch_oneof_field_match_type::ternary(ref v)) = self.field_match_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FieldMatch_oneof_field_match_type::lpm(ref v)) = self.field_match_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FieldMatch_oneof_field_match_type::range(ref v)) = self.field_match_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FieldMatch_oneof_field_match_type::optional(ref v)) = self.field_match_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FieldMatch_oneof_field_match_type::other(ref v)) = self.field_match_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_match_type = ::std::option::Option::Some(FieldMatch_oneof_field_match_type::exact(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_match_type = ::std::option::Option::Some(FieldMatch_oneof_field_match_type::ternary(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_match_type = ::std::option::Option::Some(FieldMatch_oneof_field_match_type::lpm(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_match_type = ::std::option::Option::Some(FieldMatch_oneof_field_match_type::range(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_match_type = ::std::option::Option::Some(FieldMatch_oneof_field_match_type::optional(is.read_message()?));
                },
                100 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_match_type = ::std::option::Option::Some(FieldMatch_oneof_field_match_type::other(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.field_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.field_match_type {
            match v {
                &FieldMatch_oneof_field_match_type::exact(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FieldMatch_oneof_field_match_type::ternary(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FieldMatch_oneof_field_match_type::lpm(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FieldMatch_oneof_field_match_type::range(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FieldMatch_oneof_field_match_type::optional(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FieldMatch_oneof_field_match_type::other(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_id != 0 {
            os.write_uint32(1, self.field_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.field_match_type {
            match v {
                &FieldMatch_oneof_field_match_type::exact(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FieldMatch_oneof_field_match_type::ternary(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FieldMatch_oneof_field_match_type::lpm(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FieldMatch_oneof_field_match_type::range(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FieldMatch_oneof_field_match_type::optional(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FieldMatch_oneof_field_match_type::other(ref v) => {
                    os.write_tag(100, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FieldMatch {
        FieldMatch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "field_id",
                |m: &FieldMatch| { &m.field_id },
                |m: &mut FieldMatch| { &mut m.field_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FieldMatch_Exact>(
                "exact",
                FieldMatch::has_exact,
                FieldMatch::get_exact,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FieldMatch_Ternary>(
                "ternary",
                FieldMatch::has_ternary,
                FieldMatch::get_ternary,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FieldMatch_LPM>(
                "lpm",
                FieldMatch::has_lpm,
                FieldMatch::get_lpm,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FieldMatch_Range>(
                "range",
                FieldMatch::has_range,
                FieldMatch::get_range,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FieldMatch_Optional>(
                "optional",
                FieldMatch::has_optional,
                FieldMatch::get_optional,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Any>(
                "other",
                FieldMatch::has_other,
                FieldMatch::get_other,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FieldMatch>(
                "FieldMatch",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FieldMatch {
        static instance: ::protobuf::rt::LazyV2<FieldMatch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FieldMatch::new)
    }
}

impl ::protobuf::Clear for FieldMatch {
    fn clear(&mut self) {
        self.field_id = 0;
        self.field_match_type = ::std::option::Option::None;
        self.field_match_type = ::std::option::Option::None;
        self.field_match_type = ::std::option::Option::None;
        self.field_match_type = ::std::option::Option::None;
        self.field_match_type = ::std::option::Option::None;
        self.field_match_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FieldMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FieldMatch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FieldMatch_Exact {
    // message fields
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FieldMatch_Exact {
    fn default() -> &'a FieldMatch_Exact {
        <FieldMatch_Exact as ::protobuf::Message>::default_instance()
    }
}

impl FieldMatch_Exact {
    pub fn new() -> FieldMatch_Exact {
        ::std::default::Default::default()
    }

    // bytes value = 1;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FieldMatch_Exact {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_bytes(1, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FieldMatch_Exact {
        FieldMatch_Exact::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &FieldMatch_Exact| { &m.value },
                |m: &mut FieldMatch_Exact| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FieldMatch_Exact>(
                "FieldMatch.Exact",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FieldMatch_Exact {
        static instance: ::protobuf::rt::LazyV2<FieldMatch_Exact> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FieldMatch_Exact::new)
    }
}

impl ::protobuf::Clear for FieldMatch_Exact {
    fn clear(&mut self) {
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FieldMatch_Exact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FieldMatch_Exact {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FieldMatch_Ternary {
    // message fields
    pub value: ::std::vec::Vec<u8>,
    pub mask: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FieldMatch_Ternary {
    fn default() -> &'a FieldMatch_Ternary {
        <FieldMatch_Ternary as ::protobuf::Message>::default_instance()
    }
}

impl FieldMatch_Ternary {
    pub fn new() -> FieldMatch_Ternary {
        ::std::default::Default::default()
    }

    // bytes value = 1;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // bytes mask = 2;


    pub fn get_mask(&self) -> &[u8] {
        &self.mask
    }
    pub fn clear_mask(&mut self) {
        self.mask.clear();
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: ::std::vec::Vec<u8>) {
        self.mask = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mask(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.mask
    }

    // Take field
    pub fn take_mask(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.mask, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FieldMatch_Ternary {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.value);
        }
        if !self.mask.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.mask);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_bytes(1, &self.value)?;
        }
        if !self.mask.is_empty() {
            os.write_bytes(2, &self.mask)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FieldMatch_Ternary {
        FieldMatch_Ternary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &FieldMatch_Ternary| { &m.value },
                |m: &mut FieldMatch_Ternary| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "mask",
                |m: &FieldMatch_Ternary| { &m.mask },
                |m: &mut FieldMatch_Ternary| { &mut m.mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FieldMatch_Ternary>(
                "FieldMatch.Ternary",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FieldMatch_Ternary {
        static instance: ::protobuf::rt::LazyV2<FieldMatch_Ternary> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FieldMatch_Ternary::new)
    }
}

impl ::protobuf::Clear for FieldMatch_Ternary {
    fn clear(&mut self) {
        self.value.clear();
        self.mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FieldMatch_Ternary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FieldMatch_Ternary {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FieldMatch_LPM {
    // message fields
    pub value: ::std::vec::Vec<u8>,
    pub prefix_len: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FieldMatch_LPM {
    fn default() -> &'a FieldMatch_LPM {
        <FieldMatch_LPM as ::protobuf::Message>::default_instance()
    }
}

impl FieldMatch_LPM {
    pub fn new() -> FieldMatch_LPM {
        ::std::default::Default::default()
    }

    // bytes value = 1;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // int32 prefix_len = 2;


    pub fn get_prefix_len(&self) -> i32 {
        self.prefix_len
    }
    pub fn clear_prefix_len(&mut self) {
        self.prefix_len = 0;
    }

    // Param is passed by value, moved
    pub fn set_prefix_len(&mut self, v: i32) {
        self.prefix_len = v;
    }
}

impl ::protobuf::Message for FieldMatch_LPM {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.prefix_len = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.value);
        }
        if self.prefix_len != 0 {
            my_size += ::protobuf::rt::value_size(2, self.prefix_len, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_bytes(1, &self.value)?;
        }
        if self.prefix_len != 0 {
            os.write_int32(2, self.prefix_len)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FieldMatch_LPM {
        FieldMatch_LPM::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &FieldMatch_LPM| { &m.value },
                |m: &mut FieldMatch_LPM| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "prefix_len",
                |m: &FieldMatch_LPM| { &m.prefix_len },
                |m: &mut FieldMatch_LPM| { &mut m.prefix_len },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FieldMatch_LPM>(
                "FieldMatch.LPM",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FieldMatch_LPM {
        static instance: ::protobuf::rt::LazyV2<FieldMatch_LPM> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FieldMatch_LPM::new)
    }
}

impl ::protobuf::Clear for FieldMatch_LPM {
    fn clear(&mut self) {
        self.value.clear();
        self.prefix_len = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FieldMatch_LPM {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FieldMatch_LPM {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FieldMatch_Range {
    // message fields
    pub low: ::std::vec::Vec<u8>,
    pub high: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FieldMatch_Range {
    fn default() -> &'a FieldMatch_Range {
        <FieldMatch_Range as ::protobuf::Message>::default_instance()
    }
}

impl FieldMatch_Range {
    pub fn new() -> FieldMatch_Range {
        ::std::default::Default::default()
    }

    // bytes low = 1;


    pub fn get_low(&self) -> &[u8] {
        &self.low
    }
    pub fn clear_low(&mut self) {
        self.low.clear();
    }

    // Param is passed by value, moved
    pub fn set_low(&mut self, v: ::std::vec::Vec<u8>) {
        self.low = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_low(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.low
    }

    // Take field
    pub fn take_low(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.low, ::std::vec::Vec::new())
    }

    // bytes high = 2;


    pub fn get_high(&self) -> &[u8] {
        &self.high
    }
    pub fn clear_high(&mut self) {
        self.high.clear();
    }

    // Param is passed by value, moved
    pub fn set_high(&mut self, v: ::std::vec::Vec<u8>) {
        self.high = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_high(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.high
    }

    // Take field
    pub fn take_high(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.high, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FieldMatch_Range {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.low)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.high)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.low.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.low);
        }
        if !self.high.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.high);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.low.is_empty() {
            os.write_bytes(1, &self.low)?;
        }
        if !self.high.is_empty() {
            os.write_bytes(2, &self.high)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FieldMatch_Range {
        FieldMatch_Range::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "low",
                |m: &FieldMatch_Range| { &m.low },
                |m: &mut FieldMatch_Range| { &mut m.low },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "high",
                |m: &FieldMatch_Range| { &m.high },
                |m: &mut FieldMatch_Range| { &mut m.high },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FieldMatch_Range>(
                "FieldMatch.Range",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FieldMatch_Range {
        static instance: ::protobuf::rt::LazyV2<FieldMatch_Range> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FieldMatch_Range::new)
    }
}

impl ::protobuf::Clear for FieldMatch_Range {
    fn clear(&mut self) {
        self.low.clear();
        self.high.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FieldMatch_Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FieldMatch_Range {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FieldMatch_Optional {
    // message fields
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FieldMatch_Optional {
    fn default() -> &'a FieldMatch_Optional {
        <FieldMatch_Optional as ::protobuf::Message>::default_instance()
    }
}

impl FieldMatch_Optional {
    pub fn new() -> FieldMatch_Optional {
        ::std::default::Default::default()
    }

    // bytes value = 1;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FieldMatch_Optional {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_bytes(1, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FieldMatch_Optional {
        FieldMatch_Optional::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &FieldMatch_Optional| { &m.value },
                |m: &mut FieldMatch_Optional| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FieldMatch_Optional>(
                "FieldMatch.Optional",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FieldMatch_Optional {
        static instance: ::protobuf::rt::LazyV2<FieldMatch_Optional> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FieldMatch_Optional::new)
    }
}

impl ::protobuf::Clear for FieldMatch_Optional {
    fn clear(&mut self) {
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FieldMatch_Optional {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FieldMatch_Optional {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TableAction {
    // message oneof groups
    pub field_type: ::std::option::Option<TableAction_oneof_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TableAction {
    fn default() -> &'a TableAction {
        <TableAction as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TableAction_oneof_type {
    action(Action),
    action_profile_member_id(u32),
    action_profile_group_id(u32),
    action_profile_action_set(ActionProfileActionSet),
}

impl TableAction {
    pub fn new() -> TableAction {
        ::std::default::Default::default()
    }

    // .p4.v1.Action action = 1;


    pub fn get_action(&self) -> &Action {
        match self.field_type {
            ::std::option::Option::Some(TableAction_oneof_type::action(ref v)) => v,
            _ => <Action as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_action(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(TableAction_oneof_type::action(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: Action) {
        self.field_type = ::std::option::Option::Some(TableAction_oneof_type::action(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action(&mut self) -> &mut Action {
        if let ::std::option::Option::Some(TableAction_oneof_type::action(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(TableAction_oneof_type::action(Action::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(TableAction_oneof_type::action(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action(&mut self) -> Action {
        if self.has_action() {
            match self.field_type.take() {
                ::std::option::Option::Some(TableAction_oneof_type::action(v)) => v,
                _ => panic!(),
            }
        } else {
            Action::new()
        }
    }

    // uint32 action_profile_member_id = 2;


    pub fn get_action_profile_member_id(&self) -> u32 {
        match self.field_type {
            ::std::option::Option::Some(TableAction_oneof_type::action_profile_member_id(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_action_profile_member_id(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_action_profile_member_id(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(TableAction_oneof_type::action_profile_member_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_profile_member_id(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(TableAction_oneof_type::action_profile_member_id(v))
    }

    // uint32 action_profile_group_id = 3;


    pub fn get_action_profile_group_id(&self) -> u32 {
        match self.field_type {
            ::std::option::Option::Some(TableAction_oneof_type::action_profile_group_id(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_action_profile_group_id(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_action_profile_group_id(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(TableAction_oneof_type::action_profile_group_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_profile_group_id(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(TableAction_oneof_type::action_profile_group_id(v))
    }

    // .p4.v1.ActionProfileActionSet action_profile_action_set = 4;


    pub fn get_action_profile_action_set(&self) -> &ActionProfileActionSet {
        match self.field_type {
            ::std::option::Option::Some(TableAction_oneof_type::action_profile_action_set(ref v)) => v,
            _ => <ActionProfileActionSet as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_action_profile_action_set(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_action_profile_action_set(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(TableAction_oneof_type::action_profile_action_set(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action_profile_action_set(&mut self, v: ActionProfileActionSet) {
        self.field_type = ::std::option::Option::Some(TableAction_oneof_type::action_profile_action_set(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action_profile_action_set(&mut self) -> &mut ActionProfileActionSet {
        if let ::std::option::Option::Some(TableAction_oneof_type::action_profile_action_set(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(TableAction_oneof_type::action_profile_action_set(ActionProfileActionSet::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(TableAction_oneof_type::action_profile_action_set(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action_profile_action_set(&mut self) -> ActionProfileActionSet {
        if self.has_action_profile_action_set() {
            match self.field_type.take() {
                ::std::option::Option::Some(TableAction_oneof_type::action_profile_action_set(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionProfileActionSet::new()
        }
    }
}

impl ::protobuf::Message for TableAction {
    fn is_initialized(&self) -> bool {
        if let Some(TableAction_oneof_type::action(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TableAction_oneof_type::action_profile_action_set(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(TableAction_oneof_type::action(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(TableAction_oneof_type::action_profile_member_id(is.read_uint32()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(TableAction_oneof_type::action_profile_group_id(is.read_uint32()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(TableAction_oneof_type::action_profile_action_set(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &TableAction_oneof_type::action(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TableAction_oneof_type::action_profile_member_id(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &TableAction_oneof_type::action_profile_group_id(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &TableAction_oneof_type::action_profile_action_set(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &TableAction_oneof_type::action(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TableAction_oneof_type::action_profile_member_id(v) => {
                    os.write_uint32(2, v)?;
                },
                &TableAction_oneof_type::action_profile_group_id(v) => {
                    os.write_uint32(3, v)?;
                },
                &TableAction_oneof_type::action_profile_action_set(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TableAction {
        TableAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Action>(
                "action",
                TableAction::has_action,
                TableAction::get_action,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "action_profile_member_id",
                TableAction::has_action_profile_member_id,
                TableAction::get_action_profile_member_id,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "action_profile_group_id",
                TableAction::has_action_profile_group_id,
                TableAction::get_action_profile_group_id,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionProfileActionSet>(
                "action_profile_action_set",
                TableAction::has_action_profile_action_set,
                TableAction::get_action_profile_action_set,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TableAction>(
                "TableAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TableAction {
        static instance: ::protobuf::rt::LazyV2<TableAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TableAction::new)
    }
}

impl ::protobuf::Clear for TableAction {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TableAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TableAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Action {
    // message fields
    pub action_id: u32,
    pub params: ::protobuf::RepeatedField<Action_Param>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Action {
    fn default() -> &'a Action {
        <Action as ::protobuf::Message>::default_instance()
    }
}

impl Action {
    pub fn new() -> Action {
        ::std::default::Default::default()
    }

    // uint32 action_id = 1;


    pub fn get_action_id(&self) -> u32 {
        self.action_id
    }
    pub fn clear_action_id(&mut self) {
        self.action_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_action_id(&mut self, v: u32) {
        self.action_id = v;
    }

    // repeated .p4.v1.Action.Param params = 4;


    pub fn get_params(&self) -> &[Action_Param] {
        &self.params
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::protobuf::RepeatedField<Action_Param>) {
        self.params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_params(&mut self) -> &mut ::protobuf::RepeatedField<Action_Param> {
        &mut self.params
    }

    // Take field
    pub fn take_params(&mut self) -> ::protobuf::RepeatedField<Action_Param> {
        ::std::mem::replace(&mut self.params, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Action {
    fn is_initialized(&self) -> bool {
        for v in &self.params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.action_id = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.action_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.action_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.params {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.action_id != 0 {
            os.write_uint32(1, self.action_id)?;
        }
        for v in &self.params {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Action {
        Action::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "action_id",
                |m: &Action| { &m.action_id },
                |m: &mut Action| { &mut m.action_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Action_Param>>(
                "params",
                |m: &Action| { &m.params },
                |m: &mut Action| { &mut m.params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Action>(
                "Action",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Action {
        static instance: ::protobuf::rt::LazyV2<Action> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Action::new)
    }
}

impl ::protobuf::Clear for Action {
    fn clear(&mut self) {
        self.action_id = 0;
        self.params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Action {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Action {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Action_Param {
    // message fields
    pub param_id: u32,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Action_Param {
    fn default() -> &'a Action_Param {
        <Action_Param as ::protobuf::Message>::default_instance()
    }
}

impl Action_Param {
    pub fn new() -> Action_Param {
        ::std::default::Default::default()
    }

    // uint32 param_id = 2;


    pub fn get_param_id(&self) -> u32 {
        self.param_id
    }
    pub fn clear_param_id(&mut self) {
        self.param_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_param_id(&mut self, v: u32) {
        self.param_id = v;
    }

    // bytes value = 3;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Action_Param {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.param_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.param_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.param_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.param_id != 0 {
            os.write_uint32(2, self.param_id)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(3, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Action_Param {
        Action_Param::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "param_id",
                |m: &Action_Param| { &m.param_id },
                |m: &mut Action_Param| { &mut m.param_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &Action_Param| { &m.value },
                |m: &mut Action_Param| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Action_Param>(
                "Action.Param",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Action_Param {
        static instance: ::protobuf::rt::LazyV2<Action_Param> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Action_Param::new)
    }
}

impl ::protobuf::Clear for Action_Param {
    fn clear(&mut self) {
        self.param_id = 0;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Action_Param {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Action_Param {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionProfileActionSet {
    // message fields
    pub action_profile_actions: ::protobuf::RepeatedField<ActionProfileAction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionProfileActionSet {
    fn default() -> &'a ActionProfileActionSet {
        <ActionProfileActionSet as ::protobuf::Message>::default_instance()
    }
}

impl ActionProfileActionSet {
    pub fn new() -> ActionProfileActionSet {
        ::std::default::Default::default()
    }

    // repeated .p4.v1.ActionProfileAction action_profile_actions = 1;


    pub fn get_action_profile_actions(&self) -> &[ActionProfileAction] {
        &self.action_profile_actions
    }
    pub fn clear_action_profile_actions(&mut self) {
        self.action_profile_actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_action_profile_actions(&mut self, v: ::protobuf::RepeatedField<ActionProfileAction>) {
        self.action_profile_actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_action_profile_actions(&mut self) -> &mut ::protobuf::RepeatedField<ActionProfileAction> {
        &mut self.action_profile_actions
    }

    // Take field
    pub fn take_action_profile_actions(&mut self) -> ::protobuf::RepeatedField<ActionProfileAction> {
        ::std::mem::replace(&mut self.action_profile_actions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ActionProfileActionSet {
    fn is_initialized(&self) -> bool {
        for v in &self.action_profile_actions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.action_profile_actions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.action_profile_actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.action_profile_actions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionProfileActionSet {
        ActionProfileActionSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ActionProfileAction>>(
                "action_profile_actions",
                |m: &ActionProfileActionSet| { &m.action_profile_actions },
                |m: &mut ActionProfileActionSet| { &mut m.action_profile_actions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionProfileActionSet>(
                "ActionProfileActionSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionProfileActionSet {
        static instance: ::protobuf::rt::LazyV2<ActionProfileActionSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionProfileActionSet::new)
    }
}

impl ::protobuf::Clear for ActionProfileActionSet {
    fn clear(&mut self) {
        self.action_profile_actions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionProfileActionSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionProfileActionSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionProfileAction {
    // message fields
    pub action: ::protobuf::SingularPtrField<Action>,
    pub weight: i32,
    // message oneof groups
    pub watch_kind: ::std::option::Option<ActionProfileAction_oneof_watch_kind>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionProfileAction {
    fn default() -> &'a ActionProfileAction {
        <ActionProfileAction as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ActionProfileAction_oneof_watch_kind {
    watch(i32),
    watch_port(::std::vec::Vec<u8>),
}

impl ActionProfileAction {
    pub fn new() -> ActionProfileAction {
        ::std::default::Default::default()
    }

    // .p4.v1.Action action = 1;


    pub fn get_action(&self) -> &Action {
        self.action.as_ref().unwrap_or_else(|| <Action as ::protobuf::Message>::default_instance())
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: Action) {
        self.action = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut Action {
        if self.action.is_none() {
            self.action.set_default();
        }
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> Action {
        self.action.take().unwrap_or_else(|| Action::new())
    }

    // int32 weight = 2;


    pub fn get_weight(&self) -> i32 {
        self.weight
    }
    pub fn clear_weight(&mut self) {
        self.weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: i32) {
        self.weight = v;
    }

    // int32 watch = 3;


    pub fn get_watch(&self) -> i32 {
        match self.watch_kind {
            ::std::option::Option::Some(ActionProfileAction_oneof_watch_kind::watch(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_watch(&mut self) {
        self.watch_kind = ::std::option::Option::None;
    }

    pub fn has_watch(&self) -> bool {
        match self.watch_kind {
            ::std::option::Option::Some(ActionProfileAction_oneof_watch_kind::watch(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_watch(&mut self, v: i32) {
        self.watch_kind = ::std::option::Option::Some(ActionProfileAction_oneof_watch_kind::watch(v))
    }

    // bytes watch_port = 4;


    pub fn get_watch_port(&self) -> &[u8] {
        match self.watch_kind {
            ::std::option::Option::Some(ActionProfileAction_oneof_watch_kind::watch_port(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_watch_port(&mut self) {
        self.watch_kind = ::std::option::Option::None;
    }

    pub fn has_watch_port(&self) -> bool {
        match self.watch_kind {
            ::std::option::Option::Some(ActionProfileAction_oneof_watch_kind::watch_port(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_watch_port(&mut self, v: ::std::vec::Vec<u8>) {
        self.watch_kind = ::std::option::Option::Some(ActionProfileAction_oneof_watch_kind::watch_port(v))
    }

    // Mutable pointer to the field.
    pub fn mut_watch_port(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ActionProfileAction_oneof_watch_kind::watch_port(_)) = self.watch_kind {
        } else {
            self.watch_kind = ::std::option::Option::Some(ActionProfileAction_oneof_watch_kind::watch_port(::std::vec::Vec::new()));
        }
        match self.watch_kind {
            ::std::option::Option::Some(ActionProfileAction_oneof_watch_kind::watch_port(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_watch_port(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_watch_port() {
            match self.watch_kind.take() {
                ::std::option::Option::Some(ActionProfileAction_oneof_watch_kind::watch_port(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }
}

impl ::protobuf::Message for ActionProfileAction {
    fn is_initialized(&self) -> bool {
        for v in &self.action {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.action)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.weight = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.watch_kind = ::std::option::Option::Some(ActionProfileAction_oneof_watch_kind::watch(is.read_int32()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.watch_kind = ::std::option::Option::Some(ActionProfileAction_oneof_watch_kind::watch_port(is.read_bytes()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.weight != 0 {
            my_size += ::protobuf::rt::value_size(2, self.weight, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.watch_kind {
            match v {
                &ActionProfileAction_oneof_watch_kind::watch(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &ActionProfileAction_oneof_watch_kind::watch_port(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.action.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.weight != 0 {
            os.write_int32(2, self.weight)?;
        }
        if let ::std::option::Option::Some(ref v) = self.watch_kind {
            match v {
                &ActionProfileAction_oneof_watch_kind::watch(v) => {
                    os.write_int32(3, v)?;
                },
                &ActionProfileAction_oneof_watch_kind::watch_port(ref v) => {
                    os.write_bytes(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionProfileAction {
        ActionProfileAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Action>>(
                "action",
                |m: &ActionProfileAction| { &m.action },
                |m: &mut ActionProfileAction| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "weight",
                |m: &ActionProfileAction| { &m.weight },
                |m: &mut ActionProfileAction| { &mut m.weight },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "watch",
                ActionProfileAction::has_watch,
                ActionProfileAction::get_watch,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "watch_port",
                ActionProfileAction::has_watch_port,
                ActionProfileAction::get_watch_port,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionProfileAction>(
                "ActionProfileAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionProfileAction {
        static instance: ::protobuf::rt::LazyV2<ActionProfileAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionProfileAction::new)
    }
}

impl ::protobuf::Clear for ActionProfileAction {
    fn clear(&mut self) {
        self.action.clear();
        self.weight = 0;
        self.watch_kind = ::std::option::Option::None;
        self.watch_kind = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionProfileAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionProfileAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionProfileMember {
    // message fields
    pub action_profile_id: u32,
    pub member_id: u32,
    pub action: ::protobuf::SingularPtrField<Action>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionProfileMember {
    fn default() -> &'a ActionProfileMember {
        <ActionProfileMember as ::protobuf::Message>::default_instance()
    }
}

impl ActionProfileMember {
    pub fn new() -> ActionProfileMember {
        ::std::default::Default::default()
    }

    // uint32 action_profile_id = 1;


    pub fn get_action_profile_id(&self) -> u32 {
        self.action_profile_id
    }
    pub fn clear_action_profile_id(&mut self) {
        self.action_profile_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_action_profile_id(&mut self, v: u32) {
        self.action_profile_id = v;
    }

    // uint32 member_id = 2;


    pub fn get_member_id(&self) -> u32 {
        self.member_id
    }
    pub fn clear_member_id(&mut self) {
        self.member_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_member_id(&mut self, v: u32) {
        self.member_id = v;
    }

    // .p4.v1.Action action = 3;


    pub fn get_action(&self) -> &Action {
        self.action.as_ref().unwrap_or_else(|| <Action as ::protobuf::Message>::default_instance())
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: Action) {
        self.action = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut Action {
        if self.action.is_none() {
            self.action.set_default();
        }
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> Action {
        self.action.take().unwrap_or_else(|| Action::new())
    }
}

impl ::protobuf::Message for ActionProfileMember {
    fn is_initialized(&self) -> bool {
        for v in &self.action {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.action_profile_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.member_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.action_profile_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.action_profile_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.member_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.member_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.action_profile_id != 0 {
            os.write_uint32(1, self.action_profile_id)?;
        }
        if self.member_id != 0 {
            os.write_uint32(2, self.member_id)?;
        }
        if let Some(ref v) = self.action.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionProfileMember {
        ActionProfileMember::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "action_profile_id",
                |m: &ActionProfileMember| { &m.action_profile_id },
                |m: &mut ActionProfileMember| { &mut m.action_profile_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "member_id",
                |m: &ActionProfileMember| { &m.member_id },
                |m: &mut ActionProfileMember| { &mut m.member_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Action>>(
                "action",
                |m: &ActionProfileMember| { &m.action },
                |m: &mut ActionProfileMember| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionProfileMember>(
                "ActionProfileMember",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionProfileMember {
        static instance: ::protobuf::rt::LazyV2<ActionProfileMember> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionProfileMember::new)
    }
}

impl ::protobuf::Clear for ActionProfileMember {
    fn clear(&mut self) {
        self.action_profile_id = 0;
        self.member_id = 0;
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionProfileMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionProfileMember {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionProfileGroup {
    // message fields
    pub action_profile_id: u32,
    pub group_id: u32,
    pub members: ::protobuf::RepeatedField<ActionProfileGroup_Member>,
    pub max_size: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionProfileGroup {
    fn default() -> &'a ActionProfileGroup {
        <ActionProfileGroup as ::protobuf::Message>::default_instance()
    }
}

impl ActionProfileGroup {
    pub fn new() -> ActionProfileGroup {
        ::std::default::Default::default()
    }

    // uint32 action_profile_id = 1;


    pub fn get_action_profile_id(&self) -> u32 {
        self.action_profile_id
    }
    pub fn clear_action_profile_id(&mut self) {
        self.action_profile_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_action_profile_id(&mut self, v: u32) {
        self.action_profile_id = v;
    }

    // uint32 group_id = 2;


    pub fn get_group_id(&self) -> u32 {
        self.group_id
    }
    pub fn clear_group_id(&mut self) {
        self.group_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u32) {
        self.group_id = v;
    }

    // repeated .p4.v1.ActionProfileGroup.Member members = 3;


    pub fn get_members(&self) -> &[ActionProfileGroup_Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<ActionProfileGroup_Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<ActionProfileGroup_Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<ActionProfileGroup_Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    // int32 max_size = 4;


    pub fn get_max_size(&self) -> i32 {
        self.max_size
    }
    pub fn clear_max_size(&mut self) {
        self.max_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_size(&mut self, v: i32) {
        self.max_size = v;
    }
}

impl ::protobuf::Message for ActionProfileGroup {
    fn is_initialized(&self) -> bool {
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.action_profile_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.group_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.action_profile_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.action_profile_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.group_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.group_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.max_size != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.action_profile_id != 0 {
            os.write_uint32(1, self.action_profile_id)?;
        }
        if self.group_id != 0 {
            os.write_uint32(2, self.group_id)?;
        }
        for v in &self.members {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.max_size != 0 {
            os.write_int32(4, self.max_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionProfileGroup {
        ActionProfileGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "action_profile_id",
                |m: &ActionProfileGroup| { &m.action_profile_id },
                |m: &mut ActionProfileGroup| { &mut m.action_profile_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "group_id",
                |m: &ActionProfileGroup| { &m.group_id },
                |m: &mut ActionProfileGroup| { &mut m.group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ActionProfileGroup_Member>>(
                "members",
                |m: &ActionProfileGroup| { &m.members },
                |m: &mut ActionProfileGroup| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_size",
                |m: &ActionProfileGroup| { &m.max_size },
                |m: &mut ActionProfileGroup| { &mut m.max_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionProfileGroup>(
                "ActionProfileGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionProfileGroup {
        static instance: ::protobuf::rt::LazyV2<ActionProfileGroup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionProfileGroup::new)
    }
}

impl ::protobuf::Clear for ActionProfileGroup {
    fn clear(&mut self) {
        self.action_profile_id = 0;
        self.group_id = 0;
        self.members.clear();
        self.max_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionProfileGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionProfileGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionProfileGroup_Member {
    // message fields
    pub member_id: u32,
    pub weight: i32,
    // message oneof groups
    pub watch_kind: ::std::option::Option<ActionProfileGroup_Member_oneof_watch_kind>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionProfileGroup_Member {
    fn default() -> &'a ActionProfileGroup_Member {
        <ActionProfileGroup_Member as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ActionProfileGroup_Member_oneof_watch_kind {
    watch(i32),
    watch_port(::std::vec::Vec<u8>),
}

impl ActionProfileGroup_Member {
    pub fn new() -> ActionProfileGroup_Member {
        ::std::default::Default::default()
    }

    // uint32 member_id = 1;


    pub fn get_member_id(&self) -> u32 {
        self.member_id
    }
    pub fn clear_member_id(&mut self) {
        self.member_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_member_id(&mut self, v: u32) {
        self.member_id = v;
    }

    // int32 weight = 2;


    pub fn get_weight(&self) -> i32 {
        self.weight
    }
    pub fn clear_weight(&mut self) {
        self.weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: i32) {
        self.weight = v;
    }

    // int32 watch = 3;


    pub fn get_watch(&self) -> i32 {
        match self.watch_kind {
            ::std::option::Option::Some(ActionProfileGroup_Member_oneof_watch_kind::watch(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_watch(&mut self) {
        self.watch_kind = ::std::option::Option::None;
    }

    pub fn has_watch(&self) -> bool {
        match self.watch_kind {
            ::std::option::Option::Some(ActionProfileGroup_Member_oneof_watch_kind::watch(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_watch(&mut self, v: i32) {
        self.watch_kind = ::std::option::Option::Some(ActionProfileGroup_Member_oneof_watch_kind::watch(v))
    }

    // bytes watch_port = 4;


    pub fn get_watch_port(&self) -> &[u8] {
        match self.watch_kind {
            ::std::option::Option::Some(ActionProfileGroup_Member_oneof_watch_kind::watch_port(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_watch_port(&mut self) {
        self.watch_kind = ::std::option::Option::None;
    }

    pub fn has_watch_port(&self) -> bool {
        match self.watch_kind {
            ::std::option::Option::Some(ActionProfileGroup_Member_oneof_watch_kind::watch_port(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_watch_port(&mut self, v: ::std::vec::Vec<u8>) {
        self.watch_kind = ::std::option::Option::Some(ActionProfileGroup_Member_oneof_watch_kind::watch_port(v))
    }

    // Mutable pointer to the field.
    pub fn mut_watch_port(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ActionProfileGroup_Member_oneof_watch_kind::watch_port(_)) = self.watch_kind {
        } else {
            self.watch_kind = ::std::option::Option::Some(ActionProfileGroup_Member_oneof_watch_kind::watch_port(::std::vec::Vec::new()));
        }
        match self.watch_kind {
            ::std::option::Option::Some(ActionProfileGroup_Member_oneof_watch_kind::watch_port(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_watch_port(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_watch_port() {
            match self.watch_kind.take() {
                ::std::option::Option::Some(ActionProfileGroup_Member_oneof_watch_kind::watch_port(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }
}

impl ::protobuf::Message for ActionProfileGroup_Member {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.member_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.weight = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.watch_kind = ::std::option::Option::Some(ActionProfileGroup_Member_oneof_watch_kind::watch(is.read_int32()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.watch_kind = ::std::option::Option::Some(ActionProfileGroup_Member_oneof_watch_kind::watch_port(is.read_bytes()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.member_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.member_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.weight != 0 {
            my_size += ::protobuf::rt::value_size(2, self.weight, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.watch_kind {
            match v {
                &ActionProfileGroup_Member_oneof_watch_kind::watch(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &ActionProfileGroup_Member_oneof_watch_kind::watch_port(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.member_id != 0 {
            os.write_uint32(1, self.member_id)?;
        }
        if self.weight != 0 {
            os.write_int32(2, self.weight)?;
        }
        if let ::std::option::Option::Some(ref v) = self.watch_kind {
            match v {
                &ActionProfileGroup_Member_oneof_watch_kind::watch(v) => {
                    os.write_int32(3, v)?;
                },
                &ActionProfileGroup_Member_oneof_watch_kind::watch_port(ref v) => {
                    os.write_bytes(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionProfileGroup_Member {
        ActionProfileGroup_Member::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "member_id",
                |m: &ActionProfileGroup_Member| { &m.member_id },
                |m: &mut ActionProfileGroup_Member| { &mut m.member_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "weight",
                |m: &ActionProfileGroup_Member| { &m.weight },
                |m: &mut ActionProfileGroup_Member| { &mut m.weight },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "watch",
                ActionProfileGroup_Member::has_watch,
                ActionProfileGroup_Member::get_watch,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "watch_port",
                ActionProfileGroup_Member::has_watch_port,
                ActionProfileGroup_Member::get_watch_port,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionProfileGroup_Member>(
                "ActionProfileGroup.Member",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionProfileGroup_Member {
        static instance: ::protobuf::rt::LazyV2<ActionProfileGroup_Member> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionProfileGroup_Member::new)
    }
}

impl ::protobuf::Clear for ActionProfileGroup_Member {
    fn clear(&mut self) {
        self.member_id = 0;
        self.weight = 0;
        self.watch_kind = ::std::option::Option::None;
        self.watch_kind = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionProfileGroup_Member {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionProfileGroup_Member {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Index {
    // message fields
    pub index: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Index {
    fn default() -> &'a Index {
        <Index as ::protobuf::Message>::default_instance()
    }
}

impl Index {
    pub fn new() -> Index {
        ::std::default::Default::default()
    }

    // int64 index = 1;


    pub fn get_index(&self) -> i64 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i64) {
        self.index = v;
    }
}

impl ::protobuf::Message for Index {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.index != 0 {
            os.write_int64(1, self.index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Index {
        Index::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "index",
                |m: &Index| { &m.index },
                |m: &mut Index| { &mut m.index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Index>(
                "Index",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Index {
        static instance: ::protobuf::rt::LazyV2<Index> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Index::new)
    }
}

impl ::protobuf::Clear for Index {
    fn clear(&mut self) {
        self.index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Index {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Index {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MeterEntry {
    // message fields
    pub meter_id: u32,
    pub index: ::protobuf::SingularPtrField<Index>,
    pub config: ::protobuf::SingularPtrField<MeterConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MeterEntry {
    fn default() -> &'a MeterEntry {
        <MeterEntry as ::protobuf::Message>::default_instance()
    }
}

impl MeterEntry {
    pub fn new() -> MeterEntry {
        ::std::default::Default::default()
    }

    // uint32 meter_id = 1;


    pub fn get_meter_id(&self) -> u32 {
        self.meter_id
    }
    pub fn clear_meter_id(&mut self) {
        self.meter_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_meter_id(&mut self, v: u32) {
        self.meter_id = v;
    }

    // .p4.v1.Index index = 2;


    pub fn get_index(&self) -> &Index {
        self.index.as_ref().unwrap_or_else(|| <Index as ::protobuf::Message>::default_instance())
    }
    pub fn clear_index(&mut self) {
        self.index.clear();
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: Index) {
        self.index = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index(&mut self) -> &mut Index {
        if self.index.is_none() {
            self.index.set_default();
        }
        self.index.as_mut().unwrap()
    }

    // Take field
    pub fn take_index(&mut self) -> Index {
        self.index.take().unwrap_or_else(|| Index::new())
    }

    // .p4.v1.MeterConfig config = 3;


    pub fn get_config(&self) -> &MeterConfig {
        self.config.as_ref().unwrap_or_else(|| <MeterConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: MeterConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut MeterConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> MeterConfig {
        self.config.take().unwrap_or_else(|| MeterConfig::new())
    }
}

impl ::protobuf::Message for MeterEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.index {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.meter_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.index)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.meter_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.meter_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.index.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.meter_id != 0 {
            os.write_uint32(1, self.meter_id)?;
        }
        if let Some(ref v) = self.index.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MeterEntry {
        MeterEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "meter_id",
                |m: &MeterEntry| { &m.meter_id },
                |m: &mut MeterEntry| { &mut m.meter_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Index>>(
                "index",
                |m: &MeterEntry| { &m.index },
                |m: &mut MeterEntry| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MeterConfig>>(
                "config",
                |m: &MeterEntry| { &m.config },
                |m: &mut MeterEntry| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MeterEntry>(
                "MeterEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MeterEntry {
        static instance: ::protobuf::rt::LazyV2<MeterEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MeterEntry::new)
    }
}

impl ::protobuf::Clear for MeterEntry {
    fn clear(&mut self) {
        self.meter_id = 0;
        self.index.clear();
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MeterEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MeterEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirectMeterEntry {
    // message fields
    pub table_entry: ::protobuf::SingularPtrField<TableEntry>,
    pub config: ::protobuf::SingularPtrField<MeterConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DirectMeterEntry {
    fn default() -> &'a DirectMeterEntry {
        <DirectMeterEntry as ::protobuf::Message>::default_instance()
    }
}

impl DirectMeterEntry {
    pub fn new() -> DirectMeterEntry {
        ::std::default::Default::default()
    }

    // .p4.v1.TableEntry table_entry = 1;


    pub fn get_table_entry(&self) -> &TableEntry {
        self.table_entry.as_ref().unwrap_or_else(|| <TableEntry as ::protobuf::Message>::default_instance())
    }
    pub fn clear_table_entry(&mut self) {
        self.table_entry.clear();
    }

    pub fn has_table_entry(&self) -> bool {
        self.table_entry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_entry(&mut self, v: TableEntry) {
        self.table_entry = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_entry(&mut self) -> &mut TableEntry {
        if self.table_entry.is_none() {
            self.table_entry.set_default();
        }
        self.table_entry.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_entry(&mut self) -> TableEntry {
        self.table_entry.take().unwrap_or_else(|| TableEntry::new())
    }

    // .p4.v1.MeterConfig config = 2;


    pub fn get_config(&self) -> &MeterConfig {
        self.config.as_ref().unwrap_or_else(|| <MeterConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: MeterConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut MeterConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> MeterConfig {
        self.config.take().unwrap_or_else(|| MeterConfig::new())
    }
}

impl ::protobuf::Message for DirectMeterEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.table_entry {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.table_entry)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_entry.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DirectMeterEntry {
        DirectMeterEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableEntry>>(
                "table_entry",
                |m: &DirectMeterEntry| { &m.table_entry },
                |m: &mut DirectMeterEntry| { &mut m.table_entry },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MeterConfig>>(
                "config",
                |m: &DirectMeterEntry| { &m.config },
                |m: &mut DirectMeterEntry| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DirectMeterEntry>(
                "DirectMeterEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DirectMeterEntry {
        static instance: ::protobuf::rt::LazyV2<DirectMeterEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DirectMeterEntry::new)
    }
}

impl ::protobuf::Clear for DirectMeterEntry {
    fn clear(&mut self) {
        self.table_entry.clear();
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirectMeterEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectMeterEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MeterConfig {
    // message fields
    pub cir: i64,
    pub cburst: i64,
    pub pir: i64,
    pub pburst: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MeterConfig {
    fn default() -> &'a MeterConfig {
        <MeterConfig as ::protobuf::Message>::default_instance()
    }
}

impl MeterConfig {
    pub fn new() -> MeterConfig {
        ::std::default::Default::default()
    }

    // int64 cir = 1;


    pub fn get_cir(&self) -> i64 {
        self.cir
    }
    pub fn clear_cir(&mut self) {
        self.cir = 0;
    }

    // Param is passed by value, moved
    pub fn set_cir(&mut self, v: i64) {
        self.cir = v;
    }

    // int64 cburst = 2;


    pub fn get_cburst(&self) -> i64 {
        self.cburst
    }
    pub fn clear_cburst(&mut self) {
        self.cburst = 0;
    }

    // Param is passed by value, moved
    pub fn set_cburst(&mut self, v: i64) {
        self.cburst = v;
    }

    // int64 pir = 3;


    pub fn get_pir(&self) -> i64 {
        self.pir
    }
    pub fn clear_pir(&mut self) {
        self.pir = 0;
    }

    // Param is passed by value, moved
    pub fn set_pir(&mut self, v: i64) {
        self.pir = v;
    }

    // int64 pburst = 4;


    pub fn get_pburst(&self) -> i64 {
        self.pburst
    }
    pub fn clear_pburst(&mut self) {
        self.pburst = 0;
    }

    // Param is passed by value, moved
    pub fn set_pburst(&mut self, v: i64) {
        self.pburst = v;
    }
}

impl ::protobuf::Message for MeterConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cir = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cburst = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.pir = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.pburst = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cir != 0 {
            my_size += ::protobuf::rt::value_size(1, self.cir, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cburst != 0 {
            my_size += ::protobuf::rt::value_size(2, self.cburst, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pir != 0 {
            my_size += ::protobuf::rt::value_size(3, self.pir, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pburst != 0 {
            my_size += ::protobuf::rt::value_size(4, self.pburst, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cir != 0 {
            os.write_int64(1, self.cir)?;
        }
        if self.cburst != 0 {
            os.write_int64(2, self.cburst)?;
        }
        if self.pir != 0 {
            os.write_int64(3, self.pir)?;
        }
        if self.pburst != 0 {
            os.write_int64(4, self.pburst)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MeterConfig {
        MeterConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "cir",
                |m: &MeterConfig| { &m.cir },
                |m: &mut MeterConfig| { &mut m.cir },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "cburst",
                |m: &MeterConfig| { &m.cburst },
                |m: &mut MeterConfig| { &mut m.cburst },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "pir",
                |m: &MeterConfig| { &m.pir },
                |m: &mut MeterConfig| { &mut m.pir },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "pburst",
                |m: &MeterConfig| { &m.pburst },
                |m: &mut MeterConfig| { &mut m.pburst },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MeterConfig>(
                "MeterConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MeterConfig {
        static instance: ::protobuf::rt::LazyV2<MeterConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MeterConfig::new)
    }
}

impl ::protobuf::Clear for MeterConfig {
    fn clear(&mut self) {
        self.cir = 0;
        self.cburst = 0;
        self.pir = 0;
        self.pburst = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MeterConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MeterConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CounterEntry {
    // message fields
    pub counter_id: u32,
    pub index: ::protobuf::SingularPtrField<Index>,
    pub data: ::protobuf::SingularPtrField<CounterData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CounterEntry {
    fn default() -> &'a CounterEntry {
        <CounterEntry as ::protobuf::Message>::default_instance()
    }
}

impl CounterEntry {
    pub fn new() -> CounterEntry {
        ::std::default::Default::default()
    }

    // uint32 counter_id = 1;


    pub fn get_counter_id(&self) -> u32 {
        self.counter_id
    }
    pub fn clear_counter_id(&mut self) {
        self.counter_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_counter_id(&mut self, v: u32) {
        self.counter_id = v;
    }

    // .p4.v1.Index index = 2;


    pub fn get_index(&self) -> &Index {
        self.index.as_ref().unwrap_or_else(|| <Index as ::protobuf::Message>::default_instance())
    }
    pub fn clear_index(&mut self) {
        self.index.clear();
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: Index) {
        self.index = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index(&mut self) -> &mut Index {
        if self.index.is_none() {
            self.index.set_default();
        }
        self.index.as_mut().unwrap()
    }

    // Take field
    pub fn take_index(&mut self) -> Index {
        self.index.take().unwrap_or_else(|| Index::new())
    }

    // .p4.v1.CounterData data = 3;


    pub fn get_data(&self) -> &CounterData {
        self.data.as_ref().unwrap_or_else(|| <CounterData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: CounterData) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut CounterData {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> CounterData {
        self.data.take().unwrap_or_else(|| CounterData::new())
    }
}

impl ::protobuf::Message for CounterEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.index {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.counter_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.index)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.counter_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.counter_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.index.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.counter_id != 0 {
            os.write_uint32(1, self.counter_id)?;
        }
        if let Some(ref v) = self.index.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CounterEntry {
        CounterEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "counter_id",
                |m: &CounterEntry| { &m.counter_id },
                |m: &mut CounterEntry| { &mut m.counter_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Index>>(
                "index",
                |m: &CounterEntry| { &m.index },
                |m: &mut CounterEntry| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CounterData>>(
                "data",
                |m: &CounterEntry| { &m.data },
                |m: &mut CounterEntry| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CounterEntry>(
                "CounterEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CounterEntry {
        static instance: ::protobuf::rt::LazyV2<CounterEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CounterEntry::new)
    }
}

impl ::protobuf::Clear for CounterEntry {
    fn clear(&mut self) {
        self.counter_id = 0;
        self.index.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CounterEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CounterEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirectCounterEntry {
    // message fields
    pub table_entry: ::protobuf::SingularPtrField<TableEntry>,
    pub data: ::protobuf::SingularPtrField<CounterData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DirectCounterEntry {
    fn default() -> &'a DirectCounterEntry {
        <DirectCounterEntry as ::protobuf::Message>::default_instance()
    }
}

impl DirectCounterEntry {
    pub fn new() -> DirectCounterEntry {
        ::std::default::Default::default()
    }

    // .p4.v1.TableEntry table_entry = 1;


    pub fn get_table_entry(&self) -> &TableEntry {
        self.table_entry.as_ref().unwrap_or_else(|| <TableEntry as ::protobuf::Message>::default_instance())
    }
    pub fn clear_table_entry(&mut self) {
        self.table_entry.clear();
    }

    pub fn has_table_entry(&self) -> bool {
        self.table_entry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_entry(&mut self, v: TableEntry) {
        self.table_entry = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_entry(&mut self) -> &mut TableEntry {
        if self.table_entry.is_none() {
            self.table_entry.set_default();
        }
        self.table_entry.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_entry(&mut self) -> TableEntry {
        self.table_entry.take().unwrap_or_else(|| TableEntry::new())
    }

    // .p4.v1.CounterData data = 2;


    pub fn get_data(&self) -> &CounterData {
        self.data.as_ref().unwrap_or_else(|| <CounterData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: CounterData) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut CounterData {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> CounterData {
        self.data.take().unwrap_or_else(|| CounterData::new())
    }
}

impl ::protobuf::Message for DirectCounterEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.table_entry {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.table_entry)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_entry.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DirectCounterEntry {
        DirectCounterEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableEntry>>(
                "table_entry",
                |m: &DirectCounterEntry| { &m.table_entry },
                |m: &mut DirectCounterEntry| { &mut m.table_entry },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CounterData>>(
                "data",
                |m: &DirectCounterEntry| { &m.data },
                |m: &mut DirectCounterEntry| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DirectCounterEntry>(
                "DirectCounterEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DirectCounterEntry {
        static instance: ::protobuf::rt::LazyV2<DirectCounterEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DirectCounterEntry::new)
    }
}

impl ::protobuf::Clear for DirectCounterEntry {
    fn clear(&mut self) {
        self.table_entry.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirectCounterEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectCounterEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CounterData {
    // message fields
    pub byte_count: i64,
    pub packet_count: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CounterData {
    fn default() -> &'a CounterData {
        <CounterData as ::protobuf::Message>::default_instance()
    }
}

impl CounterData {
    pub fn new() -> CounterData {
        ::std::default::Default::default()
    }

    // int64 byte_count = 1;


    pub fn get_byte_count(&self) -> i64 {
        self.byte_count
    }
    pub fn clear_byte_count(&mut self) {
        self.byte_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_byte_count(&mut self, v: i64) {
        self.byte_count = v;
    }

    // int64 packet_count = 2;


    pub fn get_packet_count(&self) -> i64 {
        self.packet_count
    }
    pub fn clear_packet_count(&mut self) {
        self.packet_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_packet_count(&mut self, v: i64) {
        self.packet_count = v;
    }
}

impl ::protobuf::Message for CounterData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.byte_count = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.packet_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.byte_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.byte_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.packet_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.packet_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.byte_count != 0 {
            os.write_int64(1, self.byte_count)?;
        }
        if self.packet_count != 0 {
            os.write_int64(2, self.packet_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CounterData {
        CounterData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "byte_count",
                |m: &CounterData| { &m.byte_count },
                |m: &mut CounterData| { &mut m.byte_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "packet_count",
                |m: &CounterData| { &m.packet_count },
                |m: &mut CounterData| { &mut m.packet_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CounterData>(
                "CounterData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CounterData {
        static instance: ::protobuf::rt::LazyV2<CounterData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CounterData::new)
    }
}

impl ::protobuf::Clear for CounterData {
    fn clear(&mut self) {
        self.byte_count = 0;
        self.packet_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CounterData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CounterData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PacketReplicationEngineEntry {
    // message oneof groups
    pub field_type: ::std::option::Option<PacketReplicationEngineEntry_oneof_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PacketReplicationEngineEntry {
    fn default() -> &'a PacketReplicationEngineEntry {
        <PacketReplicationEngineEntry as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum PacketReplicationEngineEntry_oneof_type {
    multicast_group_entry(MulticastGroupEntry),
    clone_session_entry(CloneSessionEntry),
}

impl PacketReplicationEngineEntry {
    pub fn new() -> PacketReplicationEngineEntry {
        ::std::default::Default::default()
    }

    // .p4.v1.MulticastGroupEntry multicast_group_entry = 1;


    pub fn get_multicast_group_entry(&self) -> &MulticastGroupEntry {
        match self.field_type {
            ::std::option::Option::Some(PacketReplicationEngineEntry_oneof_type::multicast_group_entry(ref v)) => v,
            _ => <MulticastGroupEntry as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_multicast_group_entry(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_multicast_group_entry(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(PacketReplicationEngineEntry_oneof_type::multicast_group_entry(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multicast_group_entry(&mut self, v: MulticastGroupEntry) {
        self.field_type = ::std::option::Option::Some(PacketReplicationEngineEntry_oneof_type::multicast_group_entry(v))
    }

    // Mutable pointer to the field.
    pub fn mut_multicast_group_entry(&mut self) -> &mut MulticastGroupEntry {
        if let ::std::option::Option::Some(PacketReplicationEngineEntry_oneof_type::multicast_group_entry(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(PacketReplicationEngineEntry_oneof_type::multicast_group_entry(MulticastGroupEntry::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(PacketReplicationEngineEntry_oneof_type::multicast_group_entry(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_multicast_group_entry(&mut self) -> MulticastGroupEntry {
        if self.has_multicast_group_entry() {
            match self.field_type.take() {
                ::std::option::Option::Some(PacketReplicationEngineEntry_oneof_type::multicast_group_entry(v)) => v,
                _ => panic!(),
            }
        } else {
            MulticastGroupEntry::new()
        }
    }

    // .p4.v1.CloneSessionEntry clone_session_entry = 2;


    pub fn get_clone_session_entry(&self) -> &CloneSessionEntry {
        match self.field_type {
            ::std::option::Option::Some(PacketReplicationEngineEntry_oneof_type::clone_session_entry(ref v)) => v,
            _ => <CloneSessionEntry as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_clone_session_entry(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_clone_session_entry(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(PacketReplicationEngineEntry_oneof_type::clone_session_entry(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_clone_session_entry(&mut self, v: CloneSessionEntry) {
        self.field_type = ::std::option::Option::Some(PacketReplicationEngineEntry_oneof_type::clone_session_entry(v))
    }

    // Mutable pointer to the field.
    pub fn mut_clone_session_entry(&mut self) -> &mut CloneSessionEntry {
        if let ::std::option::Option::Some(PacketReplicationEngineEntry_oneof_type::clone_session_entry(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(PacketReplicationEngineEntry_oneof_type::clone_session_entry(CloneSessionEntry::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(PacketReplicationEngineEntry_oneof_type::clone_session_entry(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_clone_session_entry(&mut self) -> CloneSessionEntry {
        if self.has_clone_session_entry() {
            match self.field_type.take() {
                ::std::option::Option::Some(PacketReplicationEngineEntry_oneof_type::clone_session_entry(v)) => v,
                _ => panic!(),
            }
        } else {
            CloneSessionEntry::new()
        }
    }
}

impl ::protobuf::Message for PacketReplicationEngineEntry {
    fn is_initialized(&self) -> bool {
        if let Some(PacketReplicationEngineEntry_oneof_type::multicast_group_entry(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PacketReplicationEngineEntry_oneof_type::clone_session_entry(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(PacketReplicationEngineEntry_oneof_type::multicast_group_entry(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(PacketReplicationEngineEntry_oneof_type::clone_session_entry(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &PacketReplicationEngineEntry_oneof_type::multicast_group_entry(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PacketReplicationEngineEntry_oneof_type::clone_session_entry(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &PacketReplicationEngineEntry_oneof_type::multicast_group_entry(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PacketReplicationEngineEntry_oneof_type::clone_session_entry(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PacketReplicationEngineEntry {
        PacketReplicationEngineEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MulticastGroupEntry>(
                "multicast_group_entry",
                PacketReplicationEngineEntry::has_multicast_group_entry,
                PacketReplicationEngineEntry::get_multicast_group_entry,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CloneSessionEntry>(
                "clone_session_entry",
                PacketReplicationEngineEntry::has_clone_session_entry,
                PacketReplicationEngineEntry::get_clone_session_entry,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PacketReplicationEngineEntry>(
                "PacketReplicationEngineEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PacketReplicationEngineEntry {
        static instance: ::protobuf::rt::LazyV2<PacketReplicationEngineEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PacketReplicationEngineEntry::new)
    }
}

impl ::protobuf::Clear for PacketReplicationEngineEntry {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PacketReplicationEngineEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PacketReplicationEngineEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Replica {
    // message fields
    pub egress_port: u32,
    pub instance: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Replica {
    fn default() -> &'a Replica {
        <Replica as ::protobuf::Message>::default_instance()
    }
}

impl Replica {
    pub fn new() -> Replica {
        ::std::default::Default::default()
    }

    // uint32 egress_port = 1;


    pub fn get_egress_port(&self) -> u32 {
        self.egress_port
    }
    pub fn clear_egress_port(&mut self) {
        self.egress_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_egress_port(&mut self, v: u32) {
        self.egress_port = v;
    }

    // uint32 instance = 2;


    pub fn get_instance(&self) -> u32 {
        self.instance
    }
    pub fn clear_instance(&mut self) {
        self.instance = 0;
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: u32) {
        self.instance = v;
    }
}

impl ::protobuf::Message for Replica {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.egress_port = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.instance = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.egress_port != 0 {
            my_size += ::protobuf::rt::value_size(1, self.egress_port, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.instance != 0 {
            my_size += ::protobuf::rt::value_size(2, self.instance, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.egress_port != 0 {
            os.write_uint32(1, self.egress_port)?;
        }
        if self.instance != 0 {
            os.write_uint32(2, self.instance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Replica {
        Replica::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "egress_port",
                |m: &Replica| { &m.egress_port },
                |m: &mut Replica| { &mut m.egress_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "instance",
                |m: &Replica| { &m.instance },
                |m: &mut Replica| { &mut m.instance },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Replica>(
                "Replica",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Replica {
        static instance: ::protobuf::rt::LazyV2<Replica> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Replica::new)
    }
}

impl ::protobuf::Clear for Replica {
    fn clear(&mut self) {
        self.egress_port = 0;
        self.instance = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Replica {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Replica {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MulticastGroupEntry {
    // message fields
    pub multicast_group_id: u32,
    pub replicas: ::protobuf::RepeatedField<Replica>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MulticastGroupEntry {
    fn default() -> &'a MulticastGroupEntry {
        <MulticastGroupEntry as ::protobuf::Message>::default_instance()
    }
}

impl MulticastGroupEntry {
    pub fn new() -> MulticastGroupEntry {
        ::std::default::Default::default()
    }

    // uint32 multicast_group_id = 1;


    pub fn get_multicast_group_id(&self) -> u32 {
        self.multicast_group_id
    }
    pub fn clear_multicast_group_id(&mut self) {
        self.multicast_group_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_multicast_group_id(&mut self, v: u32) {
        self.multicast_group_id = v;
    }

    // repeated .p4.v1.Replica replicas = 2;


    pub fn get_replicas(&self) -> &[Replica] {
        &self.replicas
    }
    pub fn clear_replicas(&mut self) {
        self.replicas.clear();
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: ::protobuf::RepeatedField<Replica>) {
        self.replicas = v;
    }

    // Mutable pointer to the field.
    pub fn mut_replicas(&mut self) -> &mut ::protobuf::RepeatedField<Replica> {
        &mut self.replicas
    }

    // Take field
    pub fn take_replicas(&mut self) -> ::protobuf::RepeatedField<Replica> {
        ::std::mem::replace(&mut self.replicas, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MulticastGroupEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.replicas {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.multicast_group_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.replicas)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.multicast_group_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.multicast_group_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.replicas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.multicast_group_id != 0 {
            os.write_uint32(1, self.multicast_group_id)?;
        }
        for v in &self.replicas {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MulticastGroupEntry {
        MulticastGroupEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "multicast_group_id",
                |m: &MulticastGroupEntry| { &m.multicast_group_id },
                |m: &mut MulticastGroupEntry| { &mut m.multicast_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Replica>>(
                "replicas",
                |m: &MulticastGroupEntry| { &m.replicas },
                |m: &mut MulticastGroupEntry| { &mut m.replicas },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MulticastGroupEntry>(
                "MulticastGroupEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MulticastGroupEntry {
        static instance: ::protobuf::rt::LazyV2<MulticastGroupEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MulticastGroupEntry::new)
    }
}

impl ::protobuf::Clear for MulticastGroupEntry {
    fn clear(&mut self) {
        self.multicast_group_id = 0;
        self.replicas.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MulticastGroupEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MulticastGroupEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CloneSessionEntry {
    // message fields
    pub session_id: u32,
    pub replicas: ::protobuf::RepeatedField<Replica>,
    pub class_of_service: u32,
    pub packet_length_bytes: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CloneSessionEntry {
    fn default() -> &'a CloneSessionEntry {
        <CloneSessionEntry as ::protobuf::Message>::default_instance()
    }
}

impl CloneSessionEntry {
    pub fn new() -> CloneSessionEntry {
        ::std::default::Default::default()
    }

    // uint32 session_id = 1;


    pub fn get_session_id(&self) -> u32 {
        self.session_id
    }
    pub fn clear_session_id(&mut self) {
        self.session_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: u32) {
        self.session_id = v;
    }

    // repeated .p4.v1.Replica replicas = 2;


    pub fn get_replicas(&self) -> &[Replica] {
        &self.replicas
    }
    pub fn clear_replicas(&mut self) {
        self.replicas.clear();
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: ::protobuf::RepeatedField<Replica>) {
        self.replicas = v;
    }

    // Mutable pointer to the field.
    pub fn mut_replicas(&mut self) -> &mut ::protobuf::RepeatedField<Replica> {
        &mut self.replicas
    }

    // Take field
    pub fn take_replicas(&mut self) -> ::protobuf::RepeatedField<Replica> {
        ::std::mem::replace(&mut self.replicas, ::protobuf::RepeatedField::new())
    }

    // uint32 class_of_service = 3;


    pub fn get_class_of_service(&self) -> u32 {
        self.class_of_service
    }
    pub fn clear_class_of_service(&mut self) {
        self.class_of_service = 0;
    }

    // Param is passed by value, moved
    pub fn set_class_of_service(&mut self, v: u32) {
        self.class_of_service = v;
    }

    // int32 packet_length_bytes = 4;


    pub fn get_packet_length_bytes(&self) -> i32 {
        self.packet_length_bytes
    }
    pub fn clear_packet_length_bytes(&mut self) {
        self.packet_length_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_packet_length_bytes(&mut self, v: i32) {
        self.packet_length_bytes = v;
    }
}

impl ::protobuf::Message for CloneSessionEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.replicas {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.session_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.replicas)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.class_of_service = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.packet_length_bytes = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.session_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.session_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.replicas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.class_of_service != 0 {
            my_size += ::protobuf::rt::value_size(3, self.class_of_service, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.packet_length_bytes != 0 {
            my_size += ::protobuf::rt::value_size(4, self.packet_length_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.session_id != 0 {
            os.write_uint32(1, self.session_id)?;
        }
        for v in &self.replicas {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.class_of_service != 0 {
            os.write_uint32(3, self.class_of_service)?;
        }
        if self.packet_length_bytes != 0 {
            os.write_int32(4, self.packet_length_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloneSessionEntry {
        CloneSessionEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "session_id",
                |m: &CloneSessionEntry| { &m.session_id },
                |m: &mut CloneSessionEntry| { &mut m.session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Replica>>(
                "replicas",
                |m: &CloneSessionEntry| { &m.replicas },
                |m: &mut CloneSessionEntry| { &mut m.replicas },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "class_of_service",
                |m: &CloneSessionEntry| { &m.class_of_service },
                |m: &mut CloneSessionEntry| { &mut m.class_of_service },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "packet_length_bytes",
                |m: &CloneSessionEntry| { &m.packet_length_bytes },
                |m: &mut CloneSessionEntry| { &mut m.packet_length_bytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CloneSessionEntry>(
                "CloneSessionEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CloneSessionEntry {
        static instance: ::protobuf::rt::LazyV2<CloneSessionEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CloneSessionEntry::new)
    }
}

impl ::protobuf::Clear for CloneSessionEntry {
    fn clear(&mut self) {
        self.session_id = 0;
        self.replicas.clear();
        self.class_of_service = 0;
        self.packet_length_bytes = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloneSessionEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloneSessionEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValueSetMember {
    // message fields
    pub field_match: ::protobuf::RepeatedField<FieldMatch>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValueSetMember {
    fn default() -> &'a ValueSetMember {
        <ValueSetMember as ::protobuf::Message>::default_instance()
    }
}

impl ValueSetMember {
    pub fn new() -> ValueSetMember {
        ::std::default::Default::default()
    }

    // repeated .p4.v1.FieldMatch match = 1;


    pub fn get_field_match(&self) -> &[FieldMatch] {
        &self.field_match
    }
    pub fn clear_field_match(&mut self) {
        self.field_match.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_match(&mut self, v: ::protobuf::RepeatedField<FieldMatch>) {
        self.field_match = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field_match(&mut self) -> &mut ::protobuf::RepeatedField<FieldMatch> {
        &mut self.field_match
    }

    // Take field
    pub fn take_field_match(&mut self) -> ::protobuf::RepeatedField<FieldMatch> {
        ::std::mem::replace(&mut self.field_match, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ValueSetMember {
    fn is_initialized(&self) -> bool {
        for v in &self.field_match {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.field_match)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.field_match {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.field_match {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValueSetMember {
        ValueSetMember::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldMatch>>(
                "match",
                |m: &ValueSetMember| { &m.field_match },
                |m: &mut ValueSetMember| { &mut m.field_match },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ValueSetMember>(
                "ValueSetMember",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ValueSetMember {
        static instance: ::protobuf::rt::LazyV2<ValueSetMember> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ValueSetMember::new)
    }
}

impl ::protobuf::Clear for ValueSetMember {
    fn clear(&mut self) {
        self.field_match.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValueSetMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValueSetMember {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValueSetEntry {
    // message fields
    pub value_set_id: u32,
    pub members: ::protobuf::RepeatedField<ValueSetMember>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValueSetEntry {
    fn default() -> &'a ValueSetEntry {
        <ValueSetEntry as ::protobuf::Message>::default_instance()
    }
}

impl ValueSetEntry {
    pub fn new() -> ValueSetEntry {
        ::std::default::Default::default()
    }

    // uint32 value_set_id = 1;


    pub fn get_value_set_id(&self) -> u32 {
        self.value_set_id
    }
    pub fn clear_value_set_id(&mut self) {
        self.value_set_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_value_set_id(&mut self, v: u32) {
        self.value_set_id = v;
    }

    // repeated .p4.v1.ValueSetMember members = 2;


    pub fn get_members(&self) -> &[ValueSetMember] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<ValueSetMember>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<ValueSetMember> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<ValueSetMember> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ValueSetEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value_set_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value_set_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value_set_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value_set_id != 0 {
            os.write_uint32(1, self.value_set_id)?;
        }
        for v in &self.members {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValueSetEntry {
        ValueSetEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "value_set_id",
                |m: &ValueSetEntry| { &m.value_set_id },
                |m: &mut ValueSetEntry| { &mut m.value_set_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ValueSetMember>>(
                "members",
                |m: &ValueSetEntry| { &m.members },
                |m: &mut ValueSetEntry| { &mut m.members },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ValueSetEntry>(
                "ValueSetEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ValueSetEntry {
        static instance: ::protobuf::rt::LazyV2<ValueSetEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ValueSetEntry::new)
    }
}

impl ::protobuf::Clear for ValueSetEntry {
    fn clear(&mut self) {
        self.value_set_id = 0;
        self.members.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValueSetEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValueSetEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegisterEntry {
    // message fields
    pub register_id: u32,
    pub index: ::protobuf::SingularPtrField<Index>,
    pub data: ::protobuf::SingularPtrField<super::p4data::P4Data>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegisterEntry {
    fn default() -> &'a RegisterEntry {
        <RegisterEntry as ::protobuf::Message>::default_instance()
    }
}

impl RegisterEntry {
    pub fn new() -> RegisterEntry {
        ::std::default::Default::default()
    }

    // uint32 register_id = 1;


    pub fn get_register_id(&self) -> u32 {
        self.register_id
    }
    pub fn clear_register_id(&mut self) {
        self.register_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_register_id(&mut self, v: u32) {
        self.register_id = v;
    }

    // .p4.v1.Index index = 2;


    pub fn get_index(&self) -> &Index {
        self.index.as_ref().unwrap_or_else(|| <Index as ::protobuf::Message>::default_instance())
    }
    pub fn clear_index(&mut self) {
        self.index.clear();
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: Index) {
        self.index = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index(&mut self) -> &mut Index {
        if self.index.is_none() {
            self.index.set_default();
        }
        self.index.as_mut().unwrap()
    }

    // Take field
    pub fn take_index(&mut self) -> Index {
        self.index.take().unwrap_or_else(|| Index::new())
    }

    // .p4.v1.P4Data data = 3;


    pub fn get_data(&self) -> &super::p4data::P4Data {
        self.data.as_ref().unwrap_or_else(|| <super::p4data::P4Data as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: super::p4data::P4Data) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut super::p4data::P4Data {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> super::p4data::P4Data {
        self.data.take().unwrap_or_else(|| super::p4data::P4Data::new())
    }
}

impl ::protobuf::Message for RegisterEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.index {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.register_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.index)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.register_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.register_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.index.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.register_id != 0 {
            os.write_uint32(1, self.register_id)?;
        }
        if let Some(ref v) = self.index.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegisterEntry {
        RegisterEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "register_id",
                |m: &RegisterEntry| { &m.register_id },
                |m: &mut RegisterEntry| { &mut m.register_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Index>>(
                "index",
                |m: &RegisterEntry| { &m.index },
                |m: &mut RegisterEntry| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4data::P4Data>>(
                "data",
                |m: &RegisterEntry| { &m.data },
                |m: &mut RegisterEntry| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegisterEntry>(
                "RegisterEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegisterEntry {
        static instance: ::protobuf::rt::LazyV2<RegisterEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegisterEntry::new)
    }
}

impl ::protobuf::Clear for RegisterEntry {
    fn clear(&mut self) {
        self.register_id = 0;
        self.index.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegisterEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DigestEntry {
    // message fields
    pub digest_id: u32,
    pub config: ::protobuf::SingularPtrField<DigestEntry_Config>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DigestEntry {
    fn default() -> &'a DigestEntry {
        <DigestEntry as ::protobuf::Message>::default_instance()
    }
}

impl DigestEntry {
    pub fn new() -> DigestEntry {
        ::std::default::Default::default()
    }

    // uint32 digest_id = 1;


    pub fn get_digest_id(&self) -> u32 {
        self.digest_id
    }
    pub fn clear_digest_id(&mut self) {
        self.digest_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_digest_id(&mut self, v: u32) {
        self.digest_id = v;
    }

    // .p4.v1.DigestEntry.Config config = 2;


    pub fn get_config(&self) -> &DigestEntry_Config {
        self.config.as_ref().unwrap_or_else(|| <DigestEntry_Config as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: DigestEntry_Config) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut DigestEntry_Config {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> DigestEntry_Config {
        self.config.take().unwrap_or_else(|| DigestEntry_Config::new())
    }
}

impl ::protobuf::Message for DigestEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.digest_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.digest_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.digest_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.digest_id != 0 {
            os.write_uint32(1, self.digest_id)?;
        }
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DigestEntry {
        DigestEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "digest_id",
                |m: &DigestEntry| { &m.digest_id },
                |m: &mut DigestEntry| { &mut m.digest_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DigestEntry_Config>>(
                "config",
                |m: &DigestEntry| { &m.config },
                |m: &mut DigestEntry| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DigestEntry>(
                "DigestEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DigestEntry {
        static instance: ::protobuf::rt::LazyV2<DigestEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DigestEntry::new)
    }
}

impl ::protobuf::Clear for DigestEntry {
    fn clear(&mut self) {
        self.digest_id = 0;
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DigestEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DigestEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DigestEntry_Config {
    // message fields
    pub max_timeout_ns: i64,
    pub max_list_size: i32,
    pub ack_timeout_ns: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DigestEntry_Config {
    fn default() -> &'a DigestEntry_Config {
        <DigestEntry_Config as ::protobuf::Message>::default_instance()
    }
}

impl DigestEntry_Config {
    pub fn new() -> DigestEntry_Config {
        ::std::default::Default::default()
    }

    // int64 max_timeout_ns = 1;


    pub fn get_max_timeout_ns(&self) -> i64 {
        self.max_timeout_ns
    }
    pub fn clear_max_timeout_ns(&mut self) {
        self.max_timeout_ns = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_timeout_ns(&mut self, v: i64) {
        self.max_timeout_ns = v;
    }

    // int32 max_list_size = 2;


    pub fn get_max_list_size(&self) -> i32 {
        self.max_list_size
    }
    pub fn clear_max_list_size(&mut self) {
        self.max_list_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_list_size(&mut self, v: i32) {
        self.max_list_size = v;
    }

    // int64 ack_timeout_ns = 3;


    pub fn get_ack_timeout_ns(&self) -> i64 {
        self.ack_timeout_ns
    }
    pub fn clear_ack_timeout_ns(&mut self) {
        self.ack_timeout_ns = 0;
    }

    // Param is passed by value, moved
    pub fn set_ack_timeout_ns(&mut self, v: i64) {
        self.ack_timeout_ns = v;
    }
}

impl ::protobuf::Message for DigestEntry_Config {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_timeout_ns = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_list_size = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ack_timeout_ns = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.max_timeout_ns != 0 {
            my_size += ::protobuf::rt::value_size(1, self.max_timeout_ns, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_list_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_list_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ack_timeout_ns != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ack_timeout_ns, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.max_timeout_ns != 0 {
            os.write_int64(1, self.max_timeout_ns)?;
        }
        if self.max_list_size != 0 {
            os.write_int32(2, self.max_list_size)?;
        }
        if self.ack_timeout_ns != 0 {
            os.write_int64(3, self.ack_timeout_ns)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DigestEntry_Config {
        DigestEntry_Config::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_timeout_ns",
                |m: &DigestEntry_Config| { &m.max_timeout_ns },
                |m: &mut DigestEntry_Config| { &mut m.max_timeout_ns },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_list_size",
                |m: &DigestEntry_Config| { &m.max_list_size },
                |m: &mut DigestEntry_Config| { &mut m.max_list_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ack_timeout_ns",
                |m: &DigestEntry_Config| { &m.ack_timeout_ns },
                |m: &mut DigestEntry_Config| { &mut m.ack_timeout_ns },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DigestEntry_Config>(
                "DigestEntry.Config",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DigestEntry_Config {
        static instance: ::protobuf::rt::LazyV2<DigestEntry_Config> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DigestEntry_Config::new)
    }
}

impl ::protobuf::Clear for DigestEntry_Config {
    fn clear(&mut self) {
        self.max_timeout_ns = 0;
        self.max_list_size = 0;
        self.ack_timeout_ns = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DigestEntry_Config {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DigestEntry_Config {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamMessageRequest {
    // message oneof groups
    pub update: ::std::option::Option<StreamMessageRequest_oneof_update>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamMessageRequest {
    fn default() -> &'a StreamMessageRequest {
        <StreamMessageRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum StreamMessageRequest_oneof_update {
    arbitration(MasterArbitrationUpdate),
    packet(PacketOut),
    digest_ack(DigestListAck),
    other(::protobuf::well_known_types::Any),
}

impl StreamMessageRequest {
    pub fn new() -> StreamMessageRequest {
        ::std::default::Default::default()
    }

    // .p4.v1.MasterArbitrationUpdate arbitration = 1;


    pub fn get_arbitration(&self) -> &MasterArbitrationUpdate {
        match self.update {
            ::std::option::Option::Some(StreamMessageRequest_oneof_update::arbitration(ref v)) => v,
            _ => <MasterArbitrationUpdate as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_arbitration(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_arbitration(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(StreamMessageRequest_oneof_update::arbitration(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_arbitration(&mut self, v: MasterArbitrationUpdate) {
        self.update = ::std::option::Option::Some(StreamMessageRequest_oneof_update::arbitration(v))
    }

    // Mutable pointer to the field.
    pub fn mut_arbitration(&mut self) -> &mut MasterArbitrationUpdate {
        if let ::std::option::Option::Some(StreamMessageRequest_oneof_update::arbitration(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(StreamMessageRequest_oneof_update::arbitration(MasterArbitrationUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(StreamMessageRequest_oneof_update::arbitration(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_arbitration(&mut self) -> MasterArbitrationUpdate {
        if self.has_arbitration() {
            match self.update.take() {
                ::std::option::Option::Some(StreamMessageRequest_oneof_update::arbitration(v)) => v,
                _ => panic!(),
            }
        } else {
            MasterArbitrationUpdate::new()
        }
    }

    // .p4.v1.PacketOut packet = 2;


    pub fn get_packet(&self) -> &PacketOut {
        match self.update {
            ::std::option::Option::Some(StreamMessageRequest_oneof_update::packet(ref v)) => v,
            _ => <PacketOut as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_packet(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_packet(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(StreamMessageRequest_oneof_update::packet(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_packet(&mut self, v: PacketOut) {
        self.update = ::std::option::Option::Some(StreamMessageRequest_oneof_update::packet(v))
    }

    // Mutable pointer to the field.
    pub fn mut_packet(&mut self) -> &mut PacketOut {
        if let ::std::option::Option::Some(StreamMessageRequest_oneof_update::packet(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(StreamMessageRequest_oneof_update::packet(PacketOut::new()));
        }
        match self.update {
            ::std::option::Option::Some(StreamMessageRequest_oneof_update::packet(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_packet(&mut self) -> PacketOut {
        if self.has_packet() {
            match self.update.take() {
                ::std::option::Option::Some(StreamMessageRequest_oneof_update::packet(v)) => v,
                _ => panic!(),
            }
        } else {
            PacketOut::new()
        }
    }

    // .p4.v1.DigestListAck digest_ack = 3;


    pub fn get_digest_ack(&self) -> &DigestListAck {
        match self.update {
            ::std::option::Option::Some(StreamMessageRequest_oneof_update::digest_ack(ref v)) => v,
            _ => <DigestListAck as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_digest_ack(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_digest_ack(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(StreamMessageRequest_oneof_update::digest_ack(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_digest_ack(&mut self, v: DigestListAck) {
        self.update = ::std::option::Option::Some(StreamMessageRequest_oneof_update::digest_ack(v))
    }

    // Mutable pointer to the field.
    pub fn mut_digest_ack(&mut self) -> &mut DigestListAck {
        if let ::std::option::Option::Some(StreamMessageRequest_oneof_update::digest_ack(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(StreamMessageRequest_oneof_update::digest_ack(DigestListAck::new()));
        }
        match self.update {
            ::std::option::Option::Some(StreamMessageRequest_oneof_update::digest_ack(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_digest_ack(&mut self) -> DigestListAck {
        if self.has_digest_ack() {
            match self.update.take() {
                ::std::option::Option::Some(StreamMessageRequest_oneof_update::digest_ack(v)) => v,
                _ => panic!(),
            }
        } else {
            DigestListAck::new()
        }
    }

    // .google.protobuf.Any other = 4;


    pub fn get_other(&self) -> &::protobuf::well_known_types::Any {
        match self.update {
            ::std::option::Option::Some(StreamMessageRequest_oneof_update::other(ref v)) => v,
            _ => <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_other(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_other(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(StreamMessageRequest_oneof_update::other(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_other(&mut self, v: ::protobuf::well_known_types::Any) {
        self.update = ::std::option::Option::Some(StreamMessageRequest_oneof_update::other(v))
    }

    // Mutable pointer to the field.
    pub fn mut_other(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if let ::std::option::Option::Some(StreamMessageRequest_oneof_update::other(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(StreamMessageRequest_oneof_update::other(::protobuf::well_known_types::Any::new()));
        }
        match self.update {
            ::std::option::Option::Some(StreamMessageRequest_oneof_update::other(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_other(&mut self) -> ::protobuf::well_known_types::Any {
        if self.has_other() {
            match self.update.take() {
                ::std::option::Option::Some(StreamMessageRequest_oneof_update::other(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Any::new()
        }
    }
}

impl ::protobuf::Message for StreamMessageRequest {
    fn is_initialized(&self) -> bool {
        if let Some(StreamMessageRequest_oneof_update::arbitration(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamMessageRequest_oneof_update::packet(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamMessageRequest_oneof_update::digest_ack(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamMessageRequest_oneof_update::other(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(StreamMessageRequest_oneof_update::arbitration(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(StreamMessageRequest_oneof_update::packet(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(StreamMessageRequest_oneof_update::digest_ack(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(StreamMessageRequest_oneof_update::other(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &StreamMessageRequest_oneof_update::arbitration(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamMessageRequest_oneof_update::packet(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamMessageRequest_oneof_update::digest_ack(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamMessageRequest_oneof_update::other(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &StreamMessageRequest_oneof_update::arbitration(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamMessageRequest_oneof_update::packet(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamMessageRequest_oneof_update::digest_ack(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamMessageRequest_oneof_update::other(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamMessageRequest {
        StreamMessageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MasterArbitrationUpdate>(
                "arbitration",
                StreamMessageRequest::has_arbitration,
                StreamMessageRequest::get_arbitration,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PacketOut>(
                "packet",
                StreamMessageRequest::has_packet,
                StreamMessageRequest::get_packet,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DigestListAck>(
                "digest_ack",
                StreamMessageRequest::has_digest_ack,
                StreamMessageRequest::get_digest_ack,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Any>(
                "other",
                StreamMessageRequest::has_other,
                StreamMessageRequest::get_other,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StreamMessageRequest>(
                "StreamMessageRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StreamMessageRequest {
        static instance: ::protobuf::rt::LazyV2<StreamMessageRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamMessageRequest::new)
    }
}

impl ::protobuf::Clear for StreamMessageRequest {
    fn clear(&mut self) {
        self.update = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamMessageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamMessageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PacketOut {
    // message fields
    pub payload: ::std::vec::Vec<u8>,
    pub metadata: ::protobuf::RepeatedField<PacketMetadata>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PacketOut {
    fn default() -> &'a PacketOut {
        <PacketOut as ::protobuf::Message>::default_instance()
    }
}

impl PacketOut {
    pub fn new() -> PacketOut {
        ::std::default::Default::default()
    }

    // bytes payload = 1;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    // repeated .p4.v1.PacketMetadata metadata = 2;


    pub fn get_metadata(&self) -> &[PacketMetadata] {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::RepeatedField<PacketMetadata>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::RepeatedField<PacketMetadata> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::RepeatedField<PacketMetadata> {
        ::std::mem::replace(&mut self.metadata, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PacketOut {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payload);
        }
        for value in &self.metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.payload.is_empty() {
            os.write_bytes(1, &self.payload)?;
        }
        for v in &self.metadata {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PacketOut {
        PacketOut::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payload",
                |m: &PacketOut| { &m.payload },
                |m: &mut PacketOut| { &mut m.payload },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PacketMetadata>>(
                "metadata",
                |m: &PacketOut| { &m.metadata },
                |m: &mut PacketOut| { &mut m.metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PacketOut>(
                "PacketOut",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PacketOut {
        static instance: ::protobuf::rt::LazyV2<PacketOut> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PacketOut::new)
    }
}

impl ::protobuf::Clear for PacketOut {
    fn clear(&mut self) {
        self.payload.clear();
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PacketOut {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PacketOut {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DigestListAck {
    // message fields
    pub digest_id: u32,
    pub list_id: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DigestListAck {
    fn default() -> &'a DigestListAck {
        <DigestListAck as ::protobuf::Message>::default_instance()
    }
}

impl DigestListAck {
    pub fn new() -> DigestListAck {
        ::std::default::Default::default()
    }

    // uint32 digest_id = 1;


    pub fn get_digest_id(&self) -> u32 {
        self.digest_id
    }
    pub fn clear_digest_id(&mut self) {
        self.digest_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_digest_id(&mut self, v: u32) {
        self.digest_id = v;
    }

    // uint64 list_id = 2;


    pub fn get_list_id(&self) -> u64 {
        self.list_id
    }
    pub fn clear_list_id(&mut self) {
        self.list_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_list_id(&mut self, v: u64) {
        self.list_id = v;
    }
}

impl ::protobuf::Message for DigestListAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.digest_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.list_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.digest_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.digest_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.list_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.list_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.digest_id != 0 {
            os.write_uint32(1, self.digest_id)?;
        }
        if self.list_id != 0 {
            os.write_uint64(2, self.list_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DigestListAck {
        DigestListAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "digest_id",
                |m: &DigestListAck| { &m.digest_id },
                |m: &mut DigestListAck| { &mut m.digest_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "list_id",
                |m: &DigestListAck| { &m.list_id },
                |m: &mut DigestListAck| { &mut m.list_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DigestListAck>(
                "DigestListAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DigestListAck {
        static instance: ::protobuf::rt::LazyV2<DigestListAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DigestListAck::new)
    }
}

impl ::protobuf::Clear for DigestListAck {
    fn clear(&mut self) {
        self.digest_id = 0;
        self.list_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DigestListAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DigestListAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamMessageResponse {
    // message oneof groups
    pub update: ::std::option::Option<StreamMessageResponse_oneof_update>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamMessageResponse {
    fn default() -> &'a StreamMessageResponse {
        <StreamMessageResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum StreamMessageResponse_oneof_update {
    arbitration(MasterArbitrationUpdate),
    packet(PacketIn),
    digest(DigestList),
    idle_timeout_notification(IdleTimeoutNotification),
    other(::protobuf::well_known_types::Any),
    error(StreamError),
}

impl StreamMessageResponse {
    pub fn new() -> StreamMessageResponse {
        ::std::default::Default::default()
    }

    // .p4.v1.MasterArbitrationUpdate arbitration = 1;


    pub fn get_arbitration(&self) -> &MasterArbitrationUpdate {
        match self.update {
            ::std::option::Option::Some(StreamMessageResponse_oneof_update::arbitration(ref v)) => v,
            _ => <MasterArbitrationUpdate as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_arbitration(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_arbitration(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(StreamMessageResponse_oneof_update::arbitration(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_arbitration(&mut self, v: MasterArbitrationUpdate) {
        self.update = ::std::option::Option::Some(StreamMessageResponse_oneof_update::arbitration(v))
    }

    // Mutable pointer to the field.
    pub fn mut_arbitration(&mut self) -> &mut MasterArbitrationUpdate {
        if let ::std::option::Option::Some(StreamMessageResponse_oneof_update::arbitration(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(StreamMessageResponse_oneof_update::arbitration(MasterArbitrationUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(StreamMessageResponse_oneof_update::arbitration(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_arbitration(&mut self) -> MasterArbitrationUpdate {
        if self.has_arbitration() {
            match self.update.take() {
                ::std::option::Option::Some(StreamMessageResponse_oneof_update::arbitration(v)) => v,
                _ => panic!(),
            }
        } else {
            MasterArbitrationUpdate::new()
        }
    }

    // .p4.v1.PacketIn packet = 2;


    pub fn get_packet(&self) -> &PacketIn {
        match self.update {
            ::std::option::Option::Some(StreamMessageResponse_oneof_update::packet(ref v)) => v,
            _ => <PacketIn as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_packet(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_packet(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(StreamMessageResponse_oneof_update::packet(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_packet(&mut self, v: PacketIn) {
        self.update = ::std::option::Option::Some(StreamMessageResponse_oneof_update::packet(v))
    }

    // Mutable pointer to the field.
    pub fn mut_packet(&mut self) -> &mut PacketIn {
        if let ::std::option::Option::Some(StreamMessageResponse_oneof_update::packet(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(StreamMessageResponse_oneof_update::packet(PacketIn::new()));
        }
        match self.update {
            ::std::option::Option::Some(StreamMessageResponse_oneof_update::packet(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_packet(&mut self) -> PacketIn {
        if self.has_packet() {
            match self.update.take() {
                ::std::option::Option::Some(StreamMessageResponse_oneof_update::packet(v)) => v,
                _ => panic!(),
            }
        } else {
            PacketIn::new()
        }
    }

    // .p4.v1.DigestList digest = 3;


    pub fn get_digest(&self) -> &DigestList {
        match self.update {
            ::std::option::Option::Some(StreamMessageResponse_oneof_update::digest(ref v)) => v,
            _ => <DigestList as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_digest(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_digest(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(StreamMessageResponse_oneof_update::digest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_digest(&mut self, v: DigestList) {
        self.update = ::std::option::Option::Some(StreamMessageResponse_oneof_update::digest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_digest(&mut self) -> &mut DigestList {
        if let ::std::option::Option::Some(StreamMessageResponse_oneof_update::digest(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(StreamMessageResponse_oneof_update::digest(DigestList::new()));
        }
        match self.update {
            ::std::option::Option::Some(StreamMessageResponse_oneof_update::digest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_digest(&mut self) -> DigestList {
        if self.has_digest() {
            match self.update.take() {
                ::std::option::Option::Some(StreamMessageResponse_oneof_update::digest(v)) => v,
                _ => panic!(),
            }
        } else {
            DigestList::new()
        }
    }

    // .p4.v1.IdleTimeoutNotification idle_timeout_notification = 4;


    pub fn get_idle_timeout_notification(&self) -> &IdleTimeoutNotification {
        match self.update {
            ::std::option::Option::Some(StreamMessageResponse_oneof_update::idle_timeout_notification(ref v)) => v,
            _ => <IdleTimeoutNotification as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_idle_timeout_notification(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_idle_timeout_notification(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(StreamMessageResponse_oneof_update::idle_timeout_notification(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_idle_timeout_notification(&mut self, v: IdleTimeoutNotification) {
        self.update = ::std::option::Option::Some(StreamMessageResponse_oneof_update::idle_timeout_notification(v))
    }

    // Mutable pointer to the field.
    pub fn mut_idle_timeout_notification(&mut self) -> &mut IdleTimeoutNotification {
        if let ::std::option::Option::Some(StreamMessageResponse_oneof_update::idle_timeout_notification(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(StreamMessageResponse_oneof_update::idle_timeout_notification(IdleTimeoutNotification::new()));
        }
        match self.update {
            ::std::option::Option::Some(StreamMessageResponse_oneof_update::idle_timeout_notification(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_idle_timeout_notification(&mut self) -> IdleTimeoutNotification {
        if self.has_idle_timeout_notification() {
            match self.update.take() {
                ::std::option::Option::Some(StreamMessageResponse_oneof_update::idle_timeout_notification(v)) => v,
                _ => panic!(),
            }
        } else {
            IdleTimeoutNotification::new()
        }
    }

    // .google.protobuf.Any other = 5;


    pub fn get_other(&self) -> &::protobuf::well_known_types::Any {
        match self.update {
            ::std::option::Option::Some(StreamMessageResponse_oneof_update::other(ref v)) => v,
            _ => <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_other(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_other(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(StreamMessageResponse_oneof_update::other(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_other(&mut self, v: ::protobuf::well_known_types::Any) {
        self.update = ::std::option::Option::Some(StreamMessageResponse_oneof_update::other(v))
    }

    // Mutable pointer to the field.
    pub fn mut_other(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if let ::std::option::Option::Some(StreamMessageResponse_oneof_update::other(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(StreamMessageResponse_oneof_update::other(::protobuf::well_known_types::Any::new()));
        }
        match self.update {
            ::std::option::Option::Some(StreamMessageResponse_oneof_update::other(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_other(&mut self) -> ::protobuf::well_known_types::Any {
        if self.has_other() {
            match self.update.take() {
                ::std::option::Option::Some(StreamMessageResponse_oneof_update::other(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Any::new()
        }
    }

    // .p4.v1.StreamError error = 6;


    pub fn get_error(&self) -> &StreamError {
        match self.update {
            ::std::option::Option::Some(StreamMessageResponse_oneof_update::error(ref v)) => v,
            _ => <StreamError as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_error(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(StreamMessageResponse_oneof_update::error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: StreamError) {
        self.update = ::std::option::Option::Some(StreamMessageResponse_oneof_update::error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut StreamError {
        if let ::std::option::Option::Some(StreamMessageResponse_oneof_update::error(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(StreamMessageResponse_oneof_update::error(StreamError::new()));
        }
        match self.update {
            ::std::option::Option::Some(StreamMessageResponse_oneof_update::error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> StreamError {
        if self.has_error() {
            match self.update.take() {
                ::std::option::Option::Some(StreamMessageResponse_oneof_update::error(v)) => v,
                _ => panic!(),
            }
        } else {
            StreamError::new()
        }
    }
}

impl ::protobuf::Message for StreamMessageResponse {
    fn is_initialized(&self) -> bool {
        if let Some(StreamMessageResponse_oneof_update::arbitration(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamMessageResponse_oneof_update::packet(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamMessageResponse_oneof_update::digest(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamMessageResponse_oneof_update::idle_timeout_notification(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamMessageResponse_oneof_update::other(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamMessageResponse_oneof_update::error(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(StreamMessageResponse_oneof_update::arbitration(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(StreamMessageResponse_oneof_update::packet(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(StreamMessageResponse_oneof_update::digest(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(StreamMessageResponse_oneof_update::idle_timeout_notification(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(StreamMessageResponse_oneof_update::other(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(StreamMessageResponse_oneof_update::error(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &StreamMessageResponse_oneof_update::arbitration(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamMessageResponse_oneof_update::packet(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamMessageResponse_oneof_update::digest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamMessageResponse_oneof_update::idle_timeout_notification(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamMessageResponse_oneof_update::other(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamMessageResponse_oneof_update::error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &StreamMessageResponse_oneof_update::arbitration(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamMessageResponse_oneof_update::packet(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamMessageResponse_oneof_update::digest(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamMessageResponse_oneof_update::idle_timeout_notification(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamMessageResponse_oneof_update::other(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamMessageResponse_oneof_update::error(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamMessageResponse {
        StreamMessageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MasterArbitrationUpdate>(
                "arbitration",
                StreamMessageResponse::has_arbitration,
                StreamMessageResponse::get_arbitration,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PacketIn>(
                "packet",
                StreamMessageResponse::has_packet,
                StreamMessageResponse::get_packet,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DigestList>(
                "digest",
                StreamMessageResponse::has_digest,
                StreamMessageResponse::get_digest,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, IdleTimeoutNotification>(
                "idle_timeout_notification",
                StreamMessageResponse::has_idle_timeout_notification,
                StreamMessageResponse::get_idle_timeout_notification,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Any>(
                "other",
                StreamMessageResponse::has_other,
                StreamMessageResponse::get_other,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StreamError>(
                "error",
                StreamMessageResponse::has_error,
                StreamMessageResponse::get_error,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StreamMessageResponse>(
                "StreamMessageResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StreamMessageResponse {
        static instance: ::protobuf::rt::LazyV2<StreamMessageResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamMessageResponse::new)
    }
}

impl ::protobuf::Clear for StreamMessageResponse {
    fn clear(&mut self) {
        self.update = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamMessageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamMessageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PacketIn {
    // message fields
    pub payload: ::std::vec::Vec<u8>,
    pub metadata: ::protobuf::RepeatedField<PacketMetadata>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PacketIn {
    fn default() -> &'a PacketIn {
        <PacketIn as ::protobuf::Message>::default_instance()
    }
}

impl PacketIn {
    pub fn new() -> PacketIn {
        ::std::default::Default::default()
    }

    // bytes payload = 1;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    // repeated .p4.v1.PacketMetadata metadata = 2;


    pub fn get_metadata(&self) -> &[PacketMetadata] {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::RepeatedField<PacketMetadata>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::RepeatedField<PacketMetadata> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::RepeatedField<PacketMetadata> {
        ::std::mem::replace(&mut self.metadata, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PacketIn {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payload);
        }
        for value in &self.metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.payload.is_empty() {
            os.write_bytes(1, &self.payload)?;
        }
        for v in &self.metadata {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PacketIn {
        PacketIn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payload",
                |m: &PacketIn| { &m.payload },
                |m: &mut PacketIn| { &mut m.payload },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PacketMetadata>>(
                "metadata",
                |m: &PacketIn| { &m.metadata },
                |m: &mut PacketIn| { &mut m.metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PacketIn>(
                "PacketIn",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PacketIn {
        static instance: ::protobuf::rt::LazyV2<PacketIn> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PacketIn::new)
    }
}

impl ::protobuf::Clear for PacketIn {
    fn clear(&mut self) {
        self.payload.clear();
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PacketIn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PacketIn {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DigestList {
    // message fields
    pub digest_id: u32,
    pub list_id: u64,
    pub data: ::protobuf::RepeatedField<super::p4data::P4Data>,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DigestList {
    fn default() -> &'a DigestList {
        <DigestList as ::protobuf::Message>::default_instance()
    }
}

impl DigestList {
    pub fn new() -> DigestList {
        ::std::default::Default::default()
    }

    // uint32 digest_id = 1;


    pub fn get_digest_id(&self) -> u32 {
        self.digest_id
    }
    pub fn clear_digest_id(&mut self) {
        self.digest_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_digest_id(&mut self, v: u32) {
        self.digest_id = v;
    }

    // uint64 list_id = 2;


    pub fn get_list_id(&self) -> u64 {
        self.list_id
    }
    pub fn clear_list_id(&mut self) {
        self.list_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_list_id(&mut self, v: u64) {
        self.list_id = v;
    }

    // repeated .p4.v1.P4Data data = 3;


    pub fn get_data(&self) -> &[super::p4data::P4Data] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<super::p4data::P4Data>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<super::p4data::P4Data> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<super::p4data::P4Data> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }

    // int64 timestamp = 4;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for DigestList {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.digest_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.list_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.digest_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.digest_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.list_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.list_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(4, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.digest_id != 0 {
            os.write_uint32(1, self.digest_id)?;
        }
        if self.list_id != 0 {
            os.write_uint64(2, self.list_id)?;
        }
        for v in &self.data {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.timestamp != 0 {
            os.write_int64(4, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DigestList {
        DigestList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "digest_id",
                |m: &DigestList| { &m.digest_id },
                |m: &mut DigestList| { &mut m.digest_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "list_id",
                |m: &DigestList| { &m.list_id },
                |m: &mut DigestList| { &mut m.list_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4data::P4Data>>(
                "data",
                |m: &DigestList| { &m.data },
                |m: &mut DigestList| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &DigestList| { &m.timestamp },
                |m: &mut DigestList| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DigestList>(
                "DigestList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DigestList {
        static instance: ::protobuf::rt::LazyV2<DigestList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DigestList::new)
    }
}

impl ::protobuf::Clear for DigestList {
    fn clear(&mut self) {
        self.digest_id = 0;
        self.list_id = 0;
        self.data.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DigestList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DigestList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PacketMetadata {
    // message fields
    pub metadata_id: u32,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PacketMetadata {
    fn default() -> &'a PacketMetadata {
        <PacketMetadata as ::protobuf::Message>::default_instance()
    }
}

impl PacketMetadata {
    pub fn new() -> PacketMetadata {
        ::std::default::Default::default()
    }

    // uint32 metadata_id = 1;


    pub fn get_metadata_id(&self) -> u32 {
        self.metadata_id
    }
    pub fn clear_metadata_id(&mut self) {
        self.metadata_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_metadata_id(&mut self, v: u32) {
        self.metadata_id = v;
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PacketMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.metadata_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.metadata_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.metadata_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.metadata_id != 0 {
            os.write_uint32(1, self.metadata_id)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PacketMetadata {
        PacketMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "metadata_id",
                |m: &PacketMetadata| { &m.metadata_id },
                |m: &mut PacketMetadata| { &mut m.metadata_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &PacketMetadata| { &m.value },
                |m: &mut PacketMetadata| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PacketMetadata>(
                "PacketMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PacketMetadata {
        static instance: ::protobuf::rt::LazyV2<PacketMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PacketMetadata::new)
    }
}

impl ::protobuf::Clear for PacketMetadata {
    fn clear(&mut self) {
        self.metadata_id = 0;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PacketMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PacketMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MasterArbitrationUpdate {
    // message fields
    pub device_id: u64,
    pub role: ::protobuf::SingularPtrField<Role>,
    pub election_id: ::protobuf::SingularPtrField<Uint128>,
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MasterArbitrationUpdate {
    fn default() -> &'a MasterArbitrationUpdate {
        <MasterArbitrationUpdate as ::protobuf::Message>::default_instance()
    }
}

impl MasterArbitrationUpdate {
    pub fn new() -> MasterArbitrationUpdate {
        ::std::default::Default::default()
    }

    // uint64 device_id = 1;


    pub fn get_device_id(&self) -> u64 {
        self.device_id
    }
    pub fn clear_device_id(&mut self) {
        self.device_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: u64) {
        self.device_id = v;
    }

    // .p4.v1.Role role = 2;


    pub fn get_role(&self) -> &Role {
        self.role.as_ref().unwrap_or_else(|| <Role as ::protobuf::Message>::default_instance())
    }
    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: Role) {
        self.role = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut Role {
        if self.role.is_none() {
            self.role.set_default();
        }
        self.role.as_mut().unwrap()
    }

    // Take field
    pub fn take_role(&mut self) -> Role {
        self.role.take().unwrap_or_else(|| Role::new())
    }

    // .p4.v1.Uint128 election_id = 3;


    pub fn get_election_id(&self) -> &Uint128 {
        self.election_id.as_ref().unwrap_or_else(|| <Uint128 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_election_id(&mut self) {
        self.election_id.clear();
    }

    pub fn has_election_id(&self) -> bool {
        self.election_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_election_id(&mut self, v: Uint128) {
        self.election_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_election_id(&mut self) -> &mut Uint128 {
        if self.election_id.is_none() {
            self.election_id.set_default();
        }
        self.election_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_election_id(&mut self) -> Uint128 {
        self.election_id.take().unwrap_or_else(|| Uint128::new())
    }

    // .google.rpc.Status status = 4;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }
}

impl ::protobuf::Message for MasterArbitrationUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.role {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.election_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.device_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.role)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.election_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.device_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.device_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.role.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.election_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.device_id != 0 {
            os.write_uint64(1, self.device_id)?;
        }
        if let Some(ref v) = self.role.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.election_id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MasterArbitrationUpdate {
        MasterArbitrationUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "device_id",
                |m: &MasterArbitrationUpdate| { &m.device_id },
                |m: &mut MasterArbitrationUpdate| { &mut m.device_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Role>>(
                "role",
                |m: &MasterArbitrationUpdate| { &m.role },
                |m: &mut MasterArbitrationUpdate| { &mut m.role },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Uint128>>(
                "election_id",
                |m: &MasterArbitrationUpdate| { &m.election_id },
                |m: &mut MasterArbitrationUpdate| { &mut m.election_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MasterArbitrationUpdate| { &m.status },
                |m: &mut MasterArbitrationUpdate| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MasterArbitrationUpdate>(
                "MasterArbitrationUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MasterArbitrationUpdate {
        static instance: ::protobuf::rt::LazyV2<MasterArbitrationUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MasterArbitrationUpdate::new)
    }
}

impl ::protobuf::Clear for MasterArbitrationUpdate {
    fn clear(&mut self) {
        self.device_id = 0;
        self.role.clear();
        self.election_id.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MasterArbitrationUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MasterArbitrationUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Role {
    // message fields
    pub id: u64,
    pub config: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Role {
    fn default() -> &'a Role {
        <Role as ::protobuf::Message>::default_instance()
    }
}

impl Role {
    pub fn new() -> Role {
        ::std::default::Default::default()
    }

    // uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = v;
    }

    // .google.protobuf.Any config = 2;


    pub fn get_config(&self) -> &::protobuf::well_known_types::Any {
        self.config.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ::protobuf::well_known_types::Any) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> ::protobuf::well_known_types::Any {
        self.config.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for Role {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Role {
        Role::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &Role| { &m.id },
                |m: &mut Role| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "config",
                |m: &Role| { &m.config },
                |m: &mut Role| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Role>(
                "Role",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Role {
        static instance: ::protobuf::rt::LazyV2<Role> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Role::new)
    }
}

impl ::protobuf::Clear for Role {
    fn clear(&mut self) {
        self.id = 0;
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Role {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Role {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IdleTimeoutNotification {
    // message fields
    pub table_entry: ::protobuf::RepeatedField<TableEntry>,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IdleTimeoutNotification {
    fn default() -> &'a IdleTimeoutNotification {
        <IdleTimeoutNotification as ::protobuf::Message>::default_instance()
    }
}

impl IdleTimeoutNotification {
    pub fn new() -> IdleTimeoutNotification {
        ::std::default::Default::default()
    }

    // repeated .p4.v1.TableEntry table_entry = 1;


    pub fn get_table_entry(&self) -> &[TableEntry] {
        &self.table_entry
    }
    pub fn clear_table_entry(&mut self) {
        self.table_entry.clear();
    }

    // Param is passed by value, moved
    pub fn set_table_entry(&mut self, v: ::protobuf::RepeatedField<TableEntry>) {
        self.table_entry = v;
    }

    // Mutable pointer to the field.
    pub fn mut_table_entry(&mut self) -> &mut ::protobuf::RepeatedField<TableEntry> {
        &mut self.table_entry
    }

    // Take field
    pub fn take_table_entry(&mut self) -> ::protobuf::RepeatedField<TableEntry> {
        ::std::mem::replace(&mut self.table_entry, ::protobuf::RepeatedField::new())
    }

    // int64 timestamp = 2;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for IdleTimeoutNotification {
    fn is_initialized(&self) -> bool {
        for v in &self.table_entry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.table_entry)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.table_entry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.table_entry {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.timestamp != 0 {
            os.write_int64(2, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IdleTimeoutNotification {
        IdleTimeoutNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableEntry>>(
                "table_entry",
                |m: &IdleTimeoutNotification| { &m.table_entry },
                |m: &mut IdleTimeoutNotification| { &mut m.table_entry },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &IdleTimeoutNotification| { &m.timestamp },
                |m: &mut IdleTimeoutNotification| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IdleTimeoutNotification>(
                "IdleTimeoutNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IdleTimeoutNotification {
        static instance: ::protobuf::rt::LazyV2<IdleTimeoutNotification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IdleTimeoutNotification::new)
    }
}

impl ::protobuf::Clear for IdleTimeoutNotification {
    fn clear(&mut self) {
        self.table_entry.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IdleTimeoutNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdleTimeoutNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamError {
    // message fields
    pub canonical_code: i32,
    pub message: ::std::string::String,
    pub space: ::std::string::String,
    pub code: i32,
    // message oneof groups
    pub details: ::std::option::Option<StreamError_oneof_details>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamError {
    fn default() -> &'a StreamError {
        <StreamError as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum StreamError_oneof_details {
    packet_out(PacketOutError),
    digest_list_ack(DigestListAckError),
    other(StreamOtherError),
}

impl StreamError {
    pub fn new() -> StreamError {
        ::std::default::Default::default()
    }

    // int32 canonical_code = 1;


    pub fn get_canonical_code(&self) -> i32 {
        self.canonical_code
    }
    pub fn clear_canonical_code(&mut self) {
        self.canonical_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_canonical_code(&mut self, v: i32) {
        self.canonical_code = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // string space = 3;


    pub fn get_space(&self) -> &str {
        &self.space
    }
    pub fn clear_space(&mut self) {
        self.space.clear();
    }

    // Param is passed by value, moved
    pub fn set_space(&mut self, v: ::std::string::String) {
        self.space = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_space(&mut self) -> &mut ::std::string::String {
        &mut self.space
    }

    // Take field
    pub fn take_space(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.space, ::std::string::String::new())
    }

    // int32 code = 4;


    pub fn get_code(&self) -> i32 {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = 0;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: i32) {
        self.code = v;
    }

    // .p4.v1.PacketOutError packet_out = 5;


    pub fn get_packet_out(&self) -> &PacketOutError {
        match self.details {
            ::std::option::Option::Some(StreamError_oneof_details::packet_out(ref v)) => v,
            _ => <PacketOutError as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_packet_out(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_packet_out(&self) -> bool {
        match self.details {
            ::std::option::Option::Some(StreamError_oneof_details::packet_out(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_packet_out(&mut self, v: PacketOutError) {
        self.details = ::std::option::Option::Some(StreamError_oneof_details::packet_out(v))
    }

    // Mutable pointer to the field.
    pub fn mut_packet_out(&mut self) -> &mut PacketOutError {
        if let ::std::option::Option::Some(StreamError_oneof_details::packet_out(_)) = self.details {
        } else {
            self.details = ::std::option::Option::Some(StreamError_oneof_details::packet_out(PacketOutError::new()));
        }
        match self.details {
            ::std::option::Option::Some(StreamError_oneof_details::packet_out(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_packet_out(&mut self) -> PacketOutError {
        if self.has_packet_out() {
            match self.details.take() {
                ::std::option::Option::Some(StreamError_oneof_details::packet_out(v)) => v,
                _ => panic!(),
            }
        } else {
            PacketOutError::new()
        }
    }

    // .p4.v1.DigestListAckError digest_list_ack = 6;


    pub fn get_digest_list_ack(&self) -> &DigestListAckError {
        match self.details {
            ::std::option::Option::Some(StreamError_oneof_details::digest_list_ack(ref v)) => v,
            _ => <DigestListAckError as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_digest_list_ack(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_digest_list_ack(&self) -> bool {
        match self.details {
            ::std::option::Option::Some(StreamError_oneof_details::digest_list_ack(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_digest_list_ack(&mut self, v: DigestListAckError) {
        self.details = ::std::option::Option::Some(StreamError_oneof_details::digest_list_ack(v))
    }

    // Mutable pointer to the field.
    pub fn mut_digest_list_ack(&mut self) -> &mut DigestListAckError {
        if let ::std::option::Option::Some(StreamError_oneof_details::digest_list_ack(_)) = self.details {
        } else {
            self.details = ::std::option::Option::Some(StreamError_oneof_details::digest_list_ack(DigestListAckError::new()));
        }
        match self.details {
            ::std::option::Option::Some(StreamError_oneof_details::digest_list_ack(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_digest_list_ack(&mut self) -> DigestListAckError {
        if self.has_digest_list_ack() {
            match self.details.take() {
                ::std::option::Option::Some(StreamError_oneof_details::digest_list_ack(v)) => v,
                _ => panic!(),
            }
        } else {
            DigestListAckError::new()
        }
    }

    // .p4.v1.StreamOtherError other = 7;


    pub fn get_other(&self) -> &StreamOtherError {
        match self.details {
            ::std::option::Option::Some(StreamError_oneof_details::other(ref v)) => v,
            _ => <StreamOtherError as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_other(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_other(&self) -> bool {
        match self.details {
            ::std::option::Option::Some(StreamError_oneof_details::other(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_other(&mut self, v: StreamOtherError) {
        self.details = ::std::option::Option::Some(StreamError_oneof_details::other(v))
    }

    // Mutable pointer to the field.
    pub fn mut_other(&mut self) -> &mut StreamOtherError {
        if let ::std::option::Option::Some(StreamError_oneof_details::other(_)) = self.details {
        } else {
            self.details = ::std::option::Option::Some(StreamError_oneof_details::other(StreamOtherError::new()));
        }
        match self.details {
            ::std::option::Option::Some(StreamError_oneof_details::other(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_other(&mut self) -> StreamOtherError {
        if self.has_other() {
            match self.details.take() {
                ::std::option::Option::Some(StreamError_oneof_details::other(v)) => v,
                _ => panic!(),
            }
        } else {
            StreamOtherError::new()
        }
    }
}

impl ::protobuf::Message for StreamError {
    fn is_initialized(&self) -> bool {
        if let Some(StreamError_oneof_details::packet_out(ref v)) = self.details {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamError_oneof_details::digest_list_ack(ref v)) = self.details {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamError_oneof_details::other(ref v)) = self.details {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.canonical_code = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.space)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.code = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.details = ::std::option::Option::Some(StreamError_oneof_details::packet_out(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.details = ::std::option::Option::Some(StreamError_oneof_details::digest_list_ack(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.details = ::std::option::Option::Some(StreamError_oneof_details::other(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.canonical_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.canonical_code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if !self.space.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.space);
        }
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(4, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.details {
            match v {
                &StreamError_oneof_details::packet_out(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamError_oneof_details::digest_list_ack(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamError_oneof_details::other(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.canonical_code != 0 {
            os.write_int32(1, self.canonical_code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if !self.space.is_empty() {
            os.write_string(3, &self.space)?;
        }
        if self.code != 0 {
            os.write_int32(4, self.code)?;
        }
        if let ::std::option::Option::Some(ref v) = self.details {
            match v {
                &StreamError_oneof_details::packet_out(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamError_oneof_details::digest_list_ack(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamError_oneof_details::other(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamError {
        StreamError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "canonical_code",
                |m: &StreamError| { &m.canonical_code },
                |m: &mut StreamError| { &mut m.canonical_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &StreamError| { &m.message },
                |m: &mut StreamError| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "space",
                |m: &StreamError| { &m.space },
                |m: &mut StreamError| { &mut m.space },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "code",
                |m: &StreamError| { &m.code },
                |m: &mut StreamError| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PacketOutError>(
                "packet_out",
                StreamError::has_packet_out,
                StreamError::get_packet_out,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DigestListAckError>(
                "digest_list_ack",
                StreamError::has_digest_list_ack,
                StreamError::get_digest_list_ack,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StreamOtherError>(
                "other",
                StreamError::has_other,
                StreamError::get_other,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StreamError>(
                "StreamError",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StreamError {
        static instance: ::protobuf::rt::LazyV2<StreamError> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamError::new)
    }
}

impl ::protobuf::Clear for StreamError {
    fn clear(&mut self) {
        self.canonical_code = 0;
        self.message.clear();
        self.space.clear();
        self.code = 0;
        self.details = ::std::option::Option::None;
        self.details = ::std::option::Option::None;
        self.details = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamError {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PacketOutError {
    // message fields
    pub packet_out: ::protobuf::SingularPtrField<PacketOut>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PacketOutError {
    fn default() -> &'a PacketOutError {
        <PacketOutError as ::protobuf::Message>::default_instance()
    }
}

impl PacketOutError {
    pub fn new() -> PacketOutError {
        ::std::default::Default::default()
    }

    // .p4.v1.PacketOut packet_out = 1;


    pub fn get_packet_out(&self) -> &PacketOut {
        self.packet_out.as_ref().unwrap_or_else(|| <PacketOut as ::protobuf::Message>::default_instance())
    }
    pub fn clear_packet_out(&mut self) {
        self.packet_out.clear();
    }

    pub fn has_packet_out(&self) -> bool {
        self.packet_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet_out(&mut self, v: PacketOut) {
        self.packet_out = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packet_out(&mut self) -> &mut PacketOut {
        if self.packet_out.is_none() {
            self.packet_out.set_default();
        }
        self.packet_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_packet_out(&mut self) -> PacketOut {
        self.packet_out.take().unwrap_or_else(|| PacketOut::new())
    }
}

impl ::protobuf::Message for PacketOutError {
    fn is_initialized(&self) -> bool {
        for v in &self.packet_out {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.packet_out)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.packet_out.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.packet_out.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PacketOutError {
        PacketOutError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PacketOut>>(
                "packet_out",
                |m: &PacketOutError| { &m.packet_out },
                |m: &mut PacketOutError| { &mut m.packet_out },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PacketOutError>(
                "PacketOutError",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PacketOutError {
        static instance: ::protobuf::rt::LazyV2<PacketOutError> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PacketOutError::new)
    }
}

impl ::protobuf::Clear for PacketOutError {
    fn clear(&mut self) {
        self.packet_out.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PacketOutError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PacketOutError {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DigestListAckError {
    // message fields
    pub digest_list_ack: ::protobuf::SingularPtrField<DigestListAck>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DigestListAckError {
    fn default() -> &'a DigestListAckError {
        <DigestListAckError as ::protobuf::Message>::default_instance()
    }
}

impl DigestListAckError {
    pub fn new() -> DigestListAckError {
        ::std::default::Default::default()
    }

    // .p4.v1.DigestListAck digest_list_ack = 1;


    pub fn get_digest_list_ack(&self) -> &DigestListAck {
        self.digest_list_ack.as_ref().unwrap_or_else(|| <DigestListAck as ::protobuf::Message>::default_instance())
    }
    pub fn clear_digest_list_ack(&mut self) {
        self.digest_list_ack.clear();
    }

    pub fn has_digest_list_ack(&self) -> bool {
        self.digest_list_ack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_digest_list_ack(&mut self, v: DigestListAck) {
        self.digest_list_ack = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_digest_list_ack(&mut self) -> &mut DigestListAck {
        if self.digest_list_ack.is_none() {
            self.digest_list_ack.set_default();
        }
        self.digest_list_ack.as_mut().unwrap()
    }

    // Take field
    pub fn take_digest_list_ack(&mut self) -> DigestListAck {
        self.digest_list_ack.take().unwrap_or_else(|| DigestListAck::new())
    }
}

impl ::protobuf::Message for DigestListAckError {
    fn is_initialized(&self) -> bool {
        for v in &self.digest_list_ack {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.digest_list_ack)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.digest_list_ack.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.digest_list_ack.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DigestListAckError {
        DigestListAckError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DigestListAck>>(
                "digest_list_ack",
                |m: &DigestListAckError| { &m.digest_list_ack },
                |m: &mut DigestListAckError| { &mut m.digest_list_ack },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DigestListAckError>(
                "DigestListAckError",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DigestListAckError {
        static instance: ::protobuf::rt::LazyV2<DigestListAckError> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DigestListAckError::new)
    }
}

impl ::protobuf::Clear for DigestListAckError {
    fn clear(&mut self) {
        self.digest_list_ack.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DigestListAckError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DigestListAckError {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamOtherError {
    // message fields
    pub other: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOtherError {
    fn default() -> &'a StreamOtherError {
        <StreamOtherError as ::protobuf::Message>::default_instance()
    }
}

impl StreamOtherError {
    pub fn new() -> StreamOtherError {
        ::std::default::Default::default()
    }

    // .google.protobuf.Any other = 1;


    pub fn get_other(&self) -> &::protobuf::well_known_types::Any {
        self.other.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_other(&mut self) {
        self.other.clear();
    }

    pub fn has_other(&self) -> bool {
        self.other.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other(&mut self, v: ::protobuf::well_known_types::Any) {
        self.other = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_other(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.other.is_none() {
            self.other.set_default();
        }
        self.other.as_mut().unwrap()
    }

    // Take field
    pub fn take_other(&mut self) -> ::protobuf::well_known_types::Any {
        self.other.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for StreamOtherError {
    fn is_initialized(&self) -> bool {
        for v in &self.other {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.other)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.other.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.other.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOtherError {
        StreamOtherError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "other",
                |m: &StreamOtherError| { &m.other },
                |m: &mut StreamOtherError| { &mut m.other },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StreamOtherError>(
                "StreamOtherError",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StreamOtherError {
        static instance: ::protobuf::rt::LazyV2<StreamOtherError> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOtherError::new)
    }
}

impl ::protobuf::Clear for StreamOtherError {
    fn clear(&mut self) {
        self.other.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamOtherError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOtherError {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Uint128 {
    // message fields
    pub high: u64,
    pub low: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Uint128 {
    fn default() -> &'a Uint128 {
        <Uint128 as ::protobuf::Message>::default_instance()
    }
}

impl Uint128 {
    pub fn new() -> Uint128 {
        ::std::default::Default::default()
    }

    // uint64 high = 1;


    pub fn get_high(&self) -> u64 {
        self.high
    }
    pub fn clear_high(&mut self) {
        self.high = 0;
    }

    // Param is passed by value, moved
    pub fn set_high(&mut self, v: u64) {
        self.high = v;
    }

    // uint64 low = 2;


    pub fn get_low(&self) -> u64 {
        self.low
    }
    pub fn clear_low(&mut self) {
        self.low = 0;
    }

    // Param is passed by value, moved
    pub fn set_low(&mut self, v: u64) {
        self.low = v;
    }
}

impl ::protobuf::Message for Uint128 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.high = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.low = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.high != 0 {
            my_size += ::protobuf::rt::value_size(1, self.high, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.low != 0 {
            my_size += ::protobuf::rt::value_size(2, self.low, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.high != 0 {
            os.write_uint64(1, self.high)?;
        }
        if self.low != 0 {
            os.write_uint64(2, self.low)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Uint128 {
        Uint128::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "high",
                |m: &Uint128| { &m.high },
                |m: &mut Uint128| { &mut m.high },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "low",
                |m: &Uint128| { &m.low },
                |m: &mut Uint128| { &mut m.low },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Uint128>(
                "Uint128",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Uint128 {
        static instance: ::protobuf::rt::LazyV2<Uint128> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Uint128::new)
    }
}

impl ::protobuf::Clear for Uint128 {
    fn clear(&mut self) {
        self.high = 0;
        self.low = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Uint128 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Uint128 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetForwardingPipelineConfigRequest {
    // message fields
    pub device_id: u64,
    pub role_id: u64,
    pub election_id: ::protobuf::SingularPtrField<Uint128>,
    pub action: SetForwardingPipelineConfigRequest_Action,
    pub config: ::protobuf::SingularPtrField<ForwardingPipelineConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetForwardingPipelineConfigRequest {
    fn default() -> &'a SetForwardingPipelineConfigRequest {
        <SetForwardingPipelineConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetForwardingPipelineConfigRequest {
    pub fn new() -> SetForwardingPipelineConfigRequest {
        ::std::default::Default::default()
    }

    // uint64 device_id = 1;


    pub fn get_device_id(&self) -> u64 {
        self.device_id
    }
    pub fn clear_device_id(&mut self) {
        self.device_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: u64) {
        self.device_id = v;
    }

    // uint64 role_id = 2;


    pub fn get_role_id(&self) -> u64 {
        self.role_id
    }
    pub fn clear_role_id(&mut self) {
        self.role_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = v;
    }

    // .p4.v1.Uint128 election_id = 3;


    pub fn get_election_id(&self) -> &Uint128 {
        self.election_id.as_ref().unwrap_or_else(|| <Uint128 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_election_id(&mut self) {
        self.election_id.clear();
    }

    pub fn has_election_id(&self) -> bool {
        self.election_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_election_id(&mut self, v: Uint128) {
        self.election_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_election_id(&mut self) -> &mut Uint128 {
        if self.election_id.is_none() {
            self.election_id.set_default();
        }
        self.election_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_election_id(&mut self) -> Uint128 {
        self.election_id.take().unwrap_or_else(|| Uint128::new())
    }

    // .p4.v1.SetForwardingPipelineConfigRequest.Action action = 4;


    pub fn get_action(&self) -> SetForwardingPipelineConfigRequest_Action {
        self.action
    }
    pub fn clear_action(&mut self) {
        self.action = SetForwardingPipelineConfigRequest_Action::UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: SetForwardingPipelineConfigRequest_Action) {
        self.action = v;
    }

    // .p4.v1.ForwardingPipelineConfig config = 5;


    pub fn get_config(&self) -> &ForwardingPipelineConfig {
        self.config.as_ref().unwrap_or_else(|| <ForwardingPipelineConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ForwardingPipelineConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut ForwardingPipelineConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> ForwardingPipelineConfig {
        self.config.take().unwrap_or_else(|| ForwardingPipelineConfig::new())
    }
}

impl ::protobuf::Message for SetForwardingPipelineConfigRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.election_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.device_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.role_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.election_id)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.device_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.device_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.role_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.role_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.election_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.action != SetForwardingPipelineConfigRequest_Action::UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.action);
        }
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.device_id != 0 {
            os.write_uint64(1, self.device_id)?;
        }
        if self.role_id != 0 {
            os.write_uint64(2, self.role_id)?;
        }
        if let Some(ref v) = self.election_id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.action != SetForwardingPipelineConfigRequest_Action::UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.action))?;
        }
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetForwardingPipelineConfigRequest {
        SetForwardingPipelineConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "device_id",
                |m: &SetForwardingPipelineConfigRequest| { &m.device_id },
                |m: &mut SetForwardingPipelineConfigRequest| { &mut m.device_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "role_id",
                |m: &SetForwardingPipelineConfigRequest| { &m.role_id },
                |m: &mut SetForwardingPipelineConfigRequest| { &mut m.role_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Uint128>>(
                "election_id",
                |m: &SetForwardingPipelineConfigRequest| { &m.election_id },
                |m: &mut SetForwardingPipelineConfigRequest| { &mut m.election_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SetForwardingPipelineConfigRequest_Action>>(
                "action",
                |m: &SetForwardingPipelineConfigRequest| { &m.action },
                |m: &mut SetForwardingPipelineConfigRequest| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ForwardingPipelineConfig>>(
                "config",
                |m: &SetForwardingPipelineConfigRequest| { &m.config },
                |m: &mut SetForwardingPipelineConfigRequest| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetForwardingPipelineConfigRequest>(
                "SetForwardingPipelineConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetForwardingPipelineConfigRequest {
        static instance: ::protobuf::rt::LazyV2<SetForwardingPipelineConfigRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetForwardingPipelineConfigRequest::new)
    }
}

impl ::protobuf::Clear for SetForwardingPipelineConfigRequest {
    fn clear(&mut self) {
        self.device_id = 0;
        self.role_id = 0;
        self.election_id.clear();
        self.action = SetForwardingPipelineConfigRequest_Action::UNSPECIFIED;
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetForwardingPipelineConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetForwardingPipelineConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SetForwardingPipelineConfigRequest_Action {
    UNSPECIFIED = 0,
    VERIFY = 1,
    VERIFY_AND_SAVE = 2,
    VERIFY_AND_COMMIT = 3,
    COMMIT = 4,
    RECONCILE_AND_COMMIT = 5,
}

impl ::protobuf::ProtobufEnum for SetForwardingPipelineConfigRequest_Action {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SetForwardingPipelineConfigRequest_Action> {
        match value {
            0 => ::std::option::Option::Some(SetForwardingPipelineConfigRequest_Action::UNSPECIFIED),
            1 => ::std::option::Option::Some(SetForwardingPipelineConfigRequest_Action::VERIFY),
            2 => ::std::option::Option::Some(SetForwardingPipelineConfigRequest_Action::VERIFY_AND_SAVE),
            3 => ::std::option::Option::Some(SetForwardingPipelineConfigRequest_Action::VERIFY_AND_COMMIT),
            4 => ::std::option::Option::Some(SetForwardingPipelineConfigRequest_Action::COMMIT),
            5 => ::std::option::Option::Some(SetForwardingPipelineConfigRequest_Action::RECONCILE_AND_COMMIT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SetForwardingPipelineConfigRequest_Action] = &[
            SetForwardingPipelineConfigRequest_Action::UNSPECIFIED,
            SetForwardingPipelineConfigRequest_Action::VERIFY,
            SetForwardingPipelineConfigRequest_Action::VERIFY_AND_SAVE,
            SetForwardingPipelineConfigRequest_Action::VERIFY_AND_COMMIT,
            SetForwardingPipelineConfigRequest_Action::COMMIT,
            SetForwardingPipelineConfigRequest_Action::RECONCILE_AND_COMMIT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SetForwardingPipelineConfigRequest_Action>("SetForwardingPipelineConfigRequest.Action", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SetForwardingPipelineConfigRequest_Action {
}

impl ::std::default::Default for SetForwardingPipelineConfigRequest_Action {
    fn default() -> Self {
        SetForwardingPipelineConfigRequest_Action::UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for SetForwardingPipelineConfigRequest_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetForwardingPipelineConfigResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetForwardingPipelineConfigResponse {
    fn default() -> &'a SetForwardingPipelineConfigResponse {
        <SetForwardingPipelineConfigResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetForwardingPipelineConfigResponse {
    pub fn new() -> SetForwardingPipelineConfigResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetForwardingPipelineConfigResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetForwardingPipelineConfigResponse {
        SetForwardingPipelineConfigResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetForwardingPipelineConfigResponse>(
                "SetForwardingPipelineConfigResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetForwardingPipelineConfigResponse {
        static instance: ::protobuf::rt::LazyV2<SetForwardingPipelineConfigResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetForwardingPipelineConfigResponse::new)
    }
}

impl ::protobuf::Clear for SetForwardingPipelineConfigResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetForwardingPipelineConfigResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetForwardingPipelineConfigResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ForwardingPipelineConfig {
    // message fields
    pub p4info: ::protobuf::SingularPtrField<super::p4info::P4Info>,
    pub p4_device_config: ::std::vec::Vec<u8>,
    pub cookie: ::protobuf::SingularPtrField<ForwardingPipelineConfig_Cookie>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ForwardingPipelineConfig {
    fn default() -> &'a ForwardingPipelineConfig {
        <ForwardingPipelineConfig as ::protobuf::Message>::default_instance()
    }
}

impl ForwardingPipelineConfig {
    pub fn new() -> ForwardingPipelineConfig {
        ::std::default::Default::default()
    }

    // .p4.config.v1.P4Info p4info = 1;


    pub fn get_p4info(&self) -> &super::p4info::P4Info {
        self.p4info.as_ref().unwrap_or_else(|| <super::p4info::P4Info as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p4info(&mut self) {
        self.p4info.clear();
    }

    pub fn has_p4info(&self) -> bool {
        self.p4info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p4info(&mut self, v: super::p4info::P4Info) {
        self.p4info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p4info(&mut self) -> &mut super::p4info::P4Info {
        if self.p4info.is_none() {
            self.p4info.set_default();
        }
        self.p4info.as_mut().unwrap()
    }

    // Take field
    pub fn take_p4info(&mut self) -> super::p4info::P4Info {
        self.p4info.take().unwrap_or_else(|| super::p4info::P4Info::new())
    }

    // bytes p4_device_config = 2;


    pub fn get_p4_device_config(&self) -> &[u8] {
        &self.p4_device_config
    }
    pub fn clear_p4_device_config(&mut self) {
        self.p4_device_config.clear();
    }

    // Param is passed by value, moved
    pub fn set_p4_device_config(&mut self, v: ::std::vec::Vec<u8>) {
        self.p4_device_config = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p4_device_config(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.p4_device_config
    }

    // Take field
    pub fn take_p4_device_config(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.p4_device_config, ::std::vec::Vec::new())
    }

    // .p4.v1.ForwardingPipelineConfig.Cookie cookie = 3;


    pub fn get_cookie(&self) -> &ForwardingPipelineConfig_Cookie {
        self.cookie.as_ref().unwrap_or_else(|| <ForwardingPipelineConfig_Cookie as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cookie(&mut self) {
        self.cookie.clear();
    }

    pub fn has_cookie(&self) -> bool {
        self.cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: ForwardingPipelineConfig_Cookie) {
        self.cookie = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cookie(&mut self) -> &mut ForwardingPipelineConfig_Cookie {
        if self.cookie.is_none() {
            self.cookie.set_default();
        }
        self.cookie.as_mut().unwrap()
    }

    // Take field
    pub fn take_cookie(&mut self) -> ForwardingPipelineConfig_Cookie {
        self.cookie.take().unwrap_or_else(|| ForwardingPipelineConfig_Cookie::new())
    }
}

impl ::protobuf::Message for ForwardingPipelineConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.p4info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cookie {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p4info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.p4_device_config)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p4info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.p4_device_config.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.p4_device_config);
        }
        if let Some(ref v) = self.cookie.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p4info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.p4_device_config.is_empty() {
            os.write_bytes(2, &self.p4_device_config)?;
        }
        if let Some(ref v) = self.cookie.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForwardingPipelineConfig {
        ForwardingPipelineConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4info::P4Info>>(
                "p4info",
                |m: &ForwardingPipelineConfig| { &m.p4info },
                |m: &mut ForwardingPipelineConfig| { &mut m.p4info },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "p4_device_config",
                |m: &ForwardingPipelineConfig| { &m.p4_device_config },
                |m: &mut ForwardingPipelineConfig| { &mut m.p4_device_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ForwardingPipelineConfig_Cookie>>(
                "cookie",
                |m: &ForwardingPipelineConfig| { &m.cookie },
                |m: &mut ForwardingPipelineConfig| { &mut m.cookie },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ForwardingPipelineConfig>(
                "ForwardingPipelineConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ForwardingPipelineConfig {
        static instance: ::protobuf::rt::LazyV2<ForwardingPipelineConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ForwardingPipelineConfig::new)
    }
}

impl ::protobuf::Clear for ForwardingPipelineConfig {
    fn clear(&mut self) {
        self.p4info.clear();
        self.p4_device_config.clear();
        self.cookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForwardingPipelineConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForwardingPipelineConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ForwardingPipelineConfig_Cookie {
    // message fields
    pub cookie: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ForwardingPipelineConfig_Cookie {
    fn default() -> &'a ForwardingPipelineConfig_Cookie {
        <ForwardingPipelineConfig_Cookie as ::protobuf::Message>::default_instance()
    }
}

impl ForwardingPipelineConfig_Cookie {
    pub fn new() -> ForwardingPipelineConfig_Cookie {
        ::std::default::Default::default()
    }

    // uint64 cookie = 1;


    pub fn get_cookie(&self) -> u64 {
        self.cookie
    }
    pub fn clear_cookie(&mut self) {
        self.cookie = 0;
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: u64) {
        self.cookie = v;
    }
}

impl ::protobuf::Message for ForwardingPipelineConfig_Cookie {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cookie = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cookie != 0 {
            my_size += ::protobuf::rt::value_size(1, self.cookie, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cookie != 0 {
            os.write_uint64(1, self.cookie)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForwardingPipelineConfig_Cookie {
        ForwardingPipelineConfig_Cookie::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "cookie",
                |m: &ForwardingPipelineConfig_Cookie| { &m.cookie },
                |m: &mut ForwardingPipelineConfig_Cookie| { &mut m.cookie },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ForwardingPipelineConfig_Cookie>(
                "ForwardingPipelineConfig.Cookie",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ForwardingPipelineConfig_Cookie {
        static instance: ::protobuf::rt::LazyV2<ForwardingPipelineConfig_Cookie> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ForwardingPipelineConfig_Cookie::new)
    }
}

impl ::protobuf::Clear for ForwardingPipelineConfig_Cookie {
    fn clear(&mut self) {
        self.cookie = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForwardingPipelineConfig_Cookie {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForwardingPipelineConfig_Cookie {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetForwardingPipelineConfigRequest {
    // message fields
    pub device_id: u64,
    pub response_type: GetForwardingPipelineConfigRequest_ResponseType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetForwardingPipelineConfigRequest {
    fn default() -> &'a GetForwardingPipelineConfigRequest {
        <GetForwardingPipelineConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetForwardingPipelineConfigRequest {
    pub fn new() -> GetForwardingPipelineConfigRequest {
        ::std::default::Default::default()
    }

    // uint64 device_id = 1;


    pub fn get_device_id(&self) -> u64 {
        self.device_id
    }
    pub fn clear_device_id(&mut self) {
        self.device_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: u64) {
        self.device_id = v;
    }

    // .p4.v1.GetForwardingPipelineConfigRequest.ResponseType response_type = 2;


    pub fn get_response_type(&self) -> GetForwardingPipelineConfigRequest_ResponseType {
        self.response_type
    }
    pub fn clear_response_type(&mut self) {
        self.response_type = GetForwardingPipelineConfigRequest_ResponseType::ALL;
    }

    // Param is passed by value, moved
    pub fn set_response_type(&mut self, v: GetForwardingPipelineConfigRequest_ResponseType) {
        self.response_type = v;
    }
}

impl ::protobuf::Message for GetForwardingPipelineConfigRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.device_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.response_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.device_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.device_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.response_type != GetForwardingPipelineConfigRequest_ResponseType::ALL {
            my_size += ::protobuf::rt::enum_size(2, self.response_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.device_id != 0 {
            os.write_uint64(1, self.device_id)?;
        }
        if self.response_type != GetForwardingPipelineConfigRequest_ResponseType::ALL {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.response_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetForwardingPipelineConfigRequest {
        GetForwardingPipelineConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "device_id",
                |m: &GetForwardingPipelineConfigRequest| { &m.device_id },
                |m: &mut GetForwardingPipelineConfigRequest| { &mut m.device_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GetForwardingPipelineConfigRequest_ResponseType>>(
                "response_type",
                |m: &GetForwardingPipelineConfigRequest| { &m.response_type },
                |m: &mut GetForwardingPipelineConfigRequest| { &mut m.response_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetForwardingPipelineConfigRequest>(
                "GetForwardingPipelineConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetForwardingPipelineConfigRequest {
        static instance: ::protobuf::rt::LazyV2<GetForwardingPipelineConfigRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetForwardingPipelineConfigRequest::new)
    }
}

impl ::protobuf::Clear for GetForwardingPipelineConfigRequest {
    fn clear(&mut self) {
        self.device_id = 0;
        self.response_type = GetForwardingPipelineConfigRequest_ResponseType::ALL;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetForwardingPipelineConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetForwardingPipelineConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GetForwardingPipelineConfigRequest_ResponseType {
    ALL = 0,
    COOKIE_ONLY = 1,
    P4INFO_AND_COOKIE = 2,
    DEVICE_CONFIG_AND_COOKIE = 3,
}

impl ::protobuf::ProtobufEnum for GetForwardingPipelineConfigRequest_ResponseType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GetForwardingPipelineConfigRequest_ResponseType> {
        match value {
            0 => ::std::option::Option::Some(GetForwardingPipelineConfigRequest_ResponseType::ALL),
            1 => ::std::option::Option::Some(GetForwardingPipelineConfigRequest_ResponseType::COOKIE_ONLY),
            2 => ::std::option::Option::Some(GetForwardingPipelineConfigRequest_ResponseType::P4INFO_AND_COOKIE),
            3 => ::std::option::Option::Some(GetForwardingPipelineConfigRequest_ResponseType::DEVICE_CONFIG_AND_COOKIE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GetForwardingPipelineConfigRequest_ResponseType] = &[
            GetForwardingPipelineConfigRequest_ResponseType::ALL,
            GetForwardingPipelineConfigRequest_ResponseType::COOKIE_ONLY,
            GetForwardingPipelineConfigRequest_ResponseType::P4INFO_AND_COOKIE,
            GetForwardingPipelineConfigRequest_ResponseType::DEVICE_CONFIG_AND_COOKIE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GetForwardingPipelineConfigRequest_ResponseType>("GetForwardingPipelineConfigRequest.ResponseType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GetForwardingPipelineConfigRequest_ResponseType {
}

impl ::std::default::Default for GetForwardingPipelineConfigRequest_ResponseType {
    fn default() -> Self {
        GetForwardingPipelineConfigRequest_ResponseType::ALL
    }
}

impl ::protobuf::reflect::ProtobufValue for GetForwardingPipelineConfigRequest_ResponseType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetForwardingPipelineConfigResponse {
    // message fields
    pub config: ::protobuf::SingularPtrField<ForwardingPipelineConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetForwardingPipelineConfigResponse {
    fn default() -> &'a GetForwardingPipelineConfigResponse {
        <GetForwardingPipelineConfigResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetForwardingPipelineConfigResponse {
    pub fn new() -> GetForwardingPipelineConfigResponse {
        ::std::default::Default::default()
    }

    // .p4.v1.ForwardingPipelineConfig config = 1;


    pub fn get_config(&self) -> &ForwardingPipelineConfig {
        self.config.as_ref().unwrap_or_else(|| <ForwardingPipelineConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ForwardingPipelineConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut ForwardingPipelineConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> ForwardingPipelineConfig {
        self.config.take().unwrap_or_else(|| ForwardingPipelineConfig::new())
    }
}

impl ::protobuf::Message for GetForwardingPipelineConfigResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetForwardingPipelineConfigResponse {
        GetForwardingPipelineConfigResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ForwardingPipelineConfig>>(
                "config",
                |m: &GetForwardingPipelineConfigResponse| { &m.config },
                |m: &mut GetForwardingPipelineConfigResponse| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetForwardingPipelineConfigResponse>(
                "GetForwardingPipelineConfigResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetForwardingPipelineConfigResponse {
        static instance: ::protobuf::rt::LazyV2<GetForwardingPipelineConfigResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetForwardingPipelineConfigResponse::new)
    }
}

impl ::protobuf::Clear for GetForwardingPipelineConfigResponse {
    fn clear(&mut self) {
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetForwardingPipelineConfigResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetForwardingPipelineConfigResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Error {
    // message fields
    pub canonical_code: i32,
    pub message: ::std::string::String,
    pub space: ::std::string::String,
    pub code: i32,
    pub details: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Error {
    fn default() -> &'a Error {
        <Error as ::protobuf::Message>::default_instance()
    }
}

impl Error {
    pub fn new() -> Error {
        ::std::default::Default::default()
    }

    // int32 canonical_code = 1;


    pub fn get_canonical_code(&self) -> i32 {
        self.canonical_code
    }
    pub fn clear_canonical_code(&mut self) {
        self.canonical_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_canonical_code(&mut self, v: i32) {
        self.canonical_code = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // string space = 3;


    pub fn get_space(&self) -> &str {
        &self.space
    }
    pub fn clear_space(&mut self) {
        self.space.clear();
    }

    // Param is passed by value, moved
    pub fn set_space(&mut self, v: ::std::string::String) {
        self.space = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_space(&mut self) -> &mut ::std::string::String {
        &mut self.space
    }

    // Take field
    pub fn take_space(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.space, ::std::string::String::new())
    }

    // int32 code = 4;


    pub fn get_code(&self) -> i32 {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = 0;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: i32) {
        self.code = v;
    }

    // .google.protobuf.Any details = 5;


    pub fn get_details(&self) -> &::protobuf::well_known_types::Any {
        self.details.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::protobuf::well_known_types::Any) {
        self.details = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.details.is_none() {
            self.details.set_default();
        }
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> ::protobuf::well_known_types::Any {
        self.details.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for Error {
    fn is_initialized(&self) -> bool {
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.canonical_code = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.space)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.code = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.canonical_code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.canonical_code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if !self.space.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.space);
        }
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(4, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.canonical_code != 0 {
            os.write_int32(1, self.canonical_code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if !self.space.is_empty() {
            os.write_string(3, &self.space)?;
        }
        if self.code != 0 {
            os.write_int32(4, self.code)?;
        }
        if let Some(ref v) = self.details.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Error {
        Error::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "canonical_code",
                |m: &Error| { &m.canonical_code },
                |m: &mut Error| { &mut m.canonical_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &Error| { &m.message },
                |m: &mut Error| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "space",
                |m: &Error| { &m.space },
                |m: &mut Error| { &mut m.space },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "code",
                |m: &Error| { &m.code },
                |m: &mut Error| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "details",
                |m: &Error| { &m.details },
                |m: &mut Error| { &mut m.details },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Error>(
                "Error",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Error {
        static instance: ::protobuf::rt::LazyV2<Error> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Error::new)
    }
}

impl ::protobuf::Clear for Error {
    fn clear(&mut self) {
        self.canonical_code = 0;
        self.message.clear();
        self.space.clear();
        self.code = 0;
        self.details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Error {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Error {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CapabilitiesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CapabilitiesRequest {
    fn default() -> &'a CapabilitiesRequest {
        <CapabilitiesRequest as ::protobuf::Message>::default_instance()
    }
}

impl CapabilitiesRequest {
    pub fn new() -> CapabilitiesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CapabilitiesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CapabilitiesRequest {
        CapabilitiesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CapabilitiesRequest>(
                "CapabilitiesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CapabilitiesRequest {
        static instance: ::protobuf::rt::LazyV2<CapabilitiesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CapabilitiesRequest::new)
    }
}

impl ::protobuf::Clear for CapabilitiesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CapabilitiesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CapabilitiesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CapabilitiesResponse {
    // message fields
    pub p4runtime_api_version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CapabilitiesResponse {
    fn default() -> &'a CapabilitiesResponse {
        <CapabilitiesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CapabilitiesResponse {
    pub fn new() -> CapabilitiesResponse {
        ::std::default::Default::default()
    }

    // string p4runtime_api_version = 1;


    pub fn get_p4runtime_api_version(&self) -> &str {
        &self.p4runtime_api_version
    }
    pub fn clear_p4runtime_api_version(&mut self) {
        self.p4runtime_api_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_p4runtime_api_version(&mut self, v: ::std::string::String) {
        self.p4runtime_api_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p4runtime_api_version(&mut self) -> &mut ::std::string::String {
        &mut self.p4runtime_api_version
    }

    // Take field
    pub fn take_p4runtime_api_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.p4runtime_api_version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CapabilitiesResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.p4runtime_api_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.p4runtime_api_version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.p4runtime_api_version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.p4runtime_api_version.is_empty() {
            os.write_string(1, &self.p4runtime_api_version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CapabilitiesResponse {
        CapabilitiesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "p4runtime_api_version",
                |m: &CapabilitiesResponse| { &m.p4runtime_api_version },
                |m: &mut CapabilitiesResponse| { &mut m.p4runtime_api_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CapabilitiesResponse>(
                "CapabilitiesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CapabilitiesResponse {
        static instance: ::protobuf::rt::LazyV2<CapabilitiesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CapabilitiesResponse::new)
    }
}

impl ::protobuf::Clear for CapabilitiesResponse {
    fn clear(&mut self) {
        self.p4runtime_api_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CapabilitiesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CapabilitiesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SdnPort {
    SDN_PORT_UNKNOWN = 0,
    SDN_PORT_MIN = 1,
    SDN_PORT_MAX = -257,
    SDN_PORT_RECIRCULATE = -6,
    SDN_PORT_CPU = -3,
}

impl ::protobuf::ProtobufEnum for SdnPort {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SdnPort> {
        match value {
            0 => ::std::option::Option::Some(SdnPort::SDN_PORT_UNKNOWN),
            1 => ::std::option::Option::Some(SdnPort::SDN_PORT_MIN),
            -257 => ::std::option::Option::Some(SdnPort::SDN_PORT_MAX),
            -6 => ::std::option::Option::Some(SdnPort::SDN_PORT_RECIRCULATE),
            -3 => ::std::option::Option::Some(SdnPort::SDN_PORT_CPU),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SdnPort] = &[
            SdnPort::SDN_PORT_UNKNOWN,
            SdnPort::SDN_PORT_MIN,
            SdnPort::SDN_PORT_MAX,
            SdnPort::SDN_PORT_RECIRCULATE,
            SdnPort::SDN_PORT_CPU,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SdnPort>("SdnPort", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SdnPort {
}

impl ::std::default::Default for SdnPort {
    fn default() -> Self {
        SdnPort::SDN_PORT_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for SdnPort {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15p4/v1/p4runtime.proto\x12\x05p4.v1\x1a\x19google/protobuf/any.prot\
    o\x1a\x17google/rpc/status.proto\x1a\x19p4/config/v1/p4info.proto\x1a\
    \x12p4/v1/p4data.proto\"\xac\x02\n\x0cWriteRequest\x12\x1b\n\tdevice_id\
    \x18\x01\x20\x01(\x04R\x08deviceId\x12\x17\n\x07role_id\x18\x02\x20\x01(\
    \x04R\x06roleId\x12/\n\x0belection_id\x18\x03\x20\x01(\x0b2\x0e.p4.v1.Ui\
    nt128R\nelectionId\x12'\n\x07updates\x18\x04\x20\x03(\x0b2\r.p4.v1.Updat\
    eR\x07updates\x12;\n\tatomicity\x18\x05\x20\x01(\x0e2\x1d.p4.v1.WriteReq\
    uest.AtomicityR\tatomicity\"O\n\tAtomicity\x12\x15\n\x11CONTINUE_ON_ERRO\
    R\x10\0\x12\x15\n\x11ROLLBACK_ON_ERROR\x10\x01\x12\x14\n\x10DATAPLANE_AT\
    OMIC\x10\x02\"\x0f\n\rWriteResponse\"U\n\x0bReadRequest\x12\x1b\n\tdevic\
    e_id\x18\x01\x20\x01(\x04R\x08deviceId\x12)\n\x08entities\x18\x02\x20\
    \x03(\x0b2\r.p4.v1.EntityR\x08entities\"9\n\x0cReadResponse\x12)\n\x08en\
    tities\x18\x01\x20\x03(\x0b2\r.p4.v1.EntityR\x08entities\"\x94\x01\n\x06\
    Update\x12&\n\x04type\x18\x01\x20\x01(\x0e2\x12.p4.v1.Update.TypeR\x04ty\
    pe\x12%\n\x06entity\x18\x02\x20\x01(\x0b2\r.p4.v1.EntityR\x06entity\";\n\
    \x04Type\x12\x0f\n\x0bUNSPECIFIED\x10\0\x12\n\n\x06INSERT\x10\x01\x12\n\
    \n\x06MODIFY\x10\x02\x12\n\n\x06DELETE\x10\x03\"\xd2\x06\n\x06Entity\x12\
    7\n\x0cextern_entry\x18\x01\x20\x01(\x0b2\x12.p4.v1.ExternEntryH\0R\x0be\
    xternEntry\x124\n\x0btable_entry\x18\x02\x20\x01(\x0b2\x11.p4.v1.TableEn\
    tryH\0R\ntableEntry\x12P\n\x15action_profile_member\x18\x03\x20\x01(\x0b\
    2\x1a.p4.v1.ActionProfileMemberH\0R\x13actionProfileMember\x12M\n\x14act\
    ion_profile_group\x18\x04\x20\x01(\x0b2\x19.p4.v1.ActionProfileGroupH\0R\
    \x12actionProfileGroup\x124\n\x0bmeter_entry\x18\x05\x20\x01(\x0b2\x11.p\
    4.v1.MeterEntryH\0R\nmeterEntry\x12G\n\x12direct_meter_entry\x18\x06\x20\
    \x01(\x0b2\x17.p4.v1.DirectMeterEntryH\0R\x10directMeterEntry\x12:\n\rco\
    unter_entry\x18\x07\x20\x01(\x0b2\x13.p4.v1.CounterEntryH\0R\x0ccounterE\
    ntry\x12M\n\x14direct_counter_entry\x18\x08\x20\x01(\x0b2\x19.p4.v1.Dire\
    ctCounterEntryH\0R\x12directCounterEntry\x12l\n\x1fpacket_replication_en\
    gine_entry\x18\t\x20\x01(\x0b2#.p4.v1.PacketReplicationEngineEntryH\0R\
    \x1cpacketReplicationEngineEntry\x12>\n\x0fvalue_set_entry\x18\n\x20\x01\
    (\x0b2\x14.p4.v1.ValueSetEntryH\0R\rvalueSetEntry\x12=\n\x0eregister_ent\
    ry\x18\x0b\x20\x01(\x0b2\x14.p4.v1.RegisterEntryH\0R\rregisterEntry\x127\
    \n\x0cdigest_entry\x18\x0c\x20\x01(\x0b2\x12.p4.v1.DigestEntryH\0R\x0bdi\
    gestEntryB\x08\n\x06entity\"|\n\x0bExternEntry\x12$\n\x0eextern_type_id\
    \x18\x01\x20\x01(\rR\x0cexternTypeId\x12\x1b\n\textern_id\x18\x02\x20\
    \x01(\rR\x08externId\x12*\n\x05entry\x18\x03\x20\x01(\x0b2\x14.google.pr\
    otobuf.AnyR\x05entry\"\xa7\x04\n\nTableEntry\x12\x19\n\x08table_id\x18\
    \x01\x20\x01(\rR\x07tableId\x12'\n\x05match\x18\x02\x20\x03(\x0b2\x11.p4\
    .v1.FieldMatchR\x05match\x12*\n\x06action\x18\x03\x20\x01(\x0b2\x12.p4.v\
    1.TableActionR\x06action\x12\x1a\n\x08priority\x18\x04\x20\x01(\x05R\x08\
    priority\x123\n\x13controller_metadata\x18\x05\x20\x01(\x04R\x12controll\
    erMetadataB\x02\x18\x01\x125\n\x0cmeter_config\x18\x06\x20\x01(\x0b2\x12\
    .p4.v1.MeterConfigR\x0bmeterConfig\x125\n\x0ccounter_data\x18\x07\x20\
    \x01(\x0b2\x12.p4.v1.CounterDataR\x0bcounterData\x12*\n\x11is_default_ac\
    tion\x18\x08\x20\x01(\x08R\x0fisDefaultAction\x12&\n\x0fidle_timeout_ns\
    \x18\t\x20\x01(\x03R\ridleTimeoutNs\x12L\n\x13time_since_last_hit\x18\n\
    \x20\x01(\x0b2\x1d.p4.v1.TableEntry.IdleTimeoutR\x10timeSinceLastHit\x12\
    \x1a\n\x08metadata\x18\x0b\x20\x01(\x0cR\x08metadata\x1a,\n\x0bIdleTimeo\
    ut\x12\x1d\n\nelapsed_ns\x18\x01\x20\x01(\x03R\telapsedNs\"\xc8\x04\n\nF\
    ieldMatch\x12\x19\n\x08field_id\x18\x01\x20\x01(\rR\x07fieldId\x12/\n\
    \x05exact\x18\x02\x20\x01(\x0b2\x17.p4.v1.FieldMatch.ExactH\0R\x05exact\
    \x125\n\x07ternary\x18\x03\x20\x01(\x0b2\x19.p4.v1.FieldMatch.TernaryH\0\
    R\x07ternary\x12)\n\x03lpm\x18\x04\x20\x01(\x0b2\x15.p4.v1.FieldMatch.LP\
    MH\0R\x03lpm\x12/\n\x05range\x18\x06\x20\x01(\x0b2\x17.p4.v1.FieldMatch.\
    RangeH\0R\x05range\x128\n\x08optional\x18\x07\x20\x01(\x0b2\x1a.p4.v1.Fi\
    eldMatch.OptionalH\0R\x08optional\x12,\n\x05other\x18d\x20\x01(\x0b2\x14\
    .google.protobuf.AnyH\0R\x05other\x1a\x1d\n\x05Exact\x12\x14\n\x05value\
    \x18\x01\x20\x01(\x0cR\x05value\x1a3\n\x07Ternary\x12\x14\n\x05value\x18\
    \x01\x20\x01(\x0cR\x05value\x12\x12\n\x04mask\x18\x02\x20\x01(\x0cR\x04m\
    ask\x1a:\n\x03LPM\x12\x14\n\x05value\x18\x01\x20\x01(\x0cR\x05value\x12\
    \x1d\n\nprefix_len\x18\x02\x20\x01(\x05R\tprefixLen\x1a-\n\x05Range\x12\
    \x10\n\x03low\x18\x01\x20\x01(\x0cR\x03low\x12\x12\n\x04high\x18\x02\x20\
    \x01(\x0cR\x04high\x1a\x20\n\x08Optional\x12\x14\n\x05value\x18\x01\x20\
    \x01(\x0cR\x05valueB\x12\n\x10field_match_type\"\x8e\x02\n\x0bTableActio\
    n\x12'\n\x06action\x18\x01\x20\x01(\x0b2\r.p4.v1.ActionH\0R\x06action\
    \x129\n\x18action_profile_member_id\x18\x02\x20\x01(\rH\0R\x15actionProf\
    ileMemberId\x127\n\x17action_profile_group_id\x18\x03\x20\x01(\rH\0R\x14\
    actionProfileGroupId\x12Z\n\x19action_profile_action_set\x18\x04\x20\x01\
    (\x0b2\x1d.p4.v1.ActionProfileActionSetH\0R\x16actionProfileActionSetB\
    \x06\n\x04type\"\x8c\x01\n\x06Action\x12\x1b\n\taction_id\x18\x01\x20\
    \x01(\rR\x08actionId\x12+\n\x06params\x18\x04\x20\x03(\x0b2\x13.p4.v1.Ac\
    tion.ParamR\x06params\x1a8\n\x05Param\x12\x19\n\x08param_id\x18\x02\x20\
    \x01(\rR\x07paramId\x12\x14\n\x05value\x18\x03\x20\x01(\x0cR\x05value\"j\
    \n\x16ActionProfileActionSet\x12P\n\x16action_profile_actions\x18\x01\
    \x20\x03(\x0b2\x1a.p4.v1.ActionProfileActionR\x14actionProfileActions\"\
    \x9f\x01\n\x13ActionProfileAction\x12%\n\x06action\x18\x01\x20\x01(\x0b2\
    \r.p4.v1.ActionR\x06action\x12\x16\n\x06weight\x18\x02\x20\x01(\x05R\x06\
    weight\x12\x1a\n\x05watch\x18\x03\x20\x01(\x05H\0R\x05watchB\x02\x18\x01\
    \x12\x1f\n\nwatch_port\x18\x04\x20\x01(\x0cH\0R\twatchPortB\x0c\n\nwatch\
    _kind\"\x85\x01\n\x13ActionProfileMember\x12*\n\x11action_profile_id\x18\
    \x01\x20\x01(\rR\x0factionProfileId\x12\x1b\n\tmember_id\x18\x02\x20\x01\
    (\rR\x08memberId\x12%\n\x06action\x18\x03\x20\x01(\x0b2\r.p4.v1.ActionR\
    \x06action\"\xbd\x02\n\x12ActionProfileGroup\x12*\n\x11action_profile_id\
    \x18\x01\x20\x01(\rR\x0factionProfileId\x12\x19\n\x08group_id\x18\x02\
    \x20\x01(\rR\x07groupId\x12:\n\x07members\x18\x03\x20\x03(\x0b2\x20.p4.v\
    1.ActionProfileGroup.MemberR\x07members\x12\x19\n\x08max_size\x18\x04\
    \x20\x01(\x05R\x07maxSize\x1a\x88\x01\n\x06Member\x12\x1b\n\tmember_id\
    \x18\x01\x20\x01(\rR\x08memberId\x12\x16\n\x06weight\x18\x02\x20\x01(\
    \x05R\x06weight\x12\x1a\n\x05watch\x18\x03\x20\x01(\x05H\0R\x05watchB\
    \x02\x18\x01\x12\x1f\n\nwatch_port\x18\x04\x20\x01(\x0cH\0R\twatchPortB\
    \x0c\n\nwatch_kind\"\x1d\n\x05Index\x12\x14\n\x05index\x18\x01\x20\x01(\
    \x03R\x05index\"w\n\nMeterEntry\x12\x19\n\x08meter_id\x18\x01\x20\x01(\r\
    R\x07meterId\x12\"\n\x05index\x18\x02\x20\x01(\x0b2\x0c.p4.v1.IndexR\x05\
    index\x12*\n\x06config\x18\x03\x20\x01(\x0b2\x12.p4.v1.MeterConfigR\x06c\
    onfig\"r\n\x10DirectMeterEntry\x122\n\x0btable_entry\x18\x01\x20\x01(\
    \x0b2\x11.p4.v1.TableEntryR\ntableEntry\x12*\n\x06config\x18\x02\x20\x01\
    (\x0b2\x12.p4.v1.MeterConfigR\x06config\"a\n\x0bMeterConfig\x12\x10\n\
    \x03cir\x18\x01\x20\x01(\x03R\x03cir\x12\x16\n\x06cburst\x18\x02\x20\x01\
    (\x03R\x06cburst\x12\x10\n\x03pir\x18\x03\x20\x01(\x03R\x03pir\x12\x16\n\
    \x06pburst\x18\x04\x20\x01(\x03R\x06pburst\"y\n\x0cCounterEntry\x12\x1d\
    \n\ncounter_id\x18\x01\x20\x01(\rR\tcounterId\x12\"\n\x05index\x18\x02\
    \x20\x01(\x0b2\x0c.p4.v1.IndexR\x05index\x12&\n\x04data\x18\x03\x20\x01(\
    \x0b2\x12.p4.v1.CounterDataR\x04data\"p\n\x12DirectCounterEntry\x122\n\
    \x0btable_entry\x18\x01\x20\x01(\x0b2\x11.p4.v1.TableEntryR\ntableEntry\
    \x12&\n\x04data\x18\x02\x20\x01(\x0b2\x12.p4.v1.CounterDataR\x04data\"O\
    \n\x0bCounterData\x12\x1d\n\nbyte_count\x18\x01\x20\x01(\x03R\tbyteCount\
    \x12!\n\x0cpacket_count\x18\x02\x20\x01(\x03R\x0bpacketCount\"\xc4\x01\n\
    \x1cPacketReplicationEngineEntry\x12P\n\x15multicast_group_entry\x18\x01\
    \x20\x01(\x0b2\x1a.p4.v1.MulticastGroupEntryH\0R\x13multicastGroupEntry\
    \x12J\n\x13clone_session_entry\x18\x02\x20\x01(\x0b2\x18.p4.v1.CloneSess\
    ionEntryH\0R\x11cloneSessionEntryB\x06\n\x04type\"F\n\x07Replica\x12\x1f\
    \n\x0begress_port\x18\x01\x20\x01(\rR\negressPort\x12\x1a\n\x08instance\
    \x18\x02\x20\x01(\rR\x08instance\"o\n\x13MulticastGroupEntry\x12,\n\x12m\
    ulticast_group_id\x18\x01\x20\x01(\rR\x10multicastGroupId\x12*\n\x08repl\
    icas\x18\x02\x20\x03(\x0b2\x0e.p4.v1.ReplicaR\x08replicas\"\xb8\x01\n\
    \x11CloneSessionEntry\x12\x1d\n\nsession_id\x18\x01\x20\x01(\rR\tsession\
    Id\x12*\n\x08replicas\x18\x02\x20\x03(\x0b2\x0e.p4.v1.ReplicaR\x08replic\
    as\x12(\n\x10class_of_service\x18\x03\x20\x01(\rR\x0eclassOfService\x12.\
    \n\x13packet_length_bytes\x18\x04\x20\x01(\x05R\x11packetLengthBytes\"9\
    \n\x0eValueSetMember\x12'\n\x05match\x18\x01\x20\x03(\x0b2\x11.p4.v1.Fie\
    ldMatchR\x05match\"b\n\rValueSetEntry\x12\x20\n\x0cvalue_set_id\x18\x01\
    \x20\x01(\rR\nvalueSetId\x12/\n\x07members\x18\x02\x20\x03(\x0b2\x15.p4.\
    v1.ValueSetMemberR\x07members\"w\n\rRegisterEntry\x12\x1f\n\x0bregister_\
    id\x18\x01\x20\x01(\rR\nregisterId\x12\"\n\x05index\x18\x02\x20\x01(\x0b\
    2\x0c.p4.v1.IndexR\x05index\x12!\n\x04data\x18\x03\x20\x01(\x0b2\r.p4.v1\
    .P4DataR\x04data\"\xd7\x01\n\x0bDigestEntry\x12\x1b\n\tdigest_id\x18\x01\
    \x20\x01(\rR\x08digestId\x121\n\x06config\x18\x02\x20\x01(\x0b2\x19.p4.v\
    1.DigestEntry.ConfigR\x06config\x1ax\n\x06Config\x12$\n\x0emax_timeout_n\
    s\x18\x01\x20\x01(\x03R\x0cmaxTimeoutNs\x12\"\n\rmax_list_size\x18\x02\
    \x20\x01(\x05R\x0bmaxListSize\x12$\n\x0eack_timeout_ns\x18\x03\x20\x01(\
    \x03R\x0cackTimeoutNs\"\xf5\x01\n\x14StreamMessageRequest\x12B\n\x0barbi\
    tration\x18\x01\x20\x01(\x0b2\x1e.p4.v1.MasterArbitrationUpdateH\0R\x0ba\
    rbitration\x12*\n\x06packet\x18\x02\x20\x01(\x0b2\x10.p4.v1.PacketOutH\0\
    R\x06packet\x125\n\ndigest_ack\x18\x03\x20\x01(\x0b2\x14.p4.v1.DigestLis\
    tAckH\0R\tdigestAck\x12,\n\x05other\x18\x04\x20\x01(\x0b2\x14.google.pro\
    tobuf.AnyH\0R\x05otherB\x08\n\x06update\"X\n\tPacketOut\x12\x18\n\x07pay\
    load\x18\x01\x20\x01(\x0cR\x07payload\x121\n\x08metadata\x18\x02\x20\x03\
    (\x0b2\x15.p4.v1.PacketMetadataR\x08metadata\"E\n\rDigestListAck\x12\x1b\
    \n\tdigest_id\x18\x01\x20\x01(\rR\x08digestId\x12\x17\n\x07list_id\x18\
    \x02\x20\x01(\x04R\x06listId\"\xf5\x02\n\x15StreamMessageResponse\x12B\n\
    \x0barbitration\x18\x01\x20\x01(\x0b2\x1e.p4.v1.MasterArbitrationUpdateH\
    \0R\x0barbitration\x12)\n\x06packet\x18\x02\x20\x01(\x0b2\x0f.p4.v1.Pack\
    etInH\0R\x06packet\x12+\n\x06digest\x18\x03\x20\x01(\x0b2\x11.p4.v1.Dige\
    stListH\0R\x06digest\x12\\\n\x19idle_timeout_notification\x18\x04\x20\
    \x01(\x0b2\x1e.p4.v1.IdleTimeoutNotificationH\0R\x17idleTimeoutNotificat\
    ion\x12,\n\x05other\x18\x05\x20\x01(\x0b2\x14.google.protobuf.AnyH\0R\
    \x05other\x12*\n\x05error\x18\x06\x20\x01(\x0b2\x12.p4.v1.StreamErrorH\0\
    R\x05errorB\x08\n\x06update\"W\n\x08PacketIn\x12\x18\n\x07payload\x18\
    \x01\x20\x01(\x0cR\x07payload\x121\n\x08metadata\x18\x02\x20\x03(\x0b2\
    \x15.p4.v1.PacketMetadataR\x08metadata\"\x83\x01\n\nDigestList\x12\x1b\n\
    \tdigest_id\x18\x01\x20\x01(\rR\x08digestId\x12\x17\n\x07list_id\x18\x02\
    \x20\x01(\x04R\x06listId\x12!\n\x04data\x18\x03\x20\x03(\x0b2\r.p4.v1.P4\
    DataR\x04data\x12\x1c\n\ttimestamp\x18\x04\x20\x01(\x03R\ttimestamp\"G\n\
    \x0ePacketMetadata\x12\x1f\n\x0bmetadata_id\x18\x01\x20\x01(\rR\nmetadat\
    aId\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value\"\xb4\x01\n\x17Mas\
    terArbitrationUpdate\x12\x1b\n\tdevice_id\x18\x01\x20\x01(\x04R\x08devic\
    eId\x12\x1f\n\x04role\x18\x02\x20\x01(\x0b2\x0b.p4.v1.RoleR\x04role\x12/\
    \n\x0belection_id\x18\x03\x20\x01(\x0b2\x0e.p4.v1.Uint128R\nelectionId\
    \x12*\n\x06status\x18\x04\x20\x01(\x0b2\x12.google.rpc.StatusR\x06status\
    \"D\n\x04Role\x12\x0e\n\x02id\x18\x01\x20\x01(\x04R\x02id\x12,\n\x06conf\
    ig\x18\x02\x20\x01(\x0b2\x14.google.protobuf.AnyR\x06config\"k\n\x17Idle\
    TimeoutNotification\x122\n\x0btable_entry\x18\x01\x20\x03(\x0b2\x11.p4.v\
    1.TableEntryR\ntableEntry\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\x03R\tti\
    mestamp\"\xb1\x02\n\x0bStreamError\x12%\n\x0ecanonical_code\x18\x01\x20\
    \x01(\x05R\rcanonicalCode\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07me\
    ssage\x12\x14\n\x05space\x18\x03\x20\x01(\tR\x05space\x12\x12\n\x04code\
    \x18\x04\x20\x01(\x05R\x04code\x126\n\npacket_out\x18\x05\x20\x01(\x0b2\
    \x15.p4.v1.PacketOutErrorH\0R\tpacketOut\x12C\n\x0fdigest_list_ack\x18\
    \x06\x20\x01(\x0b2\x19.p4.v1.DigestListAckErrorH\0R\rdigestListAck\x12/\
    \n\x05other\x18\x07\x20\x01(\x0b2\x17.p4.v1.StreamOtherErrorH\0R\x05othe\
    rB\t\n\x07details\"A\n\x0ePacketOutError\x12/\n\npacket_out\x18\x01\x20\
    \x01(\x0b2\x10.p4.v1.PacketOutR\tpacketOut\"R\n\x12DigestListAckError\
    \x12<\n\x0fdigest_list_ack\x18\x01\x20\x01(\x0b2\x14.p4.v1.DigestListAck\
    R\rdigestListAck\">\n\x10StreamOtherError\x12*\n\x05other\x18\x01\x20\
    \x01(\x0b2\x14.google.protobuf.AnyR\x05other\"/\n\x07Uint128\x12\x12\n\
    \x04high\x18\x01\x20\x01(\x04R\x04high\x12\x10\n\x03low\x18\x02\x20\x01(\
    \x04R\x03low\"\x87\x03\n\"SetForwardingPipelineConfigRequest\x12\x1b\n\t\
    device_id\x18\x01\x20\x01(\x04R\x08deviceId\x12\x17\n\x07role_id\x18\x02\
    \x20\x01(\x04R\x06roleId\x12/\n\x0belection_id\x18\x03\x20\x01(\x0b2\x0e\
    .p4.v1.Uint128R\nelectionId\x12H\n\x06action\x18\x04\x20\x01(\x0e20.p4.v\
    1.SetForwardingPipelineConfigRequest.ActionR\x06action\x127\n\x06config\
    \x18\x05\x20\x01(\x0b2\x1f.p4.v1.ForwardingPipelineConfigR\x06config\"w\
    \n\x06Action\x12\x0f\n\x0bUNSPECIFIED\x10\0\x12\n\n\x06VERIFY\x10\x01\
    \x12\x13\n\x0fVERIFY_AND_SAVE\x10\x02\x12\x15\n\x11VERIFY_AND_COMMIT\x10\
    \x03\x12\n\n\x06COMMIT\x10\x04\x12\x18\n\x14RECONCILE_AND_COMMIT\x10\x05\
    \"%\n#SetForwardingPipelineConfigResponse\"\xd4\x01\n\x18ForwardingPipel\
    ineConfig\x12,\n\x06p4info\x18\x01\x20\x01(\x0b2\x14.p4.config.v1.P4Info\
    R\x06p4info\x12(\n\x10p4_device_config\x18\x02\x20\x01(\x0cR\x0ep4Device\
    Config\x12>\n\x06cookie\x18\x03\x20\x01(\x0b2&.p4.v1.ForwardingPipelineC\
    onfig.CookieR\x06cookie\x1a\x20\n\x06Cookie\x12\x16\n\x06cookie\x18\x01\
    \x20\x01(\x04R\x06cookie\"\xfd\x01\n\"GetForwardingPipelineConfigRequest\
    \x12\x1b\n\tdevice_id\x18\x01\x20\x01(\x04R\x08deviceId\x12[\n\rresponse\
    _type\x18\x02\x20\x01(\x0e26.p4.v1.GetForwardingPipelineConfigRequest.Re\
    sponseTypeR\x0cresponseType\"]\n\x0cResponseType\x12\x07\n\x03ALL\x10\0\
    \x12\x0f\n\x0bCOOKIE_ONLY\x10\x01\x12\x15\n\x11P4INFO_AND_COOKIE\x10\x02\
    \x12\x1c\n\x18DEVICE_CONFIG_AND_COOKIE\x10\x03\"^\n#GetForwardingPipelin\
    eConfigResponse\x127\n\x06config\x18\x01\x20\x01(\x0b2\x1f.p4.v1.Forward\
    ingPipelineConfigR\x06config\"\xa2\x01\n\x05Error\x12%\n\x0ecanonical_co\
    de\x18\x01\x20\x01(\x05R\rcanonicalCode\x12\x18\n\x07message\x18\x02\x20\
    \x01(\tR\x07message\x12\x14\n\x05space\x18\x03\x20\x01(\tR\x05space\x12\
    \x12\n\x04code\x18\x04\x20\x01(\x05R\x04code\x12.\n\x07details\x18\x05\
    \x20\x01(\x0b2\x14.google.protobuf.AnyR\x07details\"\x15\n\x13Capabiliti\
    esRequest\"J\n\x14CapabilitiesResponse\x122\n\x15p4runtime_api_version\
    \x18\x01\x20\x01(\tR\x13p4runtimeApiVersion*\x8a\x01\n\x07SdnPort\x12\
    \x14\n\x10SDN_PORT_UNKNOWN\x10\0\x12\x10\n\x0cSDN_PORT_MIN\x10\x01\x12\
    \x19\n\x0cSDN_PORT_MAX\x10\xff\xfd\xff\xff\xff\xff\xff\xff\xff\x01\x12!\
    \n\x14SDN_PORT_RECIRCULATE\x10\xfa\xff\xff\xff\xff\xff\xff\xff\xff\x01\
    \x12\x19\n\x0cSDN_PORT_CPU\x10\xfd\xff\xff\xff\xff\xff\xff\xff\xff\x012\
    \x83\x04\n\tP4Runtime\x124\n\x05Write\x12\x13.p4.v1.WriteRequest\x1a\x14\
    .p4.v1.WriteResponse\"\0\x123\n\x04Read\x12\x12.p4.v1.ReadRequest\x1a\
    \x13.p4.v1.ReadResponse\"\00\x01\x12v\n\x1bSetForwardingPipelineConfig\
    \x12).p4.v1.SetForwardingPipelineConfigRequest\x1a*.p4.v1.SetForwardingP\
    ipelineConfigResponse\"\0\x12v\n\x1bGetForwardingPipelineConfig\x12).p4.\
    v1.GetForwardingPipelineConfigRequest\x1a*.p4.v1.GetForwardingPipelineCo\
    nfigResponse\"\0\x12P\n\rStreamChannel\x12\x1b.p4.v1.StreamMessageReques\
    t\x1a\x1c.p4.v1.StreamMessageResponse\"\0(\x010\x01\x12I\n\x0cCapabiliti\
    es\x12\x1a.p4.v1.CapabilitiesRequest\x1a\x1b.p4.v1.CapabilitiesResponse\
    \"\0B&Z$github.com/p4lang/p4runtime/go/p4/v1b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
