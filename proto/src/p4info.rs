// This file is generated by rust-protobuf 2.22.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `p4/config/v1/p4info.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_1;

#[derive(PartialEq,Clone,Default)]
pub struct P4Info {
    // message fields
    pub pkg_info: ::protobuf::SingularPtrField<PkgInfo>,
    pub tables: ::protobuf::RepeatedField<Table>,
    pub actions: ::protobuf::RepeatedField<Action>,
    pub action_profiles: ::protobuf::RepeatedField<ActionProfile>,
    pub counters: ::protobuf::RepeatedField<Counter>,
    pub direct_counters: ::protobuf::RepeatedField<DirectCounter>,
    pub meters: ::protobuf::RepeatedField<Meter>,
    pub direct_meters: ::protobuf::RepeatedField<DirectMeter>,
    pub controller_packet_metadata: ::protobuf::RepeatedField<ControllerPacketMetadata>,
    pub value_sets: ::protobuf::RepeatedField<ValueSet>,
    pub registers: ::protobuf::RepeatedField<Register>,
    pub digests: ::protobuf::RepeatedField<Digest>,
    pub externs: ::protobuf::RepeatedField<Extern>,
    pub type_info: ::protobuf::SingularPtrField<super::p4types::P4TypeInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4Info {
    fn default() -> &'a P4Info {
        <P4Info as ::protobuf::Message>::default_instance()
    }
}

impl P4Info {
    pub fn new() -> P4Info {
        ::std::default::Default::default()
    }

    // .p4.config.v1.PkgInfo pkg_info = 1;


    pub fn get_pkg_info(&self) -> &PkgInfo {
        self.pkg_info.as_ref().unwrap_or_else(|| <PkgInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pkg_info(&mut self) {
        self.pkg_info.clear();
    }

    pub fn has_pkg_info(&self) -> bool {
        self.pkg_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pkg_info(&mut self, v: PkgInfo) {
        self.pkg_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pkg_info(&mut self) -> &mut PkgInfo {
        if self.pkg_info.is_none() {
            self.pkg_info.set_default();
        }
        self.pkg_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_pkg_info(&mut self) -> PkgInfo {
        self.pkg_info.take().unwrap_or_else(|| PkgInfo::new())
    }

    // repeated .p4.config.v1.Table tables = 2;


    pub fn get_tables(&self) -> &[Table] {
        &self.tables
    }
    pub fn clear_tables(&mut self) {
        self.tables.clear();
    }

    // Param is passed by value, moved
    pub fn set_tables(&mut self, v: ::protobuf::RepeatedField<Table>) {
        self.tables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tables(&mut self) -> &mut ::protobuf::RepeatedField<Table> {
        &mut self.tables
    }

    // Take field
    pub fn take_tables(&mut self) -> ::protobuf::RepeatedField<Table> {
        ::std::mem::replace(&mut self.tables, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.Action actions = 3;


    pub fn get_actions(&self) -> &[Action] {
        &self.actions
    }
    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: ::protobuf::RepeatedField<Action>) {
        self.actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actions(&mut self) -> &mut ::protobuf::RepeatedField<Action> {
        &mut self.actions
    }

    // Take field
    pub fn take_actions(&mut self) -> ::protobuf::RepeatedField<Action> {
        ::std::mem::replace(&mut self.actions, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.ActionProfile action_profiles = 4;


    pub fn get_action_profiles(&self) -> &[ActionProfile] {
        &self.action_profiles
    }
    pub fn clear_action_profiles(&mut self) {
        self.action_profiles.clear();
    }

    // Param is passed by value, moved
    pub fn set_action_profiles(&mut self, v: ::protobuf::RepeatedField<ActionProfile>) {
        self.action_profiles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_action_profiles(&mut self) -> &mut ::protobuf::RepeatedField<ActionProfile> {
        &mut self.action_profiles
    }

    // Take field
    pub fn take_action_profiles(&mut self) -> ::protobuf::RepeatedField<ActionProfile> {
        ::std::mem::replace(&mut self.action_profiles, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.Counter counters = 5;


    pub fn get_counters(&self) -> &[Counter] {
        &self.counters
    }
    pub fn clear_counters(&mut self) {
        self.counters.clear();
    }

    // Param is passed by value, moved
    pub fn set_counters(&mut self, v: ::protobuf::RepeatedField<Counter>) {
        self.counters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_counters(&mut self) -> &mut ::protobuf::RepeatedField<Counter> {
        &mut self.counters
    }

    // Take field
    pub fn take_counters(&mut self) -> ::protobuf::RepeatedField<Counter> {
        ::std::mem::replace(&mut self.counters, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.DirectCounter direct_counters = 6;


    pub fn get_direct_counters(&self) -> &[DirectCounter] {
        &self.direct_counters
    }
    pub fn clear_direct_counters(&mut self) {
        self.direct_counters.clear();
    }

    // Param is passed by value, moved
    pub fn set_direct_counters(&mut self, v: ::protobuf::RepeatedField<DirectCounter>) {
        self.direct_counters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_direct_counters(&mut self) -> &mut ::protobuf::RepeatedField<DirectCounter> {
        &mut self.direct_counters
    }

    // Take field
    pub fn take_direct_counters(&mut self) -> ::protobuf::RepeatedField<DirectCounter> {
        ::std::mem::replace(&mut self.direct_counters, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.Meter meters = 7;


    pub fn get_meters(&self) -> &[Meter] {
        &self.meters
    }
    pub fn clear_meters(&mut self) {
        self.meters.clear();
    }

    // Param is passed by value, moved
    pub fn set_meters(&mut self, v: ::protobuf::RepeatedField<Meter>) {
        self.meters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_meters(&mut self) -> &mut ::protobuf::RepeatedField<Meter> {
        &mut self.meters
    }

    // Take field
    pub fn take_meters(&mut self) -> ::protobuf::RepeatedField<Meter> {
        ::std::mem::replace(&mut self.meters, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.DirectMeter direct_meters = 8;


    pub fn get_direct_meters(&self) -> &[DirectMeter] {
        &self.direct_meters
    }
    pub fn clear_direct_meters(&mut self) {
        self.direct_meters.clear();
    }

    // Param is passed by value, moved
    pub fn set_direct_meters(&mut self, v: ::protobuf::RepeatedField<DirectMeter>) {
        self.direct_meters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_direct_meters(&mut self) -> &mut ::protobuf::RepeatedField<DirectMeter> {
        &mut self.direct_meters
    }

    // Take field
    pub fn take_direct_meters(&mut self) -> ::protobuf::RepeatedField<DirectMeter> {
        ::std::mem::replace(&mut self.direct_meters, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.ControllerPacketMetadata controller_packet_metadata = 9;


    pub fn get_controller_packet_metadata(&self) -> &[ControllerPacketMetadata] {
        &self.controller_packet_metadata
    }
    pub fn clear_controller_packet_metadata(&mut self) {
        self.controller_packet_metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_controller_packet_metadata(&mut self, v: ::protobuf::RepeatedField<ControllerPacketMetadata>) {
        self.controller_packet_metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_controller_packet_metadata(&mut self) -> &mut ::protobuf::RepeatedField<ControllerPacketMetadata> {
        &mut self.controller_packet_metadata
    }

    // Take field
    pub fn take_controller_packet_metadata(&mut self) -> ::protobuf::RepeatedField<ControllerPacketMetadata> {
        ::std::mem::replace(&mut self.controller_packet_metadata, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.ValueSet value_sets = 10;


    pub fn get_value_sets(&self) -> &[ValueSet] {
        &self.value_sets
    }
    pub fn clear_value_sets(&mut self) {
        self.value_sets.clear();
    }

    // Param is passed by value, moved
    pub fn set_value_sets(&mut self, v: ::protobuf::RepeatedField<ValueSet>) {
        self.value_sets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value_sets(&mut self) -> &mut ::protobuf::RepeatedField<ValueSet> {
        &mut self.value_sets
    }

    // Take field
    pub fn take_value_sets(&mut self) -> ::protobuf::RepeatedField<ValueSet> {
        ::std::mem::replace(&mut self.value_sets, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.Register registers = 11;


    pub fn get_registers(&self) -> &[Register] {
        &self.registers
    }
    pub fn clear_registers(&mut self) {
        self.registers.clear();
    }

    // Param is passed by value, moved
    pub fn set_registers(&mut self, v: ::protobuf::RepeatedField<Register>) {
        self.registers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_registers(&mut self) -> &mut ::protobuf::RepeatedField<Register> {
        &mut self.registers
    }

    // Take field
    pub fn take_registers(&mut self) -> ::protobuf::RepeatedField<Register> {
        ::std::mem::replace(&mut self.registers, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.Digest digests = 12;


    pub fn get_digests(&self) -> &[Digest] {
        &self.digests
    }
    pub fn clear_digests(&mut self) {
        self.digests.clear();
    }

    // Param is passed by value, moved
    pub fn set_digests(&mut self, v: ::protobuf::RepeatedField<Digest>) {
        self.digests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_digests(&mut self) -> &mut ::protobuf::RepeatedField<Digest> {
        &mut self.digests
    }

    // Take field
    pub fn take_digests(&mut self) -> ::protobuf::RepeatedField<Digest> {
        ::std::mem::replace(&mut self.digests, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.Extern externs = 100;


    pub fn get_externs(&self) -> &[Extern] {
        &self.externs
    }
    pub fn clear_externs(&mut self) {
        self.externs.clear();
    }

    // Param is passed by value, moved
    pub fn set_externs(&mut self, v: ::protobuf::RepeatedField<Extern>) {
        self.externs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_externs(&mut self) -> &mut ::protobuf::RepeatedField<Extern> {
        &mut self.externs
    }

    // Take field
    pub fn take_externs(&mut self) -> ::protobuf::RepeatedField<Extern> {
        ::std::mem::replace(&mut self.externs, ::protobuf::RepeatedField::new())
    }

    // .p4.config.v1.P4TypeInfo type_info = 200;


    pub fn get_type_info(&self) -> &super::p4types::P4TypeInfo {
        self.type_info.as_ref().unwrap_or_else(|| <super::p4types::P4TypeInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_type_info(&mut self) {
        self.type_info.clear();
    }

    pub fn has_type_info(&self) -> bool {
        self.type_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_info(&mut self, v: super::p4types::P4TypeInfo) {
        self.type_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_info(&mut self) -> &mut super::p4types::P4TypeInfo {
        if self.type_info.is_none() {
            self.type_info.set_default();
        }
        self.type_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_info(&mut self) -> super::p4types::P4TypeInfo {
        self.type_info.take().unwrap_or_else(|| super::p4types::P4TypeInfo::new())
    }
}

impl ::protobuf::Message for P4Info {
    fn is_initialized(&self) -> bool {
        for v in &self.pkg_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tables {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.actions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.action_profiles {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.counters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.direct_counters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.meters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.direct_meters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.controller_packet_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value_sets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.registers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.digests {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.externs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.type_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pkg_info)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tables)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.actions)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.action_profiles)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.counters)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.direct_counters)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.meters)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.direct_meters)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.controller_packet_metadata)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.value_sets)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.registers)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.digests)?;
                },
                100 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.externs)?;
                },
                200 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.type_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pkg_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.tables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.action_profiles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.counters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.direct_counters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.meters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.direct_meters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.controller_packet_metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.value_sets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.registers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.digests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.externs {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.type_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pkg_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.tables {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.actions {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.action_profiles {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.counters {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.direct_counters {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.meters {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.direct_meters {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.controller_packet_metadata {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.value_sets {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.registers {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.digests {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.externs {
            os.write_tag(100, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.type_info.as_ref() {
            os.write_tag(200, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4Info {
        P4Info::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PkgInfo>>(
                "pkg_info",
                |m: &P4Info| { &m.pkg_info },
                |m: &mut P4Info| { &mut m.pkg_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Table>>(
                "tables",
                |m: &P4Info| { &m.tables },
                |m: &mut P4Info| { &mut m.tables },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Action>>(
                "actions",
                |m: &P4Info| { &m.actions },
                |m: &mut P4Info| { &mut m.actions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ActionProfile>>(
                "action_profiles",
                |m: &P4Info| { &m.action_profiles },
                |m: &mut P4Info| { &mut m.action_profiles },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Counter>>(
                "counters",
                |m: &P4Info| { &m.counters },
                |m: &mut P4Info| { &mut m.counters },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DirectCounter>>(
                "direct_counters",
                |m: &P4Info| { &m.direct_counters },
                |m: &mut P4Info| { &mut m.direct_counters },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Meter>>(
                "meters",
                |m: &P4Info| { &m.meters },
                |m: &mut P4Info| { &mut m.meters },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DirectMeter>>(
                "direct_meters",
                |m: &P4Info| { &m.direct_meters },
                |m: &mut P4Info| { &mut m.direct_meters },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ControllerPacketMetadata>>(
                "controller_packet_metadata",
                |m: &P4Info| { &m.controller_packet_metadata },
                |m: &mut P4Info| { &mut m.controller_packet_metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ValueSet>>(
                "value_sets",
                |m: &P4Info| { &m.value_sets },
                |m: &mut P4Info| { &mut m.value_sets },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Register>>(
                "registers",
                |m: &P4Info| { &m.registers },
                |m: &mut P4Info| { &mut m.registers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Digest>>(
                "digests",
                |m: &P4Info| { &m.digests },
                |m: &mut P4Info| { &mut m.digests },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extern>>(
                "externs",
                |m: &P4Info| { &m.externs },
                |m: &mut P4Info| { &mut m.externs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::P4TypeInfo>>(
                "type_info",
                |m: &P4Info| { &m.type_info },
                |m: &mut P4Info| { &mut m.type_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4Info>(
                "P4Info",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4Info {
        static instance: ::protobuf::rt::LazyV2<P4Info> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4Info::new)
    }
}

impl ::protobuf::Clear for P4Info {
    fn clear(&mut self) {
        self.pkg_info.clear();
        self.tables.clear();
        self.actions.clear();
        self.action_profiles.clear();
        self.counters.clear();
        self.direct_counters.clear();
        self.meters.clear();
        self.direct_meters.clear();
        self.controller_packet_metadata.clear();
        self.value_sets.clear();
        self.registers.clear();
        self.digests.clear();
        self.externs.clear();
        self.type_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4Info {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4Info {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Documentation {
    // message fields
    pub brief: ::std::string::String,
    pub description: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Documentation {
    fn default() -> &'a Documentation {
        <Documentation as ::protobuf::Message>::default_instance()
    }
}

impl Documentation {
    pub fn new() -> Documentation {
        ::std::default::Default::default()
    }

    // string brief = 1;


    pub fn get_brief(&self) -> &str {
        &self.brief
    }
    pub fn clear_brief(&mut self) {
        self.brief.clear();
    }

    // Param is passed by value, moved
    pub fn set_brief(&mut self, v: ::std::string::String) {
        self.brief = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_brief(&mut self) -> &mut ::std::string::String {
        &mut self.brief
    }

    // Take field
    pub fn take_brief(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.brief, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Documentation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.brief)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.brief.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.brief);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.brief.is_empty() {
            os.write_string(1, &self.brief)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Documentation {
        Documentation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "brief",
                |m: &Documentation| { &m.brief },
                |m: &mut Documentation| { &mut m.brief },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &Documentation| { &m.description },
                |m: &mut Documentation| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Documentation>(
                "Documentation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Documentation {
        static instance: ::protobuf::rt::LazyV2<Documentation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Documentation::new)
    }
}

impl ::protobuf::Clear for Documentation {
    fn clear(&mut self) {
        self.brief.clear();
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Documentation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Documentation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PkgInfo {
    // message fields
    pub name: ::std::string::String,
    pub version: ::std::string::String,
    pub doc: ::protobuf::SingularPtrField<Documentation>,
    pub annotations: ::protobuf::RepeatedField<::std::string::String>,
    pub annotation_locations: ::protobuf::RepeatedField<super::p4types::SourceLocation>,
    pub arch: ::std::string::String,
    pub organization: ::std::string::String,
    pub contact: ::std::string::String,
    pub url: ::std::string::String,
    pub structured_annotations: ::protobuf::RepeatedField<super::p4types::StructuredAnnotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PkgInfo {
    fn default() -> &'a PkgInfo {
        <PkgInfo as ::protobuf::Message>::default_instance()
    }
}

impl PkgInfo {
    pub fn new() -> PkgInfo {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string version = 2;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // .p4.config.v1.Documentation doc = 3;


    pub fn get_doc(&self) -> &Documentation {
        self.doc.as_ref().unwrap_or_else(|| <Documentation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_doc(&mut self) {
        self.doc.clear();
    }

    pub fn has_doc(&self) -> bool {
        self.doc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doc(&mut self, v: Documentation) {
        self.doc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc(&mut self) -> &mut Documentation {
        if self.doc.is_none() {
            self.doc.set_default();
        }
        self.doc.as_mut().unwrap()
    }

    // Take field
    pub fn take_doc(&mut self) -> Documentation {
        self.doc.take().unwrap_or_else(|| Documentation::new())
    }

    // repeated string annotations = 4;


    pub fn get_annotations(&self) -> &[::std::string::String] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.SourceLocation annotation_locations = 10;


    pub fn get_annotation_locations(&self) -> &[super::p4types::SourceLocation] {
        &self.annotation_locations
    }
    pub fn clear_annotation_locations(&mut self) {
        self.annotation_locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_locations(&mut self, v: ::protobuf::RepeatedField<super::p4types::SourceLocation>) {
        self.annotation_locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotation_locations(&mut self) -> &mut ::protobuf::RepeatedField<super::p4types::SourceLocation> {
        &mut self.annotation_locations
    }

    // Take field
    pub fn take_annotation_locations(&mut self) -> ::protobuf::RepeatedField<super::p4types::SourceLocation> {
        ::std::mem::replace(&mut self.annotation_locations, ::protobuf::RepeatedField::new())
    }

    // string arch = 5;


    pub fn get_arch(&self) -> &str {
        &self.arch
    }
    pub fn clear_arch(&mut self) {
        self.arch.clear();
    }

    // Param is passed by value, moved
    pub fn set_arch(&mut self, v: ::std::string::String) {
        self.arch = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arch(&mut self) -> &mut ::std::string::String {
        &mut self.arch
    }

    // Take field
    pub fn take_arch(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.arch, ::std::string::String::new())
    }

    // string organization = 6;


    pub fn get_organization(&self) -> &str {
        &self.organization
    }
    pub fn clear_organization(&mut self) {
        self.organization.clear();
    }

    // Param is passed by value, moved
    pub fn set_organization(&mut self, v: ::std::string::String) {
        self.organization = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_organization(&mut self) -> &mut ::std::string::String {
        &mut self.organization
    }

    // Take field
    pub fn take_organization(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.organization, ::std::string::String::new())
    }

    // string contact = 7;


    pub fn get_contact(&self) -> &str {
        &self.contact
    }
    pub fn clear_contact(&mut self) {
        self.contact.clear();
    }

    // Param is passed by value, moved
    pub fn set_contact(&mut self, v: ::std::string::String) {
        self.contact = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contact(&mut self) -> &mut ::std::string::String {
        &mut self.contact
    }

    // Take field
    pub fn take_contact(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.contact, ::std::string::String::new())
    }

    // string url = 8;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // repeated .p4.config.v1.StructuredAnnotation structured_annotations = 9;


    pub fn get_structured_annotations(&self) -> &[super::p4types::StructuredAnnotation] {
        &self.structured_annotations
    }
    pub fn clear_structured_annotations(&mut self) {
        self.structured_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_structured_annotations(&mut self, v: ::protobuf::RepeatedField<super::p4types::StructuredAnnotation>) {
        self.structured_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_structured_annotations(&mut self) -> &mut ::protobuf::RepeatedField<super::p4types::StructuredAnnotation> {
        &mut self.structured_annotations
    }

    // Take field
    pub fn take_structured_annotations(&mut self) -> ::protobuf::RepeatedField<super::p4types::StructuredAnnotation> {
        ::std::mem::replace(&mut self.structured_annotations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PkgInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.doc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotation_locations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.structured_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.doc)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.annotations)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotation_locations)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.arch)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.organization)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.contact)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.structured_annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        if let Some(ref v) = self.doc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.annotations {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.annotation_locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.arch.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.arch);
        }
        if !self.organization.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.organization);
        }
        if !self.contact.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.contact);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.url);
        }
        for value in &self.structured_annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        if let Some(ref v) = self.doc.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.annotations {
            os.write_string(4, &v)?;
        };
        for v in &self.annotation_locations {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.arch.is_empty() {
            os.write_string(5, &self.arch)?;
        }
        if !self.organization.is_empty() {
            os.write_string(6, &self.organization)?;
        }
        if !self.contact.is_empty() {
            os.write_string(7, &self.contact)?;
        }
        if !self.url.is_empty() {
            os.write_string(8, &self.url)?;
        }
        for v in &self.structured_annotations {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PkgInfo {
        PkgInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &PkgInfo| { &m.name },
                |m: &mut PkgInfo| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &PkgInfo| { &m.version },
                |m: &mut PkgInfo| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Documentation>>(
                "doc",
                |m: &PkgInfo| { &m.doc },
                |m: &mut PkgInfo| { &mut m.doc },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &PkgInfo| { &m.annotations },
                |m: &mut PkgInfo| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::SourceLocation>>(
                "annotation_locations",
                |m: &PkgInfo| { &m.annotation_locations },
                |m: &mut PkgInfo| { &mut m.annotation_locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "arch",
                |m: &PkgInfo| { &m.arch },
                |m: &mut PkgInfo| { &mut m.arch },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "organization",
                |m: &PkgInfo| { &m.organization },
                |m: &mut PkgInfo| { &mut m.organization },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contact",
                |m: &PkgInfo| { &m.contact },
                |m: &mut PkgInfo| { &mut m.contact },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &PkgInfo| { &m.url },
                |m: &mut PkgInfo| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::StructuredAnnotation>>(
                "structured_annotations",
                |m: &PkgInfo| { &m.structured_annotations },
                |m: &mut PkgInfo| { &mut m.structured_annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PkgInfo>(
                "PkgInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PkgInfo {
        static instance: ::protobuf::rt::LazyV2<PkgInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PkgInfo::new)
    }
}

impl ::protobuf::Clear for PkgInfo {
    fn clear(&mut self) {
        self.name.clear();
        self.version.clear();
        self.doc.clear();
        self.annotations.clear();
        self.annotation_locations.clear();
        self.arch.clear();
        self.organization.clear();
        self.contact.clear();
        self.url.clear();
        self.structured_annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PkgInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PkgInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4Ids {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4Ids {
    fn default() -> &'a P4Ids {
        <P4Ids as ::protobuf::Message>::default_instance()
    }
}

impl P4Ids {
    pub fn new() -> P4Ids {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for P4Ids {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4Ids {
        P4Ids::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4Ids>(
                "P4Ids",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4Ids {
        static instance: ::protobuf::rt::LazyV2<P4Ids> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4Ids::new)
    }
}

impl ::protobuf::Clear for P4Ids {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4Ids {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4Ids {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum P4Ids_Prefix {
    UNSPECIFIED = 0,
    ACTION = 1,
    TABLE = 2,
    VALUE_SET = 3,
    CONTROLLER_HEADER = 4,
    PSA_EXTERNS_START = 16,
    ACTION_PROFILE = 17,
    COUNTER = 18,
    DIRECT_COUNTER = 19,
    METER = 20,
    DIRECT_METER = 21,
    REGISTER = 22,
    DIGEST = 23,
    OTHER_EXTERNS_START = 128,
    MAX = 255,
}

impl ::protobuf::ProtobufEnum for P4Ids_Prefix {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<P4Ids_Prefix> {
        match value {
            0 => ::std::option::Option::Some(P4Ids_Prefix::UNSPECIFIED),
            1 => ::std::option::Option::Some(P4Ids_Prefix::ACTION),
            2 => ::std::option::Option::Some(P4Ids_Prefix::TABLE),
            3 => ::std::option::Option::Some(P4Ids_Prefix::VALUE_SET),
            4 => ::std::option::Option::Some(P4Ids_Prefix::CONTROLLER_HEADER),
            16 => ::std::option::Option::Some(P4Ids_Prefix::PSA_EXTERNS_START),
            17 => ::std::option::Option::Some(P4Ids_Prefix::ACTION_PROFILE),
            18 => ::std::option::Option::Some(P4Ids_Prefix::COUNTER),
            19 => ::std::option::Option::Some(P4Ids_Prefix::DIRECT_COUNTER),
            20 => ::std::option::Option::Some(P4Ids_Prefix::METER),
            21 => ::std::option::Option::Some(P4Ids_Prefix::DIRECT_METER),
            22 => ::std::option::Option::Some(P4Ids_Prefix::REGISTER),
            23 => ::std::option::Option::Some(P4Ids_Prefix::DIGEST),
            128 => ::std::option::Option::Some(P4Ids_Prefix::OTHER_EXTERNS_START),
            255 => ::std::option::Option::Some(P4Ids_Prefix::MAX),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [P4Ids_Prefix] = &[
            P4Ids_Prefix::UNSPECIFIED,
            P4Ids_Prefix::ACTION,
            P4Ids_Prefix::TABLE,
            P4Ids_Prefix::VALUE_SET,
            P4Ids_Prefix::CONTROLLER_HEADER,
            P4Ids_Prefix::PSA_EXTERNS_START,
            P4Ids_Prefix::ACTION_PROFILE,
            P4Ids_Prefix::COUNTER,
            P4Ids_Prefix::DIRECT_COUNTER,
            P4Ids_Prefix::METER,
            P4Ids_Prefix::DIRECT_METER,
            P4Ids_Prefix::REGISTER,
            P4Ids_Prefix::DIGEST,
            P4Ids_Prefix::OTHER_EXTERNS_START,
            P4Ids_Prefix::MAX,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<P4Ids_Prefix>("P4Ids.Prefix", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for P4Ids_Prefix {
}

impl ::std::default::Default for P4Ids_Prefix {
    fn default() -> Self {
        P4Ids_Prefix::UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for P4Ids_Prefix {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Preamble {
    // message fields
    pub id: u32,
    pub name: ::std::string::String,
    pub alias: ::std::string::String,
    pub annotations: ::protobuf::RepeatedField<::std::string::String>,
    pub annotation_locations: ::protobuf::RepeatedField<super::p4types::SourceLocation>,
    pub doc: ::protobuf::SingularPtrField<Documentation>,
    pub structured_annotations: ::protobuf::RepeatedField<super::p4types::StructuredAnnotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Preamble {
    fn default() -> &'a Preamble {
        <Preamble as ::protobuf::Message>::default_instance()
    }
}

impl Preamble {
    pub fn new() -> Preamble {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string alias = 3;


    pub fn get_alias(&self) -> &str {
        &self.alias
    }
    pub fn clear_alias(&mut self) {
        self.alias.clear();
    }

    // Param is passed by value, moved
    pub fn set_alias(&mut self, v: ::std::string::String) {
        self.alias = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alias(&mut self) -> &mut ::std::string::String {
        &mut self.alias
    }

    // Take field
    pub fn take_alias(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.alias, ::std::string::String::new())
    }

    // repeated string annotations = 4;


    pub fn get_annotations(&self) -> &[::std::string::String] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.SourceLocation annotation_locations = 7;


    pub fn get_annotation_locations(&self) -> &[super::p4types::SourceLocation] {
        &self.annotation_locations
    }
    pub fn clear_annotation_locations(&mut self) {
        self.annotation_locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_locations(&mut self, v: ::protobuf::RepeatedField<super::p4types::SourceLocation>) {
        self.annotation_locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotation_locations(&mut self) -> &mut ::protobuf::RepeatedField<super::p4types::SourceLocation> {
        &mut self.annotation_locations
    }

    // Take field
    pub fn take_annotation_locations(&mut self) -> ::protobuf::RepeatedField<super::p4types::SourceLocation> {
        ::std::mem::replace(&mut self.annotation_locations, ::protobuf::RepeatedField::new())
    }

    // .p4.config.v1.Documentation doc = 5;


    pub fn get_doc(&self) -> &Documentation {
        self.doc.as_ref().unwrap_or_else(|| <Documentation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_doc(&mut self) {
        self.doc.clear();
    }

    pub fn has_doc(&self) -> bool {
        self.doc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doc(&mut self, v: Documentation) {
        self.doc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc(&mut self) -> &mut Documentation {
        if self.doc.is_none() {
            self.doc.set_default();
        }
        self.doc.as_mut().unwrap()
    }

    // Take field
    pub fn take_doc(&mut self) -> Documentation {
        self.doc.take().unwrap_or_else(|| Documentation::new())
    }

    // repeated .p4.config.v1.StructuredAnnotation structured_annotations = 6;


    pub fn get_structured_annotations(&self) -> &[super::p4types::StructuredAnnotation] {
        &self.structured_annotations
    }
    pub fn clear_structured_annotations(&mut self) {
        self.structured_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_structured_annotations(&mut self, v: ::protobuf::RepeatedField<super::p4types::StructuredAnnotation>) {
        self.structured_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_structured_annotations(&mut self) -> &mut ::protobuf::RepeatedField<super::p4types::StructuredAnnotation> {
        &mut self.structured_annotations
    }

    // Take field
    pub fn take_structured_annotations(&mut self) -> ::protobuf::RepeatedField<super::p4types::StructuredAnnotation> {
        ::std::mem::replace(&mut self.structured_annotations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Preamble {
    fn is_initialized(&self) -> bool {
        for v in &self.annotation_locations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.doc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.structured_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.alias)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.annotations)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotation_locations)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.doc)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.structured_annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.alias.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.alias);
        }
        for value in &self.annotations {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.annotation_locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.doc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.structured_annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.alias.is_empty() {
            os.write_string(3, &self.alias)?;
        }
        for v in &self.annotations {
            os.write_string(4, &v)?;
        };
        for v in &self.annotation_locations {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.doc.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.structured_annotations {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Preamble {
        Preamble::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &Preamble| { &m.id },
                |m: &mut Preamble| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Preamble| { &m.name },
                |m: &mut Preamble| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "alias",
                |m: &Preamble| { &m.alias },
                |m: &mut Preamble| { &mut m.alias },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &Preamble| { &m.annotations },
                |m: &mut Preamble| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::SourceLocation>>(
                "annotation_locations",
                |m: &Preamble| { &m.annotation_locations },
                |m: &mut Preamble| { &mut m.annotation_locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Documentation>>(
                "doc",
                |m: &Preamble| { &m.doc },
                |m: &mut Preamble| { &mut m.doc },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::StructuredAnnotation>>(
                "structured_annotations",
                |m: &Preamble| { &m.structured_annotations },
                |m: &mut Preamble| { &mut m.structured_annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Preamble>(
                "Preamble",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Preamble {
        static instance: ::protobuf::rt::LazyV2<Preamble> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Preamble::new)
    }
}

impl ::protobuf::Clear for Preamble {
    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.alias.clear();
        self.annotations.clear();
        self.annotation_locations.clear();
        self.doc.clear();
        self.structured_annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Preamble {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Preamble {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Extern {
    // message fields
    pub extern_type_id: u32,
    pub extern_type_name: ::std::string::String,
    pub instances: ::protobuf::RepeatedField<ExternInstance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Extern {
    fn default() -> &'a Extern {
        <Extern as ::protobuf::Message>::default_instance()
    }
}

impl Extern {
    pub fn new() -> Extern {
        ::std::default::Default::default()
    }

    // uint32 extern_type_id = 1;


    pub fn get_extern_type_id(&self) -> u32 {
        self.extern_type_id
    }
    pub fn clear_extern_type_id(&mut self) {
        self.extern_type_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_extern_type_id(&mut self, v: u32) {
        self.extern_type_id = v;
    }

    // string extern_type_name = 2;


    pub fn get_extern_type_name(&self) -> &str {
        &self.extern_type_name
    }
    pub fn clear_extern_type_name(&mut self) {
        self.extern_type_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_extern_type_name(&mut self, v: ::std::string::String) {
        self.extern_type_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extern_type_name(&mut self) -> &mut ::std::string::String {
        &mut self.extern_type_name
    }

    // Take field
    pub fn take_extern_type_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.extern_type_name, ::std::string::String::new())
    }

    // repeated .p4.config.v1.ExternInstance instances = 3;


    pub fn get_instances(&self) -> &[ExternInstance] {
        &self.instances
    }
    pub fn clear_instances(&mut self) {
        self.instances.clear();
    }

    // Param is passed by value, moved
    pub fn set_instances(&mut self, v: ::protobuf::RepeatedField<ExternInstance>) {
        self.instances = v;
    }

    // Mutable pointer to the field.
    pub fn mut_instances(&mut self) -> &mut ::protobuf::RepeatedField<ExternInstance> {
        &mut self.instances
    }

    // Take field
    pub fn take_instances(&mut self) -> ::protobuf::RepeatedField<ExternInstance> {
        ::std::mem::replace(&mut self.instances, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Extern {
    fn is_initialized(&self) -> bool {
        for v in &self.instances {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.extern_type_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.extern_type_name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.instances)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.extern_type_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.extern_type_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.extern_type_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.extern_type_name);
        }
        for value in &self.instances {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.extern_type_id != 0 {
            os.write_uint32(1, self.extern_type_id)?;
        }
        if !self.extern_type_name.is_empty() {
            os.write_string(2, &self.extern_type_name)?;
        }
        for v in &self.instances {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Extern {
        Extern::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "extern_type_id",
                |m: &Extern| { &m.extern_type_id },
                |m: &mut Extern| { &mut m.extern_type_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "extern_type_name",
                |m: &Extern| { &m.extern_type_name },
                |m: &mut Extern| { &mut m.extern_type_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternInstance>>(
                "instances",
                |m: &Extern| { &m.instances },
                |m: &mut Extern| { &mut m.instances },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Extern>(
                "Extern",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Extern {
        static instance: ::protobuf::rt::LazyV2<Extern> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Extern::new)
    }
}

impl ::protobuf::Clear for Extern {
    fn clear(&mut self) {
        self.extern_type_id = 0;
        self.extern_type_name.clear();
        self.instances.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Extern {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Extern {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExternInstance {
    // message fields
    pub preamble: ::protobuf::SingularPtrField<Preamble>,
    pub info: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExternInstance {
    fn default() -> &'a ExternInstance {
        <ExternInstance as ::protobuf::Message>::default_instance()
    }
}

impl ExternInstance {
    pub fn new() -> ExternInstance {
        ::std::default::Default::default()
    }

    // .p4.config.v1.Preamble preamble = 1;


    pub fn get_preamble(&self) -> &Preamble {
        self.preamble.as_ref().unwrap_or_else(|| <Preamble as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preamble(&mut self) {
        self.preamble.clear();
    }

    pub fn has_preamble(&self) -> bool {
        self.preamble.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preamble(&mut self, v: Preamble) {
        self.preamble = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preamble(&mut self) -> &mut Preamble {
        if self.preamble.is_none() {
            self.preamble.set_default();
        }
        self.preamble.as_mut().unwrap()
    }

    // Take field
    pub fn take_preamble(&mut self) -> Preamble {
        self.preamble.take().unwrap_or_else(|| Preamble::new())
    }

    // .google.protobuf.Any info = 2;


    pub fn get_info(&self) -> &::protobuf::well_known_types::Any {
        self.info.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::protobuf::well_known_types::Any) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> ::protobuf::well_known_types::Any {
        self.info.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for ExternInstance {
    fn is_initialized(&self) -> bool {
        for v in &self.preamble {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preamble)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preamble.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preamble.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternInstance {
        ExternInstance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Preamble>>(
                "preamble",
                |m: &ExternInstance| { &m.preamble },
                |m: &mut ExternInstance| { &mut m.preamble },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "info",
                |m: &ExternInstance| { &m.info },
                |m: &mut ExternInstance| { &mut m.info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExternInstance>(
                "ExternInstance",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternInstance {
        static instance: ::protobuf::rt::LazyV2<ExternInstance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExternInstance::new)
    }
}

impl ::protobuf::Clear for ExternInstance {
    fn clear(&mut self) {
        self.preamble.clear();
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternInstance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatchField {
    // message fields
    pub id: u32,
    pub name: ::std::string::String,
    pub annotations: ::protobuf::RepeatedField<::std::string::String>,
    pub annotation_locations: ::protobuf::RepeatedField<super::p4types::SourceLocation>,
    pub bitwidth: i32,
    pub doc: ::protobuf::SingularPtrField<Documentation>,
    pub type_name: ::protobuf::SingularPtrField<super::p4types::P4NamedType>,
    pub structured_annotations: ::protobuf::RepeatedField<super::p4types::StructuredAnnotation>,
    // message oneof groups
    pub field_match: ::std::option::Option<MatchField_oneof_match>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MatchField {
    fn default() -> &'a MatchField {
        <MatchField as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum MatchField_oneof_match {
    match_type(MatchField_MatchType),
    other_match_type(::std::string::String),
}

impl MatchField {
    pub fn new() -> MatchField {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated string annotations = 3;


    pub fn get_annotations(&self) -> &[::std::string::String] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.SourceLocation annotation_locations = 10;


    pub fn get_annotation_locations(&self) -> &[super::p4types::SourceLocation] {
        &self.annotation_locations
    }
    pub fn clear_annotation_locations(&mut self) {
        self.annotation_locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_locations(&mut self, v: ::protobuf::RepeatedField<super::p4types::SourceLocation>) {
        self.annotation_locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotation_locations(&mut self) -> &mut ::protobuf::RepeatedField<super::p4types::SourceLocation> {
        &mut self.annotation_locations
    }

    // Take field
    pub fn take_annotation_locations(&mut self) -> ::protobuf::RepeatedField<super::p4types::SourceLocation> {
        ::std::mem::replace(&mut self.annotation_locations, ::protobuf::RepeatedField::new())
    }

    // int32 bitwidth = 4;


    pub fn get_bitwidth(&self) -> i32 {
        self.bitwidth
    }
    pub fn clear_bitwidth(&mut self) {
        self.bitwidth = 0;
    }

    // Param is passed by value, moved
    pub fn set_bitwidth(&mut self, v: i32) {
        self.bitwidth = v;
    }

    // .p4.config.v1.MatchField.MatchType match_type = 5;


    pub fn get_match_type(&self) -> MatchField_MatchType {
        match self.field_match {
            ::std::option::Option::Some(MatchField_oneof_match::match_type(v)) => v,
            _ => MatchField_MatchType::UNSPECIFIED,
        }
    }
    pub fn clear_match_type(&mut self) {
        self.field_match = ::std::option::Option::None;
    }

    pub fn has_match_type(&self) -> bool {
        match self.field_match {
            ::std::option::Option::Some(MatchField_oneof_match::match_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_match_type(&mut self, v: MatchField_MatchType) {
        self.field_match = ::std::option::Option::Some(MatchField_oneof_match::match_type(v))
    }

    // string other_match_type = 7;


    pub fn get_other_match_type(&self) -> &str {
        match self.field_match {
            ::std::option::Option::Some(MatchField_oneof_match::other_match_type(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_other_match_type(&mut self) {
        self.field_match = ::std::option::Option::None;
    }

    pub fn has_other_match_type(&self) -> bool {
        match self.field_match {
            ::std::option::Option::Some(MatchField_oneof_match::other_match_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_other_match_type(&mut self, v: ::std::string::String) {
        self.field_match = ::std::option::Option::Some(MatchField_oneof_match::other_match_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_other_match_type(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(MatchField_oneof_match::other_match_type(_)) = self.field_match {
        } else {
            self.field_match = ::std::option::Option::Some(MatchField_oneof_match::other_match_type(::std::string::String::new()));
        }
        match self.field_match {
            ::std::option::Option::Some(MatchField_oneof_match::other_match_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_other_match_type(&mut self) -> ::std::string::String {
        if self.has_other_match_type() {
            match self.field_match.take() {
                ::std::option::Option::Some(MatchField_oneof_match::other_match_type(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .p4.config.v1.Documentation doc = 6;


    pub fn get_doc(&self) -> &Documentation {
        self.doc.as_ref().unwrap_or_else(|| <Documentation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_doc(&mut self) {
        self.doc.clear();
    }

    pub fn has_doc(&self) -> bool {
        self.doc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doc(&mut self, v: Documentation) {
        self.doc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc(&mut self) -> &mut Documentation {
        if self.doc.is_none() {
            self.doc.set_default();
        }
        self.doc.as_mut().unwrap()
    }

    // Take field
    pub fn take_doc(&mut self) -> Documentation {
        self.doc.take().unwrap_or_else(|| Documentation::new())
    }

    // .p4.config.v1.P4NamedType type_name = 8;


    pub fn get_type_name(&self) -> &super::p4types::P4NamedType {
        self.type_name.as_ref().unwrap_or_else(|| <super::p4types::P4NamedType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_type_name(&mut self) {
        self.type_name.clear();
    }

    pub fn has_type_name(&self) -> bool {
        self.type_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_name(&mut self, v: super::p4types::P4NamedType) {
        self.type_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_name(&mut self) -> &mut super::p4types::P4NamedType {
        if self.type_name.is_none() {
            self.type_name.set_default();
        }
        self.type_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_name(&mut self) -> super::p4types::P4NamedType {
        self.type_name.take().unwrap_or_else(|| super::p4types::P4NamedType::new())
    }

    // repeated .p4.config.v1.StructuredAnnotation structured_annotations = 9;


    pub fn get_structured_annotations(&self) -> &[super::p4types::StructuredAnnotation] {
        &self.structured_annotations
    }
    pub fn clear_structured_annotations(&mut self) {
        self.structured_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_structured_annotations(&mut self, v: ::protobuf::RepeatedField<super::p4types::StructuredAnnotation>) {
        self.structured_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_structured_annotations(&mut self) -> &mut ::protobuf::RepeatedField<super::p4types::StructuredAnnotation> {
        &mut self.structured_annotations
    }

    // Take field
    pub fn take_structured_annotations(&mut self) -> ::protobuf::RepeatedField<super::p4types::StructuredAnnotation> {
        ::std::mem::replace(&mut self.structured_annotations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MatchField {
    fn is_initialized(&self) -> bool {
        for v in &self.annotation_locations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.doc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.type_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.structured_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.annotations)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotation_locations)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bitwidth = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_match = ::std::option::Option::Some(MatchField_oneof_match::match_type(is.read_enum()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_match = ::std::option::Option::Some(MatchField_oneof_match::other_match_type(is.read_string()?));
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.doc)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.type_name)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.structured_annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.annotations {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.annotation_locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.bitwidth != 0 {
            my_size += ::protobuf::rt::value_size(4, self.bitwidth, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.doc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.type_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.structured_annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.field_match {
            match v {
                &MatchField_oneof_match::match_type(v) => {
                    my_size += ::protobuf::rt::enum_size(5, v);
                },
                &MatchField_oneof_match::other_match_type(ref v) => {
                    my_size += ::protobuf::rt::string_size(7, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.annotations {
            os.write_string(3, &v)?;
        };
        for v in &self.annotation_locations {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.bitwidth != 0 {
            os.write_int32(4, self.bitwidth)?;
        }
        if let Some(ref v) = self.doc.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.type_name.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.structured_annotations {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.field_match {
            match v {
                &MatchField_oneof_match::match_type(v) => {
                    os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
                },
                &MatchField_oneof_match::other_match_type(ref v) => {
                    os.write_string(7, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MatchField {
        MatchField::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &MatchField| { &m.id },
                |m: &mut MatchField| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &MatchField| { &m.name },
                |m: &mut MatchField| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &MatchField| { &m.annotations },
                |m: &mut MatchField| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::SourceLocation>>(
                "annotation_locations",
                |m: &MatchField| { &m.annotation_locations },
                |m: &mut MatchField| { &mut m.annotation_locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bitwidth",
                |m: &MatchField| { &m.bitwidth },
                |m: &mut MatchField| { &mut m.bitwidth },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, MatchField_MatchType>(
                "match_type",
                MatchField::has_match_type,
                MatchField::get_match_type,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "other_match_type",
                MatchField::has_other_match_type,
                MatchField::get_other_match_type,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Documentation>>(
                "doc",
                |m: &MatchField| { &m.doc },
                |m: &mut MatchField| { &mut m.doc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::P4NamedType>>(
                "type_name",
                |m: &MatchField| { &m.type_name },
                |m: &mut MatchField| { &mut m.type_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::StructuredAnnotation>>(
                "structured_annotations",
                |m: &MatchField| { &m.structured_annotations },
                |m: &mut MatchField| { &mut m.structured_annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MatchField>(
                "MatchField",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MatchField {
        static instance: ::protobuf::rt::LazyV2<MatchField> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MatchField::new)
    }
}

impl ::protobuf::Clear for MatchField {
    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.annotations.clear();
        self.annotation_locations.clear();
        self.bitwidth = 0;
        self.field_match = ::std::option::Option::None;
        self.field_match = ::std::option::Option::None;
        self.doc.clear();
        self.type_name.clear();
        self.structured_annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatchField {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchField {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MatchField_MatchType {
    UNSPECIFIED = 0,
    EXACT = 2,
    LPM = 3,
    TERNARY = 4,
    RANGE = 5,
    OPTIONAL = 6,
}

impl ::protobuf::ProtobufEnum for MatchField_MatchType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MatchField_MatchType> {
        match value {
            0 => ::std::option::Option::Some(MatchField_MatchType::UNSPECIFIED),
            2 => ::std::option::Option::Some(MatchField_MatchType::EXACT),
            3 => ::std::option::Option::Some(MatchField_MatchType::LPM),
            4 => ::std::option::Option::Some(MatchField_MatchType::TERNARY),
            5 => ::std::option::Option::Some(MatchField_MatchType::RANGE),
            6 => ::std::option::Option::Some(MatchField_MatchType::OPTIONAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MatchField_MatchType] = &[
            MatchField_MatchType::UNSPECIFIED,
            MatchField_MatchType::EXACT,
            MatchField_MatchType::LPM,
            MatchField_MatchType::TERNARY,
            MatchField_MatchType::RANGE,
            MatchField_MatchType::OPTIONAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<MatchField_MatchType>("MatchField.MatchType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for MatchField_MatchType {
}

impl ::std::default::Default for MatchField_MatchType {
    fn default() -> Self {
        MatchField_MatchType::UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchField_MatchType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Table {
    // message fields
    pub preamble: ::protobuf::SingularPtrField<Preamble>,
    pub match_fields: ::protobuf::RepeatedField<MatchField>,
    pub action_refs: ::protobuf::RepeatedField<ActionRef>,
    pub const_default_action_id: u32,
    pub implementation_id: u32,
    pub direct_resource_ids: ::std::vec::Vec<u32>,
    pub size: i64,
    pub idle_timeout_behavior: Table_IdleTimeoutBehavior,
    pub is_const_table: bool,
    pub other_properties: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Table {
    fn default() -> &'a Table {
        <Table as ::protobuf::Message>::default_instance()
    }
}

impl Table {
    pub fn new() -> Table {
        ::std::default::Default::default()
    }

    // .p4.config.v1.Preamble preamble = 1;


    pub fn get_preamble(&self) -> &Preamble {
        self.preamble.as_ref().unwrap_or_else(|| <Preamble as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preamble(&mut self) {
        self.preamble.clear();
    }

    pub fn has_preamble(&self) -> bool {
        self.preamble.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preamble(&mut self, v: Preamble) {
        self.preamble = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preamble(&mut self) -> &mut Preamble {
        if self.preamble.is_none() {
            self.preamble.set_default();
        }
        self.preamble.as_mut().unwrap()
    }

    // Take field
    pub fn take_preamble(&mut self) -> Preamble {
        self.preamble.take().unwrap_or_else(|| Preamble::new())
    }

    // repeated .p4.config.v1.MatchField match_fields = 2;


    pub fn get_match_fields(&self) -> &[MatchField] {
        &self.match_fields
    }
    pub fn clear_match_fields(&mut self) {
        self.match_fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_match_fields(&mut self, v: ::protobuf::RepeatedField<MatchField>) {
        self.match_fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_match_fields(&mut self) -> &mut ::protobuf::RepeatedField<MatchField> {
        &mut self.match_fields
    }

    // Take field
    pub fn take_match_fields(&mut self) -> ::protobuf::RepeatedField<MatchField> {
        ::std::mem::replace(&mut self.match_fields, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.ActionRef action_refs = 3;


    pub fn get_action_refs(&self) -> &[ActionRef] {
        &self.action_refs
    }
    pub fn clear_action_refs(&mut self) {
        self.action_refs.clear();
    }

    // Param is passed by value, moved
    pub fn set_action_refs(&mut self, v: ::protobuf::RepeatedField<ActionRef>) {
        self.action_refs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_action_refs(&mut self) -> &mut ::protobuf::RepeatedField<ActionRef> {
        &mut self.action_refs
    }

    // Take field
    pub fn take_action_refs(&mut self) -> ::protobuf::RepeatedField<ActionRef> {
        ::std::mem::replace(&mut self.action_refs, ::protobuf::RepeatedField::new())
    }

    // uint32 const_default_action_id = 4;


    pub fn get_const_default_action_id(&self) -> u32 {
        self.const_default_action_id
    }
    pub fn clear_const_default_action_id(&mut self) {
        self.const_default_action_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_const_default_action_id(&mut self, v: u32) {
        self.const_default_action_id = v;
    }

    // uint32 implementation_id = 6;


    pub fn get_implementation_id(&self) -> u32 {
        self.implementation_id
    }
    pub fn clear_implementation_id(&mut self) {
        self.implementation_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_implementation_id(&mut self, v: u32) {
        self.implementation_id = v;
    }

    // repeated uint32 direct_resource_ids = 7;


    pub fn get_direct_resource_ids(&self) -> &[u32] {
        &self.direct_resource_ids
    }
    pub fn clear_direct_resource_ids(&mut self) {
        self.direct_resource_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_direct_resource_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.direct_resource_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_direct_resource_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.direct_resource_ids
    }

    // Take field
    pub fn take_direct_resource_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.direct_resource_ids, ::std::vec::Vec::new())
    }

    // int64 size = 8;


    pub fn get_size(&self) -> i64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i64) {
        self.size = v;
    }

    // .p4.config.v1.Table.IdleTimeoutBehavior idle_timeout_behavior = 9;


    pub fn get_idle_timeout_behavior(&self) -> Table_IdleTimeoutBehavior {
        self.idle_timeout_behavior
    }
    pub fn clear_idle_timeout_behavior(&mut self) {
        self.idle_timeout_behavior = Table_IdleTimeoutBehavior::NO_TIMEOUT;
    }

    // Param is passed by value, moved
    pub fn set_idle_timeout_behavior(&mut self, v: Table_IdleTimeoutBehavior) {
        self.idle_timeout_behavior = v;
    }

    // bool is_const_table = 10;


    pub fn get_is_const_table(&self) -> bool {
        self.is_const_table
    }
    pub fn clear_is_const_table(&mut self) {
        self.is_const_table = false;
    }

    // Param is passed by value, moved
    pub fn set_is_const_table(&mut self, v: bool) {
        self.is_const_table = v;
    }

    // .google.protobuf.Any other_properties = 100;


    pub fn get_other_properties(&self) -> &::protobuf::well_known_types::Any {
        self.other_properties.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_other_properties(&mut self) {
        self.other_properties.clear();
    }

    pub fn has_other_properties(&self) -> bool {
        self.other_properties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_properties(&mut self, v: ::protobuf::well_known_types::Any) {
        self.other_properties = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_other_properties(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.other_properties.is_none() {
            self.other_properties.set_default();
        }
        self.other_properties.as_mut().unwrap()
    }

    // Take field
    pub fn take_other_properties(&mut self) -> ::protobuf::well_known_types::Any {
        self.other_properties.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for Table {
    fn is_initialized(&self) -> bool {
        for v in &self.preamble {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.match_fields {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.action_refs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.other_properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preamble)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.match_fields)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.action_refs)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.const_default_action_id = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.implementation_id = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.direct_resource_ids)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = tmp;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.idle_timeout_behavior, 9, &mut self.unknown_fields)?
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_const_table = tmp;
                },
                100 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.other_properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preamble.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.match_fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.action_refs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.const_default_action_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.const_default_action_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.implementation_id != 0 {
            my_size += ::protobuf::rt::value_size(6, self.implementation_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.direct_resource_ids {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(8, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.idle_timeout_behavior != Table_IdleTimeoutBehavior::NO_TIMEOUT {
            my_size += ::protobuf::rt::enum_size(9, self.idle_timeout_behavior);
        }
        if self.is_const_table != false {
            my_size += 2;
        }
        if let Some(ref v) = self.other_properties.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preamble.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.match_fields {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.action_refs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.const_default_action_id != 0 {
            os.write_uint32(4, self.const_default_action_id)?;
        }
        if self.implementation_id != 0 {
            os.write_uint32(6, self.implementation_id)?;
        }
        for v in &self.direct_resource_ids {
            os.write_uint32(7, *v)?;
        };
        if self.size != 0 {
            os.write_int64(8, self.size)?;
        }
        if self.idle_timeout_behavior != Table_IdleTimeoutBehavior::NO_TIMEOUT {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.idle_timeout_behavior))?;
        }
        if self.is_const_table != false {
            os.write_bool(10, self.is_const_table)?;
        }
        if let Some(ref v) = self.other_properties.as_ref() {
            os.write_tag(100, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Table {
        Table::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Preamble>>(
                "preamble",
                |m: &Table| { &m.preamble },
                |m: &mut Table| { &mut m.preamble },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatchField>>(
                "match_fields",
                |m: &Table| { &m.match_fields },
                |m: &mut Table| { &mut m.match_fields },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ActionRef>>(
                "action_refs",
                |m: &Table| { &m.action_refs },
                |m: &mut Table| { &mut m.action_refs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "const_default_action_id",
                |m: &Table| { &m.const_default_action_id },
                |m: &mut Table| { &mut m.const_default_action_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "implementation_id",
                |m: &Table| { &m.implementation_id },
                |m: &mut Table| { &mut m.implementation_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "direct_resource_ids",
                |m: &Table| { &m.direct_resource_ids },
                |m: &mut Table| { &mut m.direct_resource_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size",
                |m: &Table| { &m.size },
                |m: &mut Table| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Table_IdleTimeoutBehavior>>(
                "idle_timeout_behavior",
                |m: &Table| { &m.idle_timeout_behavior },
                |m: &mut Table| { &mut m.idle_timeout_behavior },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_const_table",
                |m: &Table| { &m.is_const_table },
                |m: &mut Table| { &mut m.is_const_table },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "other_properties",
                |m: &Table| { &m.other_properties },
                |m: &mut Table| { &mut m.other_properties },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Table>(
                "Table",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Table {
        static instance: ::protobuf::rt::LazyV2<Table> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Table::new)
    }
}

impl ::protobuf::Clear for Table {
    fn clear(&mut self) {
        self.preamble.clear();
        self.match_fields.clear();
        self.action_refs.clear();
        self.const_default_action_id = 0;
        self.implementation_id = 0;
        self.direct_resource_ids.clear();
        self.size = 0;
        self.idle_timeout_behavior = Table_IdleTimeoutBehavior::NO_TIMEOUT;
        self.is_const_table = false;
        self.other_properties.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Table {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Table {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Table_IdleTimeoutBehavior {
    NO_TIMEOUT = 0,
    NOTIFY_CONTROL = 1,
}

impl ::protobuf::ProtobufEnum for Table_IdleTimeoutBehavior {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Table_IdleTimeoutBehavior> {
        match value {
            0 => ::std::option::Option::Some(Table_IdleTimeoutBehavior::NO_TIMEOUT),
            1 => ::std::option::Option::Some(Table_IdleTimeoutBehavior::NOTIFY_CONTROL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Table_IdleTimeoutBehavior] = &[
            Table_IdleTimeoutBehavior::NO_TIMEOUT,
            Table_IdleTimeoutBehavior::NOTIFY_CONTROL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Table_IdleTimeoutBehavior>("Table.IdleTimeoutBehavior", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Table_IdleTimeoutBehavior {
}

impl ::std::default::Default for Table_IdleTimeoutBehavior {
    fn default() -> Self {
        Table_IdleTimeoutBehavior::NO_TIMEOUT
    }
}

impl ::protobuf::reflect::ProtobufValue for Table_IdleTimeoutBehavior {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionRef {
    // message fields
    pub id: u32,
    pub scope: ActionRef_Scope,
    pub annotations: ::protobuf::RepeatedField<::std::string::String>,
    pub annotation_locations: ::protobuf::RepeatedField<super::p4types::SourceLocation>,
    pub structured_annotations: ::protobuf::RepeatedField<super::p4types::StructuredAnnotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionRef {
    fn default() -> &'a ActionRef {
        <ActionRef as ::protobuf::Message>::default_instance()
    }
}

impl ActionRef {
    pub fn new() -> ActionRef {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    // .p4.config.v1.ActionRef.Scope scope = 3;


    pub fn get_scope(&self) -> ActionRef_Scope {
        self.scope
    }
    pub fn clear_scope(&mut self) {
        self.scope = ActionRef_Scope::TABLE_AND_DEFAULT;
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ActionRef_Scope) {
        self.scope = v;
    }

    // repeated string annotations = 2;


    pub fn get_annotations(&self) -> &[::std::string::String] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.SourceLocation annotation_locations = 5;


    pub fn get_annotation_locations(&self) -> &[super::p4types::SourceLocation] {
        &self.annotation_locations
    }
    pub fn clear_annotation_locations(&mut self) {
        self.annotation_locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_locations(&mut self, v: ::protobuf::RepeatedField<super::p4types::SourceLocation>) {
        self.annotation_locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotation_locations(&mut self) -> &mut ::protobuf::RepeatedField<super::p4types::SourceLocation> {
        &mut self.annotation_locations
    }

    // Take field
    pub fn take_annotation_locations(&mut self) -> ::protobuf::RepeatedField<super::p4types::SourceLocation> {
        ::std::mem::replace(&mut self.annotation_locations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.StructuredAnnotation structured_annotations = 4;


    pub fn get_structured_annotations(&self) -> &[super::p4types::StructuredAnnotation] {
        &self.structured_annotations
    }
    pub fn clear_structured_annotations(&mut self) {
        self.structured_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_structured_annotations(&mut self, v: ::protobuf::RepeatedField<super::p4types::StructuredAnnotation>) {
        self.structured_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_structured_annotations(&mut self) -> &mut ::protobuf::RepeatedField<super::p4types::StructuredAnnotation> {
        &mut self.structured_annotations
    }

    // Take field
    pub fn take_structured_annotations(&mut self) -> ::protobuf::RepeatedField<super::p4types::StructuredAnnotation> {
        ::std::mem::replace(&mut self.structured_annotations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ActionRef {
    fn is_initialized(&self) -> bool {
        for v in &self.annotation_locations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.structured_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.scope, 3, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.annotations)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotation_locations)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.structured_annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.scope != ActionRef_Scope::TABLE_AND_DEFAULT {
            my_size += ::protobuf::rt::enum_size(3, self.scope);
        }
        for value in &self.annotations {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.annotation_locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.structured_annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if self.scope != ActionRef_Scope::TABLE_AND_DEFAULT {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.scope))?;
        }
        for v in &self.annotations {
            os.write_string(2, &v)?;
        };
        for v in &self.annotation_locations {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.structured_annotations {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionRef {
        ActionRef::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &ActionRef| { &m.id },
                |m: &mut ActionRef| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ActionRef_Scope>>(
                "scope",
                |m: &ActionRef| { &m.scope },
                |m: &mut ActionRef| { &mut m.scope },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &ActionRef| { &m.annotations },
                |m: &mut ActionRef| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::SourceLocation>>(
                "annotation_locations",
                |m: &ActionRef| { &m.annotation_locations },
                |m: &mut ActionRef| { &mut m.annotation_locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::StructuredAnnotation>>(
                "structured_annotations",
                |m: &ActionRef| { &m.structured_annotations },
                |m: &mut ActionRef| { &mut m.structured_annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionRef>(
                "ActionRef",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionRef {
        static instance: ::protobuf::rt::LazyV2<ActionRef> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionRef::new)
    }
}

impl ::protobuf::Clear for ActionRef {
    fn clear(&mut self) {
        self.id = 0;
        self.scope = ActionRef_Scope::TABLE_AND_DEFAULT;
        self.annotations.clear();
        self.annotation_locations.clear();
        self.structured_annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionRef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionRef {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ActionRef_Scope {
    TABLE_AND_DEFAULT = 0,
    TABLE_ONLY = 1,
    DEFAULT_ONLY = 2,
}

impl ::protobuf::ProtobufEnum for ActionRef_Scope {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ActionRef_Scope> {
        match value {
            0 => ::std::option::Option::Some(ActionRef_Scope::TABLE_AND_DEFAULT),
            1 => ::std::option::Option::Some(ActionRef_Scope::TABLE_ONLY),
            2 => ::std::option::Option::Some(ActionRef_Scope::DEFAULT_ONLY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ActionRef_Scope] = &[
            ActionRef_Scope::TABLE_AND_DEFAULT,
            ActionRef_Scope::TABLE_ONLY,
            ActionRef_Scope::DEFAULT_ONLY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ActionRef_Scope>("ActionRef.Scope", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ActionRef_Scope {
}

impl ::std::default::Default for ActionRef_Scope {
    fn default() -> Self {
        ActionRef_Scope::TABLE_AND_DEFAULT
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionRef_Scope {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Action {
    // message fields
    pub preamble: ::protobuf::SingularPtrField<Preamble>,
    pub params: ::protobuf::RepeatedField<Action_Param>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Action {
    fn default() -> &'a Action {
        <Action as ::protobuf::Message>::default_instance()
    }
}

impl Action {
    pub fn new() -> Action {
        ::std::default::Default::default()
    }

    // .p4.config.v1.Preamble preamble = 1;


    pub fn get_preamble(&self) -> &Preamble {
        self.preamble.as_ref().unwrap_or_else(|| <Preamble as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preamble(&mut self) {
        self.preamble.clear();
    }

    pub fn has_preamble(&self) -> bool {
        self.preamble.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preamble(&mut self, v: Preamble) {
        self.preamble = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preamble(&mut self) -> &mut Preamble {
        if self.preamble.is_none() {
            self.preamble.set_default();
        }
        self.preamble.as_mut().unwrap()
    }

    // Take field
    pub fn take_preamble(&mut self) -> Preamble {
        self.preamble.take().unwrap_or_else(|| Preamble::new())
    }

    // repeated .p4.config.v1.Action.Param params = 2;


    pub fn get_params(&self) -> &[Action_Param] {
        &self.params
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::protobuf::RepeatedField<Action_Param>) {
        self.params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_params(&mut self) -> &mut ::protobuf::RepeatedField<Action_Param> {
        &mut self.params
    }

    // Take field
    pub fn take_params(&mut self) -> ::protobuf::RepeatedField<Action_Param> {
        ::std::mem::replace(&mut self.params, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Action {
    fn is_initialized(&self) -> bool {
        for v in &self.preamble {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preamble)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preamble.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.params {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preamble.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.params {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Action {
        Action::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Preamble>>(
                "preamble",
                |m: &Action| { &m.preamble },
                |m: &mut Action| { &mut m.preamble },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Action_Param>>(
                "params",
                |m: &Action| { &m.params },
                |m: &mut Action| { &mut m.params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Action>(
                "Action",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Action {
        static instance: ::protobuf::rt::LazyV2<Action> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Action::new)
    }
}

impl ::protobuf::Clear for Action {
    fn clear(&mut self) {
        self.preamble.clear();
        self.params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Action {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Action {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Action_Param {
    // message fields
    pub id: u32,
    pub name: ::std::string::String,
    pub annotations: ::protobuf::RepeatedField<::std::string::String>,
    pub annotation_locations: ::protobuf::RepeatedField<super::p4types::SourceLocation>,
    pub bitwidth: i32,
    pub doc: ::protobuf::SingularPtrField<Documentation>,
    pub type_name: ::protobuf::SingularPtrField<super::p4types::P4NamedType>,
    pub structured_annotations: ::protobuf::RepeatedField<super::p4types::StructuredAnnotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Action_Param {
    fn default() -> &'a Action_Param {
        <Action_Param as ::protobuf::Message>::default_instance()
    }
}

impl Action_Param {
    pub fn new() -> Action_Param {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated string annotations = 3;


    pub fn get_annotations(&self) -> &[::std::string::String] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.SourceLocation annotation_locations = 8;


    pub fn get_annotation_locations(&self) -> &[super::p4types::SourceLocation] {
        &self.annotation_locations
    }
    pub fn clear_annotation_locations(&mut self) {
        self.annotation_locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_locations(&mut self, v: ::protobuf::RepeatedField<super::p4types::SourceLocation>) {
        self.annotation_locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotation_locations(&mut self) -> &mut ::protobuf::RepeatedField<super::p4types::SourceLocation> {
        &mut self.annotation_locations
    }

    // Take field
    pub fn take_annotation_locations(&mut self) -> ::protobuf::RepeatedField<super::p4types::SourceLocation> {
        ::std::mem::replace(&mut self.annotation_locations, ::protobuf::RepeatedField::new())
    }

    // int32 bitwidth = 4;


    pub fn get_bitwidth(&self) -> i32 {
        self.bitwidth
    }
    pub fn clear_bitwidth(&mut self) {
        self.bitwidth = 0;
    }

    // Param is passed by value, moved
    pub fn set_bitwidth(&mut self, v: i32) {
        self.bitwidth = v;
    }

    // .p4.config.v1.Documentation doc = 5;


    pub fn get_doc(&self) -> &Documentation {
        self.doc.as_ref().unwrap_or_else(|| <Documentation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_doc(&mut self) {
        self.doc.clear();
    }

    pub fn has_doc(&self) -> bool {
        self.doc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doc(&mut self, v: Documentation) {
        self.doc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc(&mut self) -> &mut Documentation {
        if self.doc.is_none() {
            self.doc.set_default();
        }
        self.doc.as_mut().unwrap()
    }

    // Take field
    pub fn take_doc(&mut self) -> Documentation {
        self.doc.take().unwrap_or_else(|| Documentation::new())
    }

    // .p4.config.v1.P4NamedType type_name = 6;


    pub fn get_type_name(&self) -> &super::p4types::P4NamedType {
        self.type_name.as_ref().unwrap_or_else(|| <super::p4types::P4NamedType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_type_name(&mut self) {
        self.type_name.clear();
    }

    pub fn has_type_name(&self) -> bool {
        self.type_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_name(&mut self, v: super::p4types::P4NamedType) {
        self.type_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_name(&mut self) -> &mut super::p4types::P4NamedType {
        if self.type_name.is_none() {
            self.type_name.set_default();
        }
        self.type_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_name(&mut self) -> super::p4types::P4NamedType {
        self.type_name.take().unwrap_or_else(|| super::p4types::P4NamedType::new())
    }

    // repeated .p4.config.v1.StructuredAnnotation structured_annotations = 7;


    pub fn get_structured_annotations(&self) -> &[super::p4types::StructuredAnnotation] {
        &self.structured_annotations
    }
    pub fn clear_structured_annotations(&mut self) {
        self.structured_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_structured_annotations(&mut self, v: ::protobuf::RepeatedField<super::p4types::StructuredAnnotation>) {
        self.structured_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_structured_annotations(&mut self) -> &mut ::protobuf::RepeatedField<super::p4types::StructuredAnnotation> {
        &mut self.structured_annotations
    }

    // Take field
    pub fn take_structured_annotations(&mut self) -> ::protobuf::RepeatedField<super::p4types::StructuredAnnotation> {
        ::std::mem::replace(&mut self.structured_annotations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Action_Param {
    fn is_initialized(&self) -> bool {
        for v in &self.annotation_locations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.doc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.type_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.structured_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.annotations)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotation_locations)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bitwidth = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.doc)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.type_name)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.structured_annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.annotations {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.annotation_locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.bitwidth != 0 {
            my_size += ::protobuf::rt::value_size(4, self.bitwidth, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.doc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.type_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.structured_annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.annotations {
            os.write_string(3, &v)?;
        };
        for v in &self.annotation_locations {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.bitwidth != 0 {
            os.write_int32(4, self.bitwidth)?;
        }
        if let Some(ref v) = self.doc.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.type_name.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.structured_annotations {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Action_Param {
        Action_Param::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &Action_Param| { &m.id },
                |m: &mut Action_Param| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Action_Param| { &m.name },
                |m: &mut Action_Param| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &Action_Param| { &m.annotations },
                |m: &mut Action_Param| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::SourceLocation>>(
                "annotation_locations",
                |m: &Action_Param| { &m.annotation_locations },
                |m: &mut Action_Param| { &mut m.annotation_locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bitwidth",
                |m: &Action_Param| { &m.bitwidth },
                |m: &mut Action_Param| { &mut m.bitwidth },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Documentation>>(
                "doc",
                |m: &Action_Param| { &m.doc },
                |m: &mut Action_Param| { &mut m.doc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::P4NamedType>>(
                "type_name",
                |m: &Action_Param| { &m.type_name },
                |m: &mut Action_Param| { &mut m.type_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::StructuredAnnotation>>(
                "structured_annotations",
                |m: &Action_Param| { &m.structured_annotations },
                |m: &mut Action_Param| { &mut m.structured_annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Action_Param>(
                "Action.Param",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Action_Param {
        static instance: ::protobuf::rt::LazyV2<Action_Param> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Action_Param::new)
    }
}

impl ::protobuf::Clear for Action_Param {
    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.annotations.clear();
        self.annotation_locations.clear();
        self.bitwidth = 0;
        self.doc.clear();
        self.type_name.clear();
        self.structured_annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Action_Param {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Action_Param {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionProfile {
    // message fields
    pub preamble: ::protobuf::SingularPtrField<Preamble>,
    pub table_ids: ::std::vec::Vec<u32>,
    pub with_selector: bool,
    pub size: i64,
    pub max_group_size: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionProfile {
    fn default() -> &'a ActionProfile {
        <ActionProfile as ::protobuf::Message>::default_instance()
    }
}

impl ActionProfile {
    pub fn new() -> ActionProfile {
        ::std::default::Default::default()
    }

    // .p4.config.v1.Preamble preamble = 1;


    pub fn get_preamble(&self) -> &Preamble {
        self.preamble.as_ref().unwrap_or_else(|| <Preamble as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preamble(&mut self) {
        self.preamble.clear();
    }

    pub fn has_preamble(&self) -> bool {
        self.preamble.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preamble(&mut self, v: Preamble) {
        self.preamble = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preamble(&mut self) -> &mut Preamble {
        if self.preamble.is_none() {
            self.preamble.set_default();
        }
        self.preamble.as_mut().unwrap()
    }

    // Take field
    pub fn take_preamble(&mut self) -> Preamble {
        self.preamble.take().unwrap_or_else(|| Preamble::new())
    }

    // repeated uint32 table_ids = 2;


    pub fn get_table_ids(&self) -> &[u32] {
        &self.table_ids
    }
    pub fn clear_table_ids(&mut self) {
        self.table_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_table_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.table_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_table_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.table_ids
    }

    // Take field
    pub fn take_table_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.table_ids, ::std::vec::Vec::new())
    }

    // bool with_selector = 3;


    pub fn get_with_selector(&self) -> bool {
        self.with_selector
    }
    pub fn clear_with_selector(&mut self) {
        self.with_selector = false;
    }

    // Param is passed by value, moved
    pub fn set_with_selector(&mut self, v: bool) {
        self.with_selector = v;
    }

    // int64 size = 4;


    pub fn get_size(&self) -> i64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i64) {
        self.size = v;
    }

    // int32 max_group_size = 5;


    pub fn get_max_group_size(&self) -> i32 {
        self.max_group_size
    }
    pub fn clear_max_group_size(&mut self) {
        self.max_group_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_group_size(&mut self, v: i32) {
        self.max_group_size = v;
    }
}

impl ::protobuf::Message for ActionProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.preamble {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preamble)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.table_ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.with_selector = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_group_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preamble.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.table_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.with_selector != false {
            my_size += 2;
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(4, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_group_size != 0 {
            my_size += ::protobuf::rt::value_size(5, self.max_group_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preamble.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.table_ids {
            os.write_uint32(2, *v)?;
        };
        if self.with_selector != false {
            os.write_bool(3, self.with_selector)?;
        }
        if self.size != 0 {
            os.write_int64(4, self.size)?;
        }
        if self.max_group_size != 0 {
            os.write_int32(5, self.max_group_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionProfile {
        ActionProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Preamble>>(
                "preamble",
                |m: &ActionProfile| { &m.preamble },
                |m: &mut ActionProfile| { &mut m.preamble },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "table_ids",
                |m: &ActionProfile| { &m.table_ids },
                |m: &mut ActionProfile| { &mut m.table_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "with_selector",
                |m: &ActionProfile| { &m.with_selector },
                |m: &mut ActionProfile| { &mut m.with_selector },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size",
                |m: &ActionProfile| { &m.size },
                |m: &mut ActionProfile| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_group_size",
                |m: &ActionProfile| { &m.max_group_size },
                |m: &mut ActionProfile| { &mut m.max_group_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionProfile>(
                "ActionProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionProfile {
        static instance: ::protobuf::rt::LazyV2<ActionProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionProfile::new)
    }
}

impl ::protobuf::Clear for ActionProfile {
    fn clear(&mut self) {
        self.preamble.clear();
        self.table_ids.clear();
        self.with_selector = false;
        self.size = 0;
        self.max_group_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CounterSpec {
    // message fields
    pub unit: CounterSpec_Unit,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CounterSpec {
    fn default() -> &'a CounterSpec {
        <CounterSpec as ::protobuf::Message>::default_instance()
    }
}

impl CounterSpec {
    pub fn new() -> CounterSpec {
        ::std::default::Default::default()
    }

    // .p4.config.v1.CounterSpec.Unit unit = 1;


    pub fn get_unit(&self) -> CounterSpec_Unit {
        self.unit
    }
    pub fn clear_unit(&mut self) {
        self.unit = CounterSpec_Unit::UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_unit(&mut self, v: CounterSpec_Unit) {
        self.unit = v;
    }
}

impl ::protobuf::Message for CounterSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.unit, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.unit != CounterSpec_Unit::UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.unit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.unit != CounterSpec_Unit::UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.unit))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CounterSpec {
        CounterSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CounterSpec_Unit>>(
                "unit",
                |m: &CounterSpec| { &m.unit },
                |m: &mut CounterSpec| { &mut m.unit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CounterSpec>(
                "CounterSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CounterSpec {
        static instance: ::protobuf::rt::LazyV2<CounterSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CounterSpec::new)
    }
}

impl ::protobuf::Clear for CounterSpec {
    fn clear(&mut self) {
        self.unit = CounterSpec_Unit::UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CounterSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CounterSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CounterSpec_Unit {
    UNSPECIFIED = 0,
    BYTES = 1,
    PACKETS = 2,
    BOTH = 3,
}

impl ::protobuf::ProtobufEnum for CounterSpec_Unit {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CounterSpec_Unit> {
        match value {
            0 => ::std::option::Option::Some(CounterSpec_Unit::UNSPECIFIED),
            1 => ::std::option::Option::Some(CounterSpec_Unit::BYTES),
            2 => ::std::option::Option::Some(CounterSpec_Unit::PACKETS),
            3 => ::std::option::Option::Some(CounterSpec_Unit::BOTH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CounterSpec_Unit] = &[
            CounterSpec_Unit::UNSPECIFIED,
            CounterSpec_Unit::BYTES,
            CounterSpec_Unit::PACKETS,
            CounterSpec_Unit::BOTH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CounterSpec_Unit>("CounterSpec.Unit", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CounterSpec_Unit {
}

impl ::std::default::Default for CounterSpec_Unit {
    fn default() -> Self {
        CounterSpec_Unit::UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for CounterSpec_Unit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Counter {
    // message fields
    pub preamble: ::protobuf::SingularPtrField<Preamble>,
    pub spec: ::protobuf::SingularPtrField<CounterSpec>,
    pub size: i64,
    pub index_type_name: ::protobuf::SingularPtrField<super::p4types::P4NamedType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Counter {
    fn default() -> &'a Counter {
        <Counter as ::protobuf::Message>::default_instance()
    }
}

impl Counter {
    pub fn new() -> Counter {
        ::std::default::Default::default()
    }

    // .p4.config.v1.Preamble preamble = 1;


    pub fn get_preamble(&self) -> &Preamble {
        self.preamble.as_ref().unwrap_or_else(|| <Preamble as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preamble(&mut self) {
        self.preamble.clear();
    }

    pub fn has_preamble(&self) -> bool {
        self.preamble.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preamble(&mut self, v: Preamble) {
        self.preamble = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preamble(&mut self) -> &mut Preamble {
        if self.preamble.is_none() {
            self.preamble.set_default();
        }
        self.preamble.as_mut().unwrap()
    }

    // Take field
    pub fn take_preamble(&mut self) -> Preamble {
        self.preamble.take().unwrap_or_else(|| Preamble::new())
    }

    // .p4.config.v1.CounterSpec spec = 2;


    pub fn get_spec(&self) -> &CounterSpec {
        self.spec.as_ref().unwrap_or_else(|| <CounterSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: CounterSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut CounterSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> CounterSpec {
        self.spec.take().unwrap_or_else(|| CounterSpec::new())
    }

    // int64 size = 3;


    pub fn get_size(&self) -> i64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i64) {
        self.size = v;
    }

    // .p4.config.v1.P4NamedType index_type_name = 4;


    pub fn get_index_type_name(&self) -> &super::p4types::P4NamedType {
        self.index_type_name.as_ref().unwrap_or_else(|| <super::p4types::P4NamedType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_index_type_name(&mut self) {
        self.index_type_name.clear();
    }

    pub fn has_index_type_name(&self) -> bool {
        self.index_type_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index_type_name(&mut self, v: super::p4types::P4NamedType) {
        self.index_type_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index_type_name(&mut self) -> &mut super::p4types::P4NamedType {
        if self.index_type_name.is_none() {
            self.index_type_name.set_default();
        }
        self.index_type_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_index_type_name(&mut self) -> super::p4types::P4NamedType {
        self.index_type_name.take().unwrap_or_else(|| super::p4types::P4NamedType::new())
    }
}

impl ::protobuf::Message for Counter {
    fn is_initialized(&self) -> bool {
        for v in &self.preamble {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.index_type_name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preamble)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.index_type_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preamble.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.index_type_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preamble.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.size != 0 {
            os.write_int64(3, self.size)?;
        }
        if let Some(ref v) = self.index_type_name.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Counter {
        Counter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Preamble>>(
                "preamble",
                |m: &Counter| { &m.preamble },
                |m: &mut Counter| { &mut m.preamble },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CounterSpec>>(
                "spec",
                |m: &Counter| { &m.spec },
                |m: &mut Counter| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size",
                |m: &Counter| { &m.size },
                |m: &mut Counter| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::P4NamedType>>(
                "index_type_name",
                |m: &Counter| { &m.index_type_name },
                |m: &mut Counter| { &mut m.index_type_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Counter>(
                "Counter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Counter {
        static instance: ::protobuf::rt::LazyV2<Counter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Counter::new)
    }
}

impl ::protobuf::Clear for Counter {
    fn clear(&mut self) {
        self.preamble.clear();
        self.spec.clear();
        self.size = 0;
        self.index_type_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Counter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Counter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirectCounter {
    // message fields
    pub preamble: ::protobuf::SingularPtrField<Preamble>,
    pub spec: ::protobuf::SingularPtrField<CounterSpec>,
    pub direct_table_id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DirectCounter {
    fn default() -> &'a DirectCounter {
        <DirectCounter as ::protobuf::Message>::default_instance()
    }
}

impl DirectCounter {
    pub fn new() -> DirectCounter {
        ::std::default::Default::default()
    }

    // .p4.config.v1.Preamble preamble = 1;


    pub fn get_preamble(&self) -> &Preamble {
        self.preamble.as_ref().unwrap_or_else(|| <Preamble as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preamble(&mut self) {
        self.preamble.clear();
    }

    pub fn has_preamble(&self) -> bool {
        self.preamble.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preamble(&mut self, v: Preamble) {
        self.preamble = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preamble(&mut self) -> &mut Preamble {
        if self.preamble.is_none() {
            self.preamble.set_default();
        }
        self.preamble.as_mut().unwrap()
    }

    // Take field
    pub fn take_preamble(&mut self) -> Preamble {
        self.preamble.take().unwrap_or_else(|| Preamble::new())
    }

    // .p4.config.v1.CounterSpec spec = 2;


    pub fn get_spec(&self) -> &CounterSpec {
        self.spec.as_ref().unwrap_or_else(|| <CounterSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: CounterSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut CounterSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> CounterSpec {
        self.spec.take().unwrap_or_else(|| CounterSpec::new())
    }

    // uint32 direct_table_id = 3;


    pub fn get_direct_table_id(&self) -> u32 {
        self.direct_table_id
    }
    pub fn clear_direct_table_id(&mut self) {
        self.direct_table_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_direct_table_id(&mut self, v: u32) {
        self.direct_table_id = v;
    }
}

impl ::protobuf::Message for DirectCounter {
    fn is_initialized(&self) -> bool {
        for v in &self.preamble {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preamble)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.direct_table_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preamble.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.direct_table_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.direct_table_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preamble.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.direct_table_id != 0 {
            os.write_uint32(3, self.direct_table_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DirectCounter {
        DirectCounter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Preamble>>(
                "preamble",
                |m: &DirectCounter| { &m.preamble },
                |m: &mut DirectCounter| { &mut m.preamble },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CounterSpec>>(
                "spec",
                |m: &DirectCounter| { &m.spec },
                |m: &mut DirectCounter| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "direct_table_id",
                |m: &DirectCounter| { &m.direct_table_id },
                |m: &mut DirectCounter| { &mut m.direct_table_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DirectCounter>(
                "DirectCounter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DirectCounter {
        static instance: ::protobuf::rt::LazyV2<DirectCounter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DirectCounter::new)
    }
}

impl ::protobuf::Clear for DirectCounter {
    fn clear(&mut self) {
        self.preamble.clear();
        self.spec.clear();
        self.direct_table_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirectCounter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectCounter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MeterSpec {
    // message fields
    pub unit: MeterSpec_Unit,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MeterSpec {
    fn default() -> &'a MeterSpec {
        <MeterSpec as ::protobuf::Message>::default_instance()
    }
}

impl MeterSpec {
    pub fn new() -> MeterSpec {
        ::std::default::Default::default()
    }

    // .p4.config.v1.MeterSpec.Unit unit = 1;


    pub fn get_unit(&self) -> MeterSpec_Unit {
        self.unit
    }
    pub fn clear_unit(&mut self) {
        self.unit = MeterSpec_Unit::UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_unit(&mut self, v: MeterSpec_Unit) {
        self.unit = v;
    }
}

impl ::protobuf::Message for MeterSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.unit, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.unit != MeterSpec_Unit::UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.unit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.unit != MeterSpec_Unit::UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.unit))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MeterSpec {
        MeterSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MeterSpec_Unit>>(
                "unit",
                |m: &MeterSpec| { &m.unit },
                |m: &mut MeterSpec| { &mut m.unit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MeterSpec>(
                "MeterSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MeterSpec {
        static instance: ::protobuf::rt::LazyV2<MeterSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MeterSpec::new)
    }
}

impl ::protobuf::Clear for MeterSpec {
    fn clear(&mut self) {
        self.unit = MeterSpec_Unit::UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MeterSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MeterSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MeterSpec_Unit {
    UNSPECIFIED = 0,
    BYTES = 1,
    PACKETS = 2,
}

impl ::protobuf::ProtobufEnum for MeterSpec_Unit {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MeterSpec_Unit> {
        match value {
            0 => ::std::option::Option::Some(MeterSpec_Unit::UNSPECIFIED),
            1 => ::std::option::Option::Some(MeterSpec_Unit::BYTES),
            2 => ::std::option::Option::Some(MeterSpec_Unit::PACKETS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MeterSpec_Unit] = &[
            MeterSpec_Unit::UNSPECIFIED,
            MeterSpec_Unit::BYTES,
            MeterSpec_Unit::PACKETS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<MeterSpec_Unit>("MeterSpec.Unit", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for MeterSpec_Unit {
}

impl ::std::default::Default for MeterSpec_Unit {
    fn default() -> Self {
        MeterSpec_Unit::UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for MeterSpec_Unit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Meter {
    // message fields
    pub preamble: ::protobuf::SingularPtrField<Preamble>,
    pub spec: ::protobuf::SingularPtrField<MeterSpec>,
    pub size: i64,
    pub index_type_name: ::protobuf::SingularPtrField<super::p4types::P4NamedType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Meter {
    fn default() -> &'a Meter {
        <Meter as ::protobuf::Message>::default_instance()
    }
}

impl Meter {
    pub fn new() -> Meter {
        ::std::default::Default::default()
    }

    // .p4.config.v1.Preamble preamble = 1;


    pub fn get_preamble(&self) -> &Preamble {
        self.preamble.as_ref().unwrap_or_else(|| <Preamble as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preamble(&mut self) {
        self.preamble.clear();
    }

    pub fn has_preamble(&self) -> bool {
        self.preamble.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preamble(&mut self, v: Preamble) {
        self.preamble = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preamble(&mut self) -> &mut Preamble {
        if self.preamble.is_none() {
            self.preamble.set_default();
        }
        self.preamble.as_mut().unwrap()
    }

    // Take field
    pub fn take_preamble(&mut self) -> Preamble {
        self.preamble.take().unwrap_or_else(|| Preamble::new())
    }

    // .p4.config.v1.MeterSpec spec = 2;


    pub fn get_spec(&self) -> &MeterSpec {
        self.spec.as_ref().unwrap_or_else(|| <MeterSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: MeterSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut MeterSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> MeterSpec {
        self.spec.take().unwrap_or_else(|| MeterSpec::new())
    }

    // int64 size = 3;


    pub fn get_size(&self) -> i64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i64) {
        self.size = v;
    }

    // .p4.config.v1.P4NamedType index_type_name = 4;


    pub fn get_index_type_name(&self) -> &super::p4types::P4NamedType {
        self.index_type_name.as_ref().unwrap_or_else(|| <super::p4types::P4NamedType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_index_type_name(&mut self) {
        self.index_type_name.clear();
    }

    pub fn has_index_type_name(&self) -> bool {
        self.index_type_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index_type_name(&mut self, v: super::p4types::P4NamedType) {
        self.index_type_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index_type_name(&mut self) -> &mut super::p4types::P4NamedType {
        if self.index_type_name.is_none() {
            self.index_type_name.set_default();
        }
        self.index_type_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_index_type_name(&mut self) -> super::p4types::P4NamedType {
        self.index_type_name.take().unwrap_or_else(|| super::p4types::P4NamedType::new())
    }
}

impl ::protobuf::Message for Meter {
    fn is_initialized(&self) -> bool {
        for v in &self.preamble {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.index_type_name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preamble)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.index_type_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preamble.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.index_type_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preamble.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.size != 0 {
            os.write_int64(3, self.size)?;
        }
        if let Some(ref v) = self.index_type_name.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Meter {
        Meter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Preamble>>(
                "preamble",
                |m: &Meter| { &m.preamble },
                |m: &mut Meter| { &mut m.preamble },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MeterSpec>>(
                "spec",
                |m: &Meter| { &m.spec },
                |m: &mut Meter| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size",
                |m: &Meter| { &m.size },
                |m: &mut Meter| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::P4NamedType>>(
                "index_type_name",
                |m: &Meter| { &m.index_type_name },
                |m: &mut Meter| { &mut m.index_type_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Meter>(
                "Meter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Meter {
        static instance: ::protobuf::rt::LazyV2<Meter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Meter::new)
    }
}

impl ::protobuf::Clear for Meter {
    fn clear(&mut self) {
        self.preamble.clear();
        self.spec.clear();
        self.size = 0;
        self.index_type_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Meter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Meter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirectMeter {
    // message fields
    pub preamble: ::protobuf::SingularPtrField<Preamble>,
    pub spec: ::protobuf::SingularPtrField<MeterSpec>,
    pub direct_table_id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DirectMeter {
    fn default() -> &'a DirectMeter {
        <DirectMeter as ::protobuf::Message>::default_instance()
    }
}

impl DirectMeter {
    pub fn new() -> DirectMeter {
        ::std::default::Default::default()
    }

    // .p4.config.v1.Preamble preamble = 1;


    pub fn get_preamble(&self) -> &Preamble {
        self.preamble.as_ref().unwrap_or_else(|| <Preamble as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preamble(&mut self) {
        self.preamble.clear();
    }

    pub fn has_preamble(&self) -> bool {
        self.preamble.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preamble(&mut self, v: Preamble) {
        self.preamble = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preamble(&mut self) -> &mut Preamble {
        if self.preamble.is_none() {
            self.preamble.set_default();
        }
        self.preamble.as_mut().unwrap()
    }

    // Take field
    pub fn take_preamble(&mut self) -> Preamble {
        self.preamble.take().unwrap_or_else(|| Preamble::new())
    }

    // .p4.config.v1.MeterSpec spec = 2;


    pub fn get_spec(&self) -> &MeterSpec {
        self.spec.as_ref().unwrap_or_else(|| <MeterSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: MeterSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut MeterSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> MeterSpec {
        self.spec.take().unwrap_or_else(|| MeterSpec::new())
    }

    // uint32 direct_table_id = 3;


    pub fn get_direct_table_id(&self) -> u32 {
        self.direct_table_id
    }
    pub fn clear_direct_table_id(&mut self) {
        self.direct_table_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_direct_table_id(&mut self, v: u32) {
        self.direct_table_id = v;
    }
}

impl ::protobuf::Message for DirectMeter {
    fn is_initialized(&self) -> bool {
        for v in &self.preamble {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preamble)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.direct_table_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preamble.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.direct_table_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.direct_table_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preamble.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.direct_table_id != 0 {
            os.write_uint32(3, self.direct_table_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DirectMeter {
        DirectMeter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Preamble>>(
                "preamble",
                |m: &DirectMeter| { &m.preamble },
                |m: &mut DirectMeter| { &mut m.preamble },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MeterSpec>>(
                "spec",
                |m: &DirectMeter| { &m.spec },
                |m: &mut DirectMeter| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "direct_table_id",
                |m: &DirectMeter| { &m.direct_table_id },
                |m: &mut DirectMeter| { &mut m.direct_table_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DirectMeter>(
                "DirectMeter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DirectMeter {
        static instance: ::protobuf::rt::LazyV2<DirectMeter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DirectMeter::new)
    }
}

impl ::protobuf::Clear for DirectMeter {
    fn clear(&mut self) {
        self.preamble.clear();
        self.spec.clear();
        self.direct_table_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirectMeter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectMeter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ControllerPacketMetadata {
    // message fields
    pub preamble: ::protobuf::SingularPtrField<Preamble>,
    pub metadata: ::protobuf::RepeatedField<ControllerPacketMetadata_Metadata>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ControllerPacketMetadata {
    fn default() -> &'a ControllerPacketMetadata {
        <ControllerPacketMetadata as ::protobuf::Message>::default_instance()
    }
}

impl ControllerPacketMetadata {
    pub fn new() -> ControllerPacketMetadata {
        ::std::default::Default::default()
    }

    // .p4.config.v1.Preamble preamble = 1;


    pub fn get_preamble(&self) -> &Preamble {
        self.preamble.as_ref().unwrap_or_else(|| <Preamble as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preamble(&mut self) {
        self.preamble.clear();
    }

    pub fn has_preamble(&self) -> bool {
        self.preamble.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preamble(&mut self, v: Preamble) {
        self.preamble = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preamble(&mut self) -> &mut Preamble {
        if self.preamble.is_none() {
            self.preamble.set_default();
        }
        self.preamble.as_mut().unwrap()
    }

    // Take field
    pub fn take_preamble(&mut self) -> Preamble {
        self.preamble.take().unwrap_or_else(|| Preamble::new())
    }

    // repeated .p4.config.v1.ControllerPacketMetadata.Metadata metadata = 2;


    pub fn get_metadata(&self) -> &[ControllerPacketMetadata_Metadata] {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::RepeatedField<ControllerPacketMetadata_Metadata>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::RepeatedField<ControllerPacketMetadata_Metadata> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::RepeatedField<ControllerPacketMetadata_Metadata> {
        ::std::mem::replace(&mut self.metadata, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ControllerPacketMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.preamble {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preamble)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preamble.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preamble.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.metadata {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ControllerPacketMetadata {
        ControllerPacketMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Preamble>>(
                "preamble",
                |m: &ControllerPacketMetadata| { &m.preamble },
                |m: &mut ControllerPacketMetadata| { &mut m.preamble },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ControllerPacketMetadata_Metadata>>(
                "metadata",
                |m: &ControllerPacketMetadata| { &m.metadata },
                |m: &mut ControllerPacketMetadata| { &mut m.metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ControllerPacketMetadata>(
                "ControllerPacketMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ControllerPacketMetadata {
        static instance: ::protobuf::rt::LazyV2<ControllerPacketMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ControllerPacketMetadata::new)
    }
}

impl ::protobuf::Clear for ControllerPacketMetadata {
    fn clear(&mut self) {
        self.preamble.clear();
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControllerPacketMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControllerPacketMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ControllerPacketMetadata_Metadata {
    // message fields
    pub id: u32,
    pub name: ::std::string::String,
    pub annotations: ::protobuf::RepeatedField<::std::string::String>,
    pub annotation_locations: ::protobuf::RepeatedField<super::p4types::SourceLocation>,
    pub bitwidth: i32,
    pub type_name: ::protobuf::SingularPtrField<super::p4types::P4NamedType>,
    pub structured_annotations: ::protobuf::RepeatedField<super::p4types::StructuredAnnotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ControllerPacketMetadata_Metadata {
    fn default() -> &'a ControllerPacketMetadata_Metadata {
        <ControllerPacketMetadata_Metadata as ::protobuf::Message>::default_instance()
    }
}

impl ControllerPacketMetadata_Metadata {
    pub fn new() -> ControllerPacketMetadata_Metadata {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated string annotations = 3;


    pub fn get_annotations(&self) -> &[::std::string::String] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.SourceLocation annotation_locations = 7;


    pub fn get_annotation_locations(&self) -> &[super::p4types::SourceLocation] {
        &self.annotation_locations
    }
    pub fn clear_annotation_locations(&mut self) {
        self.annotation_locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_locations(&mut self, v: ::protobuf::RepeatedField<super::p4types::SourceLocation>) {
        self.annotation_locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotation_locations(&mut self) -> &mut ::protobuf::RepeatedField<super::p4types::SourceLocation> {
        &mut self.annotation_locations
    }

    // Take field
    pub fn take_annotation_locations(&mut self) -> ::protobuf::RepeatedField<super::p4types::SourceLocation> {
        ::std::mem::replace(&mut self.annotation_locations, ::protobuf::RepeatedField::new())
    }

    // int32 bitwidth = 4;


    pub fn get_bitwidth(&self) -> i32 {
        self.bitwidth
    }
    pub fn clear_bitwidth(&mut self) {
        self.bitwidth = 0;
    }

    // Param is passed by value, moved
    pub fn set_bitwidth(&mut self, v: i32) {
        self.bitwidth = v;
    }

    // .p4.config.v1.P4NamedType type_name = 5;


    pub fn get_type_name(&self) -> &super::p4types::P4NamedType {
        self.type_name.as_ref().unwrap_or_else(|| <super::p4types::P4NamedType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_type_name(&mut self) {
        self.type_name.clear();
    }

    pub fn has_type_name(&self) -> bool {
        self.type_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_name(&mut self, v: super::p4types::P4NamedType) {
        self.type_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_name(&mut self) -> &mut super::p4types::P4NamedType {
        if self.type_name.is_none() {
            self.type_name.set_default();
        }
        self.type_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_name(&mut self) -> super::p4types::P4NamedType {
        self.type_name.take().unwrap_or_else(|| super::p4types::P4NamedType::new())
    }

    // repeated .p4.config.v1.StructuredAnnotation structured_annotations = 6;


    pub fn get_structured_annotations(&self) -> &[super::p4types::StructuredAnnotation] {
        &self.structured_annotations
    }
    pub fn clear_structured_annotations(&mut self) {
        self.structured_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_structured_annotations(&mut self, v: ::protobuf::RepeatedField<super::p4types::StructuredAnnotation>) {
        self.structured_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_structured_annotations(&mut self) -> &mut ::protobuf::RepeatedField<super::p4types::StructuredAnnotation> {
        &mut self.structured_annotations
    }

    // Take field
    pub fn take_structured_annotations(&mut self) -> ::protobuf::RepeatedField<super::p4types::StructuredAnnotation> {
        ::std::mem::replace(&mut self.structured_annotations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ControllerPacketMetadata_Metadata {
    fn is_initialized(&self) -> bool {
        for v in &self.annotation_locations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.type_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.structured_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.annotations)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotation_locations)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bitwidth = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.type_name)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.structured_annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.annotations {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.annotation_locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.bitwidth != 0 {
            my_size += ::protobuf::rt::value_size(4, self.bitwidth, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.type_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.structured_annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.annotations {
            os.write_string(3, &v)?;
        };
        for v in &self.annotation_locations {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.bitwidth != 0 {
            os.write_int32(4, self.bitwidth)?;
        }
        if let Some(ref v) = self.type_name.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.structured_annotations {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ControllerPacketMetadata_Metadata {
        ControllerPacketMetadata_Metadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &ControllerPacketMetadata_Metadata| { &m.id },
                |m: &mut ControllerPacketMetadata_Metadata| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ControllerPacketMetadata_Metadata| { &m.name },
                |m: &mut ControllerPacketMetadata_Metadata| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &ControllerPacketMetadata_Metadata| { &m.annotations },
                |m: &mut ControllerPacketMetadata_Metadata| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::SourceLocation>>(
                "annotation_locations",
                |m: &ControllerPacketMetadata_Metadata| { &m.annotation_locations },
                |m: &mut ControllerPacketMetadata_Metadata| { &mut m.annotation_locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bitwidth",
                |m: &ControllerPacketMetadata_Metadata| { &m.bitwidth },
                |m: &mut ControllerPacketMetadata_Metadata| { &mut m.bitwidth },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::P4NamedType>>(
                "type_name",
                |m: &ControllerPacketMetadata_Metadata| { &m.type_name },
                |m: &mut ControllerPacketMetadata_Metadata| { &mut m.type_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::StructuredAnnotation>>(
                "structured_annotations",
                |m: &ControllerPacketMetadata_Metadata| { &m.structured_annotations },
                |m: &mut ControllerPacketMetadata_Metadata| { &mut m.structured_annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ControllerPacketMetadata_Metadata>(
                "ControllerPacketMetadata.Metadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ControllerPacketMetadata_Metadata {
        static instance: ::protobuf::rt::LazyV2<ControllerPacketMetadata_Metadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ControllerPacketMetadata_Metadata::new)
    }
}

impl ::protobuf::Clear for ControllerPacketMetadata_Metadata {
    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.annotations.clear();
        self.annotation_locations.clear();
        self.bitwidth = 0;
        self.type_name.clear();
        self.structured_annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControllerPacketMetadata_Metadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControllerPacketMetadata_Metadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValueSet {
    // message fields
    pub preamble: ::protobuf::SingularPtrField<Preamble>,
    pub field_match: ::protobuf::RepeatedField<MatchField>,
    pub size: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValueSet {
    fn default() -> &'a ValueSet {
        <ValueSet as ::protobuf::Message>::default_instance()
    }
}

impl ValueSet {
    pub fn new() -> ValueSet {
        ::std::default::Default::default()
    }

    // .p4.config.v1.Preamble preamble = 1;


    pub fn get_preamble(&self) -> &Preamble {
        self.preamble.as_ref().unwrap_or_else(|| <Preamble as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preamble(&mut self) {
        self.preamble.clear();
    }

    pub fn has_preamble(&self) -> bool {
        self.preamble.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preamble(&mut self, v: Preamble) {
        self.preamble = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preamble(&mut self) -> &mut Preamble {
        if self.preamble.is_none() {
            self.preamble.set_default();
        }
        self.preamble.as_mut().unwrap()
    }

    // Take field
    pub fn take_preamble(&mut self) -> Preamble {
        self.preamble.take().unwrap_or_else(|| Preamble::new())
    }

    // repeated .p4.config.v1.MatchField match = 2;


    pub fn get_field_match(&self) -> &[MatchField] {
        &self.field_match
    }
    pub fn clear_field_match(&mut self) {
        self.field_match.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_match(&mut self, v: ::protobuf::RepeatedField<MatchField>) {
        self.field_match = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field_match(&mut self) -> &mut ::protobuf::RepeatedField<MatchField> {
        &mut self.field_match
    }

    // Take field
    pub fn take_field_match(&mut self) -> ::protobuf::RepeatedField<MatchField> {
        ::std::mem::replace(&mut self.field_match, ::protobuf::RepeatedField::new())
    }

    // int32 size = 3;


    pub fn get_size(&self) -> i32 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i32) {
        self.size = v;
    }
}

impl ::protobuf::Message for ValueSet {
    fn is_initialized(&self) -> bool {
        for v in &self.preamble {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_match {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preamble)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.field_match)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preamble.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.field_match {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preamble.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.field_match {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.size != 0 {
            os.write_int32(3, self.size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValueSet {
        ValueSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Preamble>>(
                "preamble",
                |m: &ValueSet| { &m.preamble },
                |m: &mut ValueSet| { &mut m.preamble },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatchField>>(
                "match",
                |m: &ValueSet| { &m.field_match },
                |m: &mut ValueSet| { &mut m.field_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "size",
                |m: &ValueSet| { &m.size },
                |m: &mut ValueSet| { &mut m.size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ValueSet>(
                "ValueSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ValueSet {
        static instance: ::protobuf::rt::LazyV2<ValueSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ValueSet::new)
    }
}

impl ::protobuf::Clear for ValueSet {
    fn clear(&mut self) {
        self.preamble.clear();
        self.field_match.clear();
        self.size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValueSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValueSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Register {
    // message fields
    pub preamble: ::protobuf::SingularPtrField<Preamble>,
    pub type_spec: ::protobuf::SingularPtrField<super::p4types::P4DataTypeSpec>,
    pub size: i32,
    pub index_type_name: ::protobuf::SingularPtrField<super::p4types::P4NamedType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Register {
    fn default() -> &'a Register {
        <Register as ::protobuf::Message>::default_instance()
    }
}

impl Register {
    pub fn new() -> Register {
        ::std::default::Default::default()
    }

    // .p4.config.v1.Preamble preamble = 1;


    pub fn get_preamble(&self) -> &Preamble {
        self.preamble.as_ref().unwrap_or_else(|| <Preamble as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preamble(&mut self) {
        self.preamble.clear();
    }

    pub fn has_preamble(&self) -> bool {
        self.preamble.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preamble(&mut self, v: Preamble) {
        self.preamble = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preamble(&mut self) -> &mut Preamble {
        if self.preamble.is_none() {
            self.preamble.set_default();
        }
        self.preamble.as_mut().unwrap()
    }

    // Take field
    pub fn take_preamble(&mut self) -> Preamble {
        self.preamble.take().unwrap_or_else(|| Preamble::new())
    }

    // .p4.config.v1.P4DataTypeSpec type_spec = 2;


    pub fn get_type_spec(&self) -> &super::p4types::P4DataTypeSpec {
        self.type_spec.as_ref().unwrap_or_else(|| <super::p4types::P4DataTypeSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_type_spec(&mut self) {
        self.type_spec.clear();
    }

    pub fn has_type_spec(&self) -> bool {
        self.type_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_spec(&mut self, v: super::p4types::P4DataTypeSpec) {
        self.type_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_spec(&mut self) -> &mut super::p4types::P4DataTypeSpec {
        if self.type_spec.is_none() {
            self.type_spec.set_default();
        }
        self.type_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_spec(&mut self) -> super::p4types::P4DataTypeSpec {
        self.type_spec.take().unwrap_or_else(|| super::p4types::P4DataTypeSpec::new())
    }

    // int32 size = 3;


    pub fn get_size(&self) -> i32 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i32) {
        self.size = v;
    }

    // .p4.config.v1.P4NamedType index_type_name = 4;


    pub fn get_index_type_name(&self) -> &super::p4types::P4NamedType {
        self.index_type_name.as_ref().unwrap_or_else(|| <super::p4types::P4NamedType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_index_type_name(&mut self) {
        self.index_type_name.clear();
    }

    pub fn has_index_type_name(&self) -> bool {
        self.index_type_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index_type_name(&mut self, v: super::p4types::P4NamedType) {
        self.index_type_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index_type_name(&mut self) -> &mut super::p4types::P4NamedType {
        if self.index_type_name.is_none() {
            self.index_type_name.set_default();
        }
        self.index_type_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_index_type_name(&mut self) -> super::p4types::P4NamedType {
        self.index_type_name.take().unwrap_or_else(|| super::p4types::P4NamedType::new())
    }
}

impl ::protobuf::Message for Register {
    fn is_initialized(&self) -> bool {
        for v in &self.preamble {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.type_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.index_type_name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preamble)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.type_spec)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.index_type_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preamble.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.type_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.index_type_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preamble.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.type_spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.size != 0 {
            os.write_int32(3, self.size)?;
        }
        if let Some(ref v) = self.index_type_name.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Register {
        Register::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Preamble>>(
                "preamble",
                |m: &Register| { &m.preamble },
                |m: &mut Register| { &mut m.preamble },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::P4DataTypeSpec>>(
                "type_spec",
                |m: &Register| { &m.type_spec },
                |m: &mut Register| { &mut m.type_spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "size",
                |m: &Register| { &m.size },
                |m: &mut Register| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::P4NamedType>>(
                "index_type_name",
                |m: &Register| { &m.index_type_name },
                |m: &mut Register| { &mut m.index_type_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Register>(
                "Register",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Register {
        static instance: ::protobuf::rt::LazyV2<Register> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Register::new)
    }
}

impl ::protobuf::Clear for Register {
    fn clear(&mut self) {
        self.preamble.clear();
        self.type_spec.clear();
        self.size = 0;
        self.index_type_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Register {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Register {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Digest {
    // message fields
    pub preamble: ::protobuf::SingularPtrField<Preamble>,
    pub type_spec: ::protobuf::SingularPtrField<super::p4types::P4DataTypeSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Digest {
    fn default() -> &'a Digest {
        <Digest as ::protobuf::Message>::default_instance()
    }
}

impl Digest {
    pub fn new() -> Digest {
        ::std::default::Default::default()
    }

    // .p4.config.v1.Preamble preamble = 1;


    pub fn get_preamble(&self) -> &Preamble {
        self.preamble.as_ref().unwrap_or_else(|| <Preamble as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preamble(&mut self) {
        self.preamble.clear();
    }

    pub fn has_preamble(&self) -> bool {
        self.preamble.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preamble(&mut self, v: Preamble) {
        self.preamble = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preamble(&mut self) -> &mut Preamble {
        if self.preamble.is_none() {
            self.preamble.set_default();
        }
        self.preamble.as_mut().unwrap()
    }

    // Take field
    pub fn take_preamble(&mut self) -> Preamble {
        self.preamble.take().unwrap_or_else(|| Preamble::new())
    }

    // .p4.config.v1.P4DataTypeSpec type_spec = 2;


    pub fn get_type_spec(&self) -> &super::p4types::P4DataTypeSpec {
        self.type_spec.as_ref().unwrap_or_else(|| <super::p4types::P4DataTypeSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_type_spec(&mut self) {
        self.type_spec.clear();
    }

    pub fn has_type_spec(&self) -> bool {
        self.type_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_spec(&mut self, v: super::p4types::P4DataTypeSpec) {
        self.type_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_spec(&mut self) -> &mut super::p4types::P4DataTypeSpec {
        if self.type_spec.is_none() {
            self.type_spec.set_default();
        }
        self.type_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_spec(&mut self) -> super::p4types::P4DataTypeSpec {
        self.type_spec.take().unwrap_or_else(|| super::p4types::P4DataTypeSpec::new())
    }
}

impl ::protobuf::Message for Digest {
    fn is_initialized(&self) -> bool {
        for v in &self.preamble {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.type_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preamble)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.type_spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preamble.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.type_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preamble.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.type_spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Digest {
        Digest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Preamble>>(
                "preamble",
                |m: &Digest| { &m.preamble },
                |m: &mut Digest| { &mut m.preamble },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::p4types::P4DataTypeSpec>>(
                "type_spec",
                |m: &Digest| { &m.type_spec },
                |m: &mut Digest| { &mut m.type_spec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Digest>(
                "Digest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Digest {
        static instance: ::protobuf::rt::LazyV2<Digest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Digest::new)
    }
}

impl ::protobuf::Clear for Digest {
    fn clear(&mut self) {
        self.preamble.clear();
        self.type_spec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Digest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Digest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x19p4/config/v1/p4info.proto\x12\x0cp4.config.v1\x1a\x19google/protob\
    uf/any.proto\x1a\x1ap4/config/v1/p4types.proto\"\xae\x06\n\x06P4Info\x12\
    0\n\x08pkg_info\x18\x01\x20\x01(\x0b2\x15.p4.config.v1.PkgInfoR\x07pkgIn\
    fo\x12+\n\x06tables\x18\x02\x20\x03(\x0b2\x13.p4.config.v1.TableR\x06tab\
    les\x12.\n\x07actions\x18\x03\x20\x03(\x0b2\x14.p4.config.v1.ActionR\x07\
    actions\x12D\n\x0faction_profiles\x18\x04\x20\x03(\x0b2\x1b.p4.config.v1\
    .ActionProfileR\x0eactionProfiles\x121\n\x08counters\x18\x05\x20\x03(\
    \x0b2\x15.p4.config.v1.CounterR\x08counters\x12D\n\x0fdirect_counters\
    \x18\x06\x20\x03(\x0b2\x1b.p4.config.v1.DirectCounterR\x0edirectCounters\
    \x12+\n\x06meters\x18\x07\x20\x03(\x0b2\x13.p4.config.v1.MeterR\x06meter\
    s\x12>\n\rdirect_meters\x18\x08\x20\x03(\x0b2\x19.p4.config.v1.DirectMet\
    erR\x0cdirectMeters\x12d\n\x1acontroller_packet_metadata\x18\t\x20\x03(\
    \x0b2&.p4.config.v1.ControllerPacketMetadataR\x18controllerPacketMetadat\
    a\x125\n\nvalue_sets\x18\n\x20\x03(\x0b2\x16.p4.config.v1.ValueSetR\tval\
    ueSets\x124\n\tregisters\x18\x0b\x20\x03(\x0b2\x16.p4.config.v1.Register\
    R\tregisters\x12.\n\x07digests\x18\x0c\x20\x03(\x0b2\x14.p4.config.v1.Di\
    gestR\x07digests\x12.\n\x07externs\x18d\x20\x03(\x0b2\x14.p4.config.v1.E\
    xternR\x07externs\x126\n\ttype_info\x18\xc8\x01\x20\x01(\x0b2\x18.p4.con\
    fig.v1.P4TypeInfoR\x08typeInfo\"G\n\rDocumentation\x12\x14\n\x05brief\
    \x18\x01\x20\x01(\tR\x05brief\x12\x20\n\x0bdescription\x18\x02\x20\x01(\
    \tR\x0bdescription\"\x98\x03\n\x07PkgInfo\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x18\n\x07version\x18\x02\x20\x01(\tR\x07version\x12\
    -\n\x03doc\x18\x03\x20\x01(\x0b2\x1b.p4.config.v1.DocumentationR\x03doc\
    \x12\x20\n\x0bannotations\x18\x04\x20\x03(\tR\x0bannotations\x12O\n\x14a\
    nnotation_locations\x18\n\x20\x03(\x0b2\x1c.p4.config.v1.SourceLocationR\
    \x13annotationLocations\x12\x12\n\x04arch\x18\x05\x20\x01(\tR\x04arch\
    \x12\"\n\x0corganization\x18\x06\x20\x01(\tR\x0corganization\x12\x18\n\
    \x07contact\x18\x07\x20\x01(\tR\x07contact\x12\x10\n\x03url\x18\x08\x20\
    \x01(\tR\x03url\x12Y\n\x16structured_annotations\x18\t\x20\x03(\x0b2\".p\
    4.config.v1.StructuredAnnotationR\x15structuredAnnotations\"\x87\x02\n\
    \x05P4Ids\"\xfd\x01\n\x06Prefix\x12\x0f\n\x0bUNSPECIFIED\x10\0\x12\n\n\
    \x06ACTION\x10\x01\x12\t\n\x05TABLE\x10\x02\x12\r\n\tVALUE_SET\x10\x03\
    \x12\x15\n\x11CONTROLLER_HEADER\x10\x04\x12\x15\n\x11PSA_EXTERNS_START\
    \x10\x10\x12\x12\n\x0eACTION_PROFILE\x10\x11\x12\x0b\n\x07COUNTER\x10\
    \x12\x12\x12\n\x0eDIRECT_COUNTER\x10\x13\x12\t\n\x05METER\x10\x14\x12\
    \x10\n\x0cDIRECT_METER\x10\x15\x12\x0c\n\x08REGISTER\x10\x16\x12\n\n\x06\
    DIGEST\x10\x17\x12\x18\n\x13OTHER_EXTERNS_START\x10\x80\x01\x12\x08\n\
    \x03MAX\x10\xff\x01\"\xc1\x02\n\x08Preamble\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\rR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x14\n\
    \x05alias\x18\x03\x20\x01(\tR\x05alias\x12\x20\n\x0bannotations\x18\x04\
    \x20\x03(\tR\x0bannotations\x12O\n\x14annotation_locations\x18\x07\x20\
    \x03(\x0b2\x1c.p4.config.v1.SourceLocationR\x13annotationLocations\x12-\
    \n\x03doc\x18\x05\x20\x01(\x0b2\x1b.p4.config.v1.DocumentationR\x03doc\
    \x12Y\n\x16structured_annotations\x18\x06\x20\x03(\x0b2\".p4.config.v1.S\
    tructuredAnnotationR\x15structuredAnnotations\"\x94\x01\n\x06Extern\x12$\
    \n\x0eextern_type_id\x18\x01\x20\x01(\rR\x0cexternTypeId\x12(\n\x10exter\
    n_type_name\x18\x02\x20\x01(\tR\x0eexternTypeName\x12:\n\tinstances\x18\
    \x03\x20\x03(\x0b2\x1c.p4.config.v1.ExternInstanceR\tinstances\"n\n\x0eE\
    xternInstance\x122\n\x08preamble\x18\x01\x20\x01(\x0b2\x16.p4.config.v1.\
    PreambleR\x08preamble\x12(\n\x04info\x18\x02\x20\x01(\x0b2\x14.google.pr\
    otobuf.AnyR\x04info\"\xd3\x04\n\nMatchField\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\rR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x20\n\
    \x0bannotations\x18\x03\x20\x03(\tR\x0bannotations\x12O\n\x14annotation_\
    locations\x18\n\x20\x03(\x0b2\x1c.p4.config.v1.SourceLocationR\x13annota\
    tionLocations\x12\x1a\n\x08bitwidth\x18\x04\x20\x01(\x05R\x08bitwidth\
    \x12C\n\nmatch_type\x18\x05\x20\x01(\x0e2\".p4.config.v1.MatchField.Matc\
    hTypeH\0R\tmatchType\x12*\n\x10other_match_type\x18\x07\x20\x01(\tH\0R\
    \x0eotherMatchType\x12-\n\x03doc\x18\x06\x20\x01(\x0b2\x1b.p4.config.v1.\
    DocumentationR\x03doc\x126\n\ttype_name\x18\x08\x20\x01(\x0b2\x19.p4.con\
    fig.v1.P4NamedTypeR\x08typeName\x12Y\n\x16structured_annotations\x18\t\
    \x20\x03(\x0b2\".p4.config.v1.StructuredAnnotationR\x15structuredAnnotat\
    ions\"V\n\tMatchType\x12\x0f\n\x0bUNSPECIFIED\x10\0\x12\t\n\x05EXACT\x10\
    \x02\x12\x07\n\x03LPM\x10\x03\x12\x0b\n\x07TERNARY\x10\x04\x12\t\n\x05RA\
    NGE\x10\x05\x12\x0c\n\x08OPTIONAL\x10\x06B\x07\n\x05match\"\xd9\x04\n\
    \x05Table\x122\n\x08preamble\x18\x01\x20\x01(\x0b2\x16.p4.config.v1.Prea\
    mbleR\x08preamble\x12;\n\x0cmatch_fields\x18\x02\x20\x03(\x0b2\x18.p4.co\
    nfig.v1.MatchFieldR\x0bmatchFields\x128\n\x0baction_refs\x18\x03\x20\x03\
    (\x0b2\x17.p4.config.v1.ActionRefR\nactionRefs\x125\n\x17const_default_a\
    ction_id\x18\x04\x20\x01(\rR\x14constDefaultActionId\x12+\n\x11implement\
    ation_id\x18\x06\x20\x01(\rR\x10implementationId\x12.\n\x13direct_resour\
    ce_ids\x18\x07\x20\x03(\rR\x11directResourceIds\x12\x12\n\x04size\x18\
    \x08\x20\x01(\x03R\x04size\x12[\n\x15idle_timeout_behavior\x18\t\x20\x01\
    (\x0e2'.p4.config.v1.Table.IdleTimeoutBehaviorR\x13idleTimeoutBehavior\
    \x12$\n\x0eis_const_table\x18\n\x20\x01(\x08R\x0cisConstTable\x12?\n\x10\
    other_properties\x18d\x20\x01(\x0b2\x14.google.protobuf.AnyR\x0fotherPro\
    perties\"9\n\x13IdleTimeoutBehavior\x12\x0e\n\nNO_TIMEOUT\x10\0\x12\x12\
    \n\x0eNOTIFY_CONTROL\x10\x01\"\xe0\x02\n\tActionRef\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\rR\x02id\x123\n\x05scope\x18\x03\x20\x01(\x0e2\x1d.p4.conf\
    ig.v1.ActionRef.ScopeR\x05scope\x12\x20\n\x0bannotations\x18\x02\x20\x03\
    (\tR\x0bannotations\x12O\n\x14annotation_locations\x18\x05\x20\x03(\x0b2\
    \x1c.p4.config.v1.SourceLocationR\x13annotationLocations\x12Y\n\x16struc\
    tured_annotations\x18\x04\x20\x03(\x0b2\".p4.config.v1.StructuredAnnotat\
    ionR\x15structuredAnnotations\"@\n\x05Scope\x12\x15\n\x11TABLE_AND_DEFAU\
    LT\x10\0\x12\x0e\n\nTABLE_ONLY\x10\x01\x12\x10\n\x0cDEFAULT_ONLY\x10\x02\
    \"\xef\x03\n\x06Action\x122\n\x08preamble\x18\x01\x20\x01(\x0b2\x16.p4.c\
    onfig.v1.PreambleR\x08preamble\x122\n\x06params\x18\x02\x20\x03(\x0b2\
    \x1a.p4.config.v1.Action.ParamR\x06params\x1a\xfc\x02\n\x05Param\x12\x0e\
    \n\x02id\x18\x01\x20\x01(\rR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\x12\x20\n\x0bannotations\x18\x03\x20\x03(\tR\x0bannotations\x12\
    O\n\x14annotation_locations\x18\x08\x20\x03(\x0b2\x1c.p4.config.v1.Sourc\
    eLocationR\x13annotationLocations\x12\x1a\n\x08bitwidth\x18\x04\x20\x01(\
    \x05R\x08bitwidth\x12-\n\x03doc\x18\x05\x20\x01(\x0b2\x1b.p4.config.v1.D\
    ocumentationR\x03doc\x126\n\ttype_name\x18\x06\x20\x01(\x0b2\x19.p4.conf\
    ig.v1.P4NamedTypeR\x08typeName\x12Y\n\x16structured_annotations\x18\x07\
    \x20\x03(\x0b2\".p4.config.v1.StructuredAnnotationR\x15structuredAnnotat\
    ions\"\xbf\x01\n\rActionProfile\x122\n\x08preamble\x18\x01\x20\x01(\x0b2\
    \x16.p4.config.v1.PreambleR\x08preamble\x12\x1b\n\ttable_ids\x18\x02\x20\
    \x03(\rR\x08tableIds\x12#\n\rwith_selector\x18\x03\x20\x01(\x08R\x0cwith\
    Selector\x12\x12\n\x04size\x18\x04\x20\x01(\x03R\x04size\x12$\n\x0emax_g\
    roup_size\x18\x05\x20\x01(\x05R\x0cmaxGroupSize\"|\n\x0bCounterSpec\x122\
    \n\x04unit\x18\x01\x20\x01(\x0e2\x1e.p4.config.v1.CounterSpec.UnitR\x04u\
    nit\"9\n\x04Unit\x12\x0f\n\x0bUNSPECIFIED\x10\0\x12\t\n\x05BYTES\x10\x01\
    \x12\x0b\n\x07PACKETS\x10\x02\x12\x08\n\x04BOTH\x10\x03\"\xc3\x01\n\x07C\
    ounter\x122\n\x08preamble\x18\x01\x20\x01(\x0b2\x16.p4.config.v1.Preambl\
    eR\x08preamble\x12-\n\x04spec\x18\x02\x20\x01(\x0b2\x19.p4.config.v1.Cou\
    nterSpecR\x04spec\x12\x12\n\x04size\x18\x03\x20\x01(\x03R\x04size\x12A\n\
    \x0findex_type_name\x18\x04\x20\x01(\x0b2\x19.p4.config.v1.P4NamedTypeR\
    \rindexTypeName\"\x9a\x01\n\rDirectCounter\x122\n\x08preamble\x18\x01\
    \x20\x01(\x0b2\x16.p4.config.v1.PreambleR\x08preamble\x12-\n\x04spec\x18\
    \x02\x20\x01(\x0b2\x19.p4.config.v1.CounterSpecR\x04spec\x12&\n\x0fdirec\
    t_table_id\x18\x03\x20\x01(\rR\rdirectTableId\"n\n\tMeterSpec\x120\n\x04\
    unit\x18\x01\x20\x01(\x0e2\x1c.p4.config.v1.MeterSpec.UnitR\x04unit\"/\n\
    \x04Unit\x12\x0f\n\x0bUNSPECIFIED\x10\0\x12\t\n\x05BYTES\x10\x01\x12\x0b\
    \n\x07PACKETS\x10\x02\"\xbf\x01\n\x05Meter\x122\n\x08preamble\x18\x01\
    \x20\x01(\x0b2\x16.p4.config.v1.PreambleR\x08preamble\x12+\n\x04spec\x18\
    \x02\x20\x01(\x0b2\x17.p4.config.v1.MeterSpecR\x04spec\x12\x12\n\x04size\
    \x18\x03\x20\x01(\x03R\x04size\x12A\n\x0findex_type_name\x18\x04\x20\x01\
    (\x0b2\x19.p4.config.v1.P4NamedTypeR\rindexTypeName\"\x96\x01\n\x0bDirec\
    tMeter\x122\n\x08preamble\x18\x01\x20\x01(\x0b2\x16.p4.config.v1.Preambl\
    eR\x08preamble\x12+\n\x04spec\x18\x02\x20\x01(\x0b2\x17.p4.config.v1.Met\
    erSpecR\x04spec\x12&\n\x0fdirect_table_id\x18\x03\x20\x01(\rR\rdirectTab\
    leId\"\xee\x03\n\x18ControllerPacketMetadata\x122\n\x08preamble\x18\x01\
    \x20\x01(\x0b2\x16.p4.config.v1.PreambleR\x08preamble\x12K\n\x08metadata\
    \x18\x02\x20\x03(\x0b2/.p4.config.v1.ControllerPacketMetadata.MetadataR\
    \x08metadata\x1a\xd0\x02\n\x08Metadata\x12\x0e\n\x02id\x18\x01\x20\x01(\
    \rR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x20\n\x0bann\
    otations\x18\x03\x20\x03(\tR\x0bannotations\x12O\n\x14annotation_locatio\
    ns\x18\x07\x20\x03(\x0b2\x1c.p4.config.v1.SourceLocationR\x13annotationL\
    ocations\x12\x1a\n\x08bitwidth\x18\x04\x20\x01(\x05R\x08bitwidth\x126\n\
    \ttype_name\x18\x05\x20\x01(\x0b2\x19.p4.config.v1.P4NamedTypeR\x08typeN\
    ame\x12Y\n\x16structured_annotations\x18\x06\x20\x03(\x0b2\".p4.config.v\
    1.StructuredAnnotationR\x15structuredAnnotations\"\x82\x01\n\x08ValueSet\
    \x122\n\x08preamble\x18\x01\x20\x01(\x0b2\x16.p4.config.v1.PreambleR\x08\
    preamble\x12.\n\x05match\x18\x02\x20\x03(\x0b2\x18.p4.config.v1.MatchFie\
    ldR\x05match\x12\x12\n\x04size\x18\x03\x20\x01(\x05R\x04size\"\xd0\x01\n\
    \x08Register\x122\n\x08preamble\x18\x01\x20\x01(\x0b2\x16.p4.config.v1.P\
    reambleR\x08preamble\x129\n\ttype_spec\x18\x02\x20\x01(\x0b2\x1c.p4.conf\
    ig.v1.P4DataTypeSpecR\x08typeSpec\x12\x12\n\x04size\x18\x03\x20\x01(\x05\
    R\x04size\x12A\n\x0findex_type_name\x18\x04\x20\x01(\x0b2\x19.p4.config.\
    v1.P4NamedTypeR\rindexTypeName\"w\n\x06Digest\x122\n\x08preamble\x18\x01\
    \x20\x01(\x0b2\x16.p4.config.v1.PreambleR\x08preamble\x129\n\ttype_spec\
    \x18\x02\x20\x01(\x0b2\x1c.p4.config.v1.P4DataTypeSpecR\x08typeSpecB-Z+g\
    ithub.com/p4lang/p4runtime/go/p4/config/v1b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
