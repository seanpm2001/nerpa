// This file is generated by rust-protobuf 2.22.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `p4/config/v1/p4types.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_1;

#[derive(PartialEq,Clone,Default)]
pub struct P4TypeInfo {
    // message fields
    pub structs: ::std::collections::HashMap<::std::string::String, P4StructTypeSpec>,
    pub headers: ::std::collections::HashMap<::std::string::String, P4HeaderTypeSpec>,
    pub header_unions: ::std::collections::HashMap<::std::string::String, P4HeaderUnionTypeSpec>,
    pub enums: ::std::collections::HashMap<::std::string::String, P4EnumTypeSpec>,
    pub error: ::protobuf::SingularPtrField<P4ErrorTypeSpec>,
    pub serializable_enums: ::std::collections::HashMap<::std::string::String, P4SerializableEnumTypeSpec>,
    pub new_types: ::std::collections::HashMap<::std::string::String, P4NewTypeSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4TypeInfo {
    fn default() -> &'a P4TypeInfo {
        <P4TypeInfo as ::protobuf::Message>::default_instance()
    }
}

impl P4TypeInfo {
    pub fn new() -> P4TypeInfo {
        ::std::default::Default::default()
    }

    // repeated .p4.config.v1.P4TypeInfo.StructsEntry structs = 1;


    pub fn get_structs(&self) -> &::std::collections::HashMap<::std::string::String, P4StructTypeSpec> {
        &self.structs
    }
    pub fn clear_structs(&mut self) {
        self.structs.clear();
    }

    // Param is passed by value, moved
    pub fn set_structs(&mut self, v: ::std::collections::HashMap<::std::string::String, P4StructTypeSpec>) {
        self.structs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_structs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, P4StructTypeSpec> {
        &mut self.structs
    }

    // Take field
    pub fn take_structs(&mut self) -> ::std::collections::HashMap<::std::string::String, P4StructTypeSpec> {
        ::std::mem::replace(&mut self.structs, ::std::collections::HashMap::new())
    }

    // repeated .p4.config.v1.P4TypeInfo.HeadersEntry headers = 2;


    pub fn get_headers(&self) -> &::std::collections::HashMap<::std::string::String, P4HeaderTypeSpec> {
        &self.headers
    }
    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: ::std::collections::HashMap<::std::string::String, P4HeaderTypeSpec>) {
        self.headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_headers(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, P4HeaderTypeSpec> {
        &mut self.headers
    }

    // Take field
    pub fn take_headers(&mut self) -> ::std::collections::HashMap<::std::string::String, P4HeaderTypeSpec> {
        ::std::mem::replace(&mut self.headers, ::std::collections::HashMap::new())
    }

    // repeated .p4.config.v1.P4TypeInfo.HeaderUnionsEntry header_unions = 3;


    pub fn get_header_unions(&self) -> &::std::collections::HashMap<::std::string::String, P4HeaderUnionTypeSpec> {
        &self.header_unions
    }
    pub fn clear_header_unions(&mut self) {
        self.header_unions.clear();
    }

    // Param is passed by value, moved
    pub fn set_header_unions(&mut self, v: ::std::collections::HashMap<::std::string::String, P4HeaderUnionTypeSpec>) {
        self.header_unions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_header_unions(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, P4HeaderUnionTypeSpec> {
        &mut self.header_unions
    }

    // Take field
    pub fn take_header_unions(&mut self) -> ::std::collections::HashMap<::std::string::String, P4HeaderUnionTypeSpec> {
        ::std::mem::replace(&mut self.header_unions, ::std::collections::HashMap::new())
    }

    // repeated .p4.config.v1.P4TypeInfo.EnumsEntry enums = 4;


    pub fn get_enums(&self) -> &::std::collections::HashMap<::std::string::String, P4EnumTypeSpec> {
        &self.enums
    }
    pub fn clear_enums(&mut self) {
        self.enums.clear();
    }

    // Param is passed by value, moved
    pub fn set_enums(&mut self, v: ::std::collections::HashMap<::std::string::String, P4EnumTypeSpec>) {
        self.enums = v;
    }

    // Mutable pointer to the field.
    pub fn mut_enums(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, P4EnumTypeSpec> {
        &mut self.enums
    }

    // Take field
    pub fn take_enums(&mut self) -> ::std::collections::HashMap<::std::string::String, P4EnumTypeSpec> {
        ::std::mem::replace(&mut self.enums, ::std::collections::HashMap::new())
    }

    // .p4.config.v1.P4ErrorTypeSpec error = 5;


    pub fn get_error(&self) -> &P4ErrorTypeSpec {
        self.error.as_ref().unwrap_or_else(|| <P4ErrorTypeSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: P4ErrorTypeSpec) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut P4ErrorTypeSpec {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> P4ErrorTypeSpec {
        self.error.take().unwrap_or_else(|| P4ErrorTypeSpec::new())
    }

    // repeated .p4.config.v1.P4TypeInfo.SerializableEnumsEntry serializable_enums = 6;


    pub fn get_serializable_enums(&self) -> &::std::collections::HashMap<::std::string::String, P4SerializableEnumTypeSpec> {
        &self.serializable_enums
    }
    pub fn clear_serializable_enums(&mut self) {
        self.serializable_enums.clear();
    }

    // Param is passed by value, moved
    pub fn set_serializable_enums(&mut self, v: ::std::collections::HashMap<::std::string::String, P4SerializableEnumTypeSpec>) {
        self.serializable_enums = v;
    }

    // Mutable pointer to the field.
    pub fn mut_serializable_enums(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, P4SerializableEnumTypeSpec> {
        &mut self.serializable_enums
    }

    // Take field
    pub fn take_serializable_enums(&mut self) -> ::std::collections::HashMap<::std::string::String, P4SerializableEnumTypeSpec> {
        ::std::mem::replace(&mut self.serializable_enums, ::std::collections::HashMap::new())
    }

    // repeated .p4.config.v1.P4TypeInfo.NewTypesEntry new_types = 7;


    pub fn get_new_types(&self) -> &::std::collections::HashMap<::std::string::String, P4NewTypeSpec> {
        &self.new_types
    }
    pub fn clear_new_types(&mut self) {
        self.new_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_new_types(&mut self, v: ::std::collections::HashMap<::std::string::String, P4NewTypeSpec>) {
        self.new_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_new_types(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, P4NewTypeSpec> {
        &mut self.new_types
    }

    // Take field
    pub fn take_new_types(&mut self) -> ::std::collections::HashMap<::std::string::String, P4NewTypeSpec> {
        ::std::mem::replace(&mut self.new_types, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for P4TypeInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4StructTypeSpec>>(wire_type, is, &mut self.structs)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4HeaderTypeSpec>>(wire_type, is, &mut self.headers)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4HeaderUnionTypeSpec>>(wire_type, is, &mut self.header_unions)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4EnumTypeSpec>>(wire_type, is, &mut self.enums)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4SerializableEnumTypeSpec>>(wire_type, is, &mut self.serializable_enums)?;
                },
                7 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4NewTypeSpec>>(wire_type, is, &mut self.new_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4StructTypeSpec>>(1, &self.structs);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4HeaderTypeSpec>>(2, &self.headers);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4HeaderUnionTypeSpec>>(3, &self.header_unions);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4EnumTypeSpec>>(4, &self.enums);
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4SerializableEnumTypeSpec>>(6, &self.serializable_enums);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4NewTypeSpec>>(7, &self.new_types);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4StructTypeSpec>>(1, &self.structs, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4HeaderTypeSpec>>(2, &self.headers, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4HeaderUnionTypeSpec>>(3, &self.header_unions, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4EnumTypeSpec>>(4, &self.enums, os)?;
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4SerializableEnumTypeSpec>>(6, &self.serializable_enums, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4NewTypeSpec>>(7, &self.new_types, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4TypeInfo {
        P4TypeInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4StructTypeSpec>>(
                "structs",
                |m: &P4TypeInfo| { &m.structs },
                |m: &mut P4TypeInfo| { &mut m.structs },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4HeaderTypeSpec>>(
                "headers",
                |m: &P4TypeInfo| { &m.headers },
                |m: &mut P4TypeInfo| { &mut m.headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4HeaderUnionTypeSpec>>(
                "header_unions",
                |m: &P4TypeInfo| { &m.header_unions },
                |m: &mut P4TypeInfo| { &mut m.header_unions },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4EnumTypeSpec>>(
                "enums",
                |m: &P4TypeInfo| { &m.enums },
                |m: &mut P4TypeInfo| { &mut m.enums },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<P4ErrorTypeSpec>>(
                "error",
                |m: &P4TypeInfo| { &m.error },
                |m: &mut P4TypeInfo| { &mut m.error },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4SerializableEnumTypeSpec>>(
                "serializable_enums",
                |m: &P4TypeInfo| { &m.serializable_enums },
                |m: &mut P4TypeInfo| { &mut m.serializable_enums },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<P4NewTypeSpec>>(
                "new_types",
                |m: &P4TypeInfo| { &m.new_types },
                |m: &mut P4TypeInfo| { &mut m.new_types },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4TypeInfo>(
                "P4TypeInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4TypeInfo {
        static instance: ::protobuf::rt::LazyV2<P4TypeInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4TypeInfo::new)
    }
}

impl ::protobuf::Clear for P4TypeInfo {
    fn clear(&mut self) {
        self.structs.clear();
        self.headers.clear();
        self.header_unions.clear();
        self.enums.clear();
        self.error.clear();
        self.serializable_enums.clear();
        self.new_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4TypeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4TypeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4DataTypeSpec {
    // message oneof groups
    pub type_spec: ::std::option::Option<P4DataTypeSpec_oneof_type_spec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4DataTypeSpec {
    fn default() -> &'a P4DataTypeSpec {
        <P4DataTypeSpec as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum P4DataTypeSpec_oneof_type_spec {
    bitstring(P4BitstringLikeTypeSpec),
    bool(P4BoolType),
    tuple(P4TupleTypeSpec),
    field_struct(P4NamedType),
    header(P4NamedType),
    header_union(P4NamedType),
    header_stack(P4HeaderStackTypeSpec),
    header_union_stack(P4HeaderUnionStackTypeSpec),
    field_enum(P4NamedType),
    error(P4ErrorType),
    serializable_enum(P4NamedType),
    new_type(P4NamedType),
}

impl P4DataTypeSpec {
    pub fn new() -> P4DataTypeSpec {
        ::std::default::Default::default()
    }

    // .p4.config.v1.P4BitstringLikeTypeSpec bitstring = 1;


    pub fn get_bitstring(&self) -> &P4BitstringLikeTypeSpec {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::bitstring(ref v)) => v,
            _ => <P4BitstringLikeTypeSpec as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_bitstring(&mut self) {
        self.type_spec = ::std::option::Option::None;
    }

    pub fn has_bitstring(&self) -> bool {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::bitstring(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bitstring(&mut self, v: P4BitstringLikeTypeSpec) {
        self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::bitstring(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bitstring(&mut self) -> &mut P4BitstringLikeTypeSpec {
        if let ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::bitstring(_)) = self.type_spec {
        } else {
            self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::bitstring(P4BitstringLikeTypeSpec::new()));
        }
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::bitstring(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bitstring(&mut self) -> P4BitstringLikeTypeSpec {
        if self.has_bitstring() {
            match self.type_spec.take() {
                ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::bitstring(v)) => v,
                _ => panic!(),
            }
        } else {
            P4BitstringLikeTypeSpec::new()
        }
    }

    // .p4.config.v1.P4BoolType bool = 2;


    pub fn get_bool(&self) -> &P4BoolType {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::bool(ref v)) => v,
            _ => <P4BoolType as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_bool(&mut self) {
        self.type_spec = ::std::option::Option::None;
    }

    pub fn has_bool(&self) -> bool {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::bool(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bool(&mut self, v: P4BoolType) {
        self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::bool(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bool(&mut self) -> &mut P4BoolType {
        if let ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::bool(_)) = self.type_spec {
        } else {
            self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::bool(P4BoolType::new()));
        }
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::bool(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bool(&mut self) -> P4BoolType {
        if self.has_bool() {
            match self.type_spec.take() {
                ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::bool(v)) => v,
                _ => panic!(),
            }
        } else {
            P4BoolType::new()
        }
    }

    // .p4.config.v1.P4TupleTypeSpec tuple = 3;


    pub fn get_tuple(&self) -> &P4TupleTypeSpec {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::tuple(ref v)) => v,
            _ => <P4TupleTypeSpec as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_tuple(&mut self) {
        self.type_spec = ::std::option::Option::None;
    }

    pub fn has_tuple(&self) -> bool {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::tuple(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tuple(&mut self, v: P4TupleTypeSpec) {
        self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::tuple(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tuple(&mut self) -> &mut P4TupleTypeSpec {
        if let ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::tuple(_)) = self.type_spec {
        } else {
            self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::tuple(P4TupleTypeSpec::new()));
        }
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::tuple(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tuple(&mut self) -> P4TupleTypeSpec {
        if self.has_tuple() {
            match self.type_spec.take() {
                ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::tuple(v)) => v,
                _ => panic!(),
            }
        } else {
            P4TupleTypeSpec::new()
        }
    }

    // .p4.config.v1.P4NamedType struct = 4;


    pub fn get_field_struct(&self) -> &P4NamedType {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::field_struct(ref v)) => v,
            _ => <P4NamedType as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_field_struct(&mut self) {
        self.type_spec = ::std::option::Option::None;
    }

    pub fn has_field_struct(&self) -> bool {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::field_struct(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_struct(&mut self, v: P4NamedType) {
        self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::field_struct(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field_struct(&mut self) -> &mut P4NamedType {
        if let ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::field_struct(_)) = self.type_spec {
        } else {
            self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::field_struct(P4NamedType::new()));
        }
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::field_struct(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_struct(&mut self) -> P4NamedType {
        if self.has_field_struct() {
            match self.type_spec.take() {
                ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::field_struct(v)) => v,
                _ => panic!(),
            }
        } else {
            P4NamedType::new()
        }
    }

    // .p4.config.v1.P4NamedType header = 5;


    pub fn get_header(&self) -> &P4NamedType {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header(ref v)) => v,
            _ => <P4NamedType as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_header(&mut self) {
        self.type_spec = ::std::option::Option::None;
    }

    pub fn has_header(&self) -> bool {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: P4NamedType) {
        self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header(v))
    }

    // Mutable pointer to the field.
    pub fn mut_header(&mut self) -> &mut P4NamedType {
        if let ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header(_)) = self.type_spec {
        } else {
            self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header(P4NamedType::new()));
        }
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_header(&mut self) -> P4NamedType {
        if self.has_header() {
            match self.type_spec.take() {
                ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header(v)) => v,
                _ => panic!(),
            }
        } else {
            P4NamedType::new()
        }
    }

    // .p4.config.v1.P4NamedType header_union = 6;


    pub fn get_header_union(&self) -> &P4NamedType {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_union(ref v)) => v,
            _ => <P4NamedType as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_header_union(&mut self) {
        self.type_spec = ::std::option::Option::None;
    }

    pub fn has_header_union(&self) -> bool {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_union(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_header_union(&mut self, v: P4NamedType) {
        self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_union(v))
    }

    // Mutable pointer to the field.
    pub fn mut_header_union(&mut self) -> &mut P4NamedType {
        if let ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_union(_)) = self.type_spec {
        } else {
            self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_union(P4NamedType::new()));
        }
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_union(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_header_union(&mut self) -> P4NamedType {
        if self.has_header_union() {
            match self.type_spec.take() {
                ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_union(v)) => v,
                _ => panic!(),
            }
        } else {
            P4NamedType::new()
        }
    }

    // .p4.config.v1.P4HeaderStackTypeSpec header_stack = 7;


    pub fn get_header_stack(&self) -> &P4HeaderStackTypeSpec {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_stack(ref v)) => v,
            _ => <P4HeaderStackTypeSpec as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_header_stack(&mut self) {
        self.type_spec = ::std::option::Option::None;
    }

    pub fn has_header_stack(&self) -> bool {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_stack(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_header_stack(&mut self, v: P4HeaderStackTypeSpec) {
        self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_stack(v))
    }

    // Mutable pointer to the field.
    pub fn mut_header_stack(&mut self) -> &mut P4HeaderStackTypeSpec {
        if let ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_stack(_)) = self.type_spec {
        } else {
            self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_stack(P4HeaderStackTypeSpec::new()));
        }
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_stack(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_header_stack(&mut self) -> P4HeaderStackTypeSpec {
        if self.has_header_stack() {
            match self.type_spec.take() {
                ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_stack(v)) => v,
                _ => panic!(),
            }
        } else {
            P4HeaderStackTypeSpec::new()
        }
    }

    // .p4.config.v1.P4HeaderUnionStackTypeSpec header_union_stack = 8;


    pub fn get_header_union_stack(&self) -> &P4HeaderUnionStackTypeSpec {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_union_stack(ref v)) => v,
            _ => <P4HeaderUnionStackTypeSpec as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_header_union_stack(&mut self) {
        self.type_spec = ::std::option::Option::None;
    }

    pub fn has_header_union_stack(&self) -> bool {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_union_stack(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_header_union_stack(&mut self, v: P4HeaderUnionStackTypeSpec) {
        self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_union_stack(v))
    }

    // Mutable pointer to the field.
    pub fn mut_header_union_stack(&mut self) -> &mut P4HeaderUnionStackTypeSpec {
        if let ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_union_stack(_)) = self.type_spec {
        } else {
            self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_union_stack(P4HeaderUnionStackTypeSpec::new()));
        }
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_union_stack(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_header_union_stack(&mut self) -> P4HeaderUnionStackTypeSpec {
        if self.has_header_union_stack() {
            match self.type_spec.take() {
                ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_union_stack(v)) => v,
                _ => panic!(),
            }
        } else {
            P4HeaderUnionStackTypeSpec::new()
        }
    }

    // .p4.config.v1.P4NamedType enum = 9;


    pub fn get_field_enum(&self) -> &P4NamedType {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::field_enum(ref v)) => v,
            _ => <P4NamedType as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_field_enum(&mut self) {
        self.type_spec = ::std::option::Option::None;
    }

    pub fn has_field_enum(&self) -> bool {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::field_enum(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_enum(&mut self, v: P4NamedType) {
        self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::field_enum(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field_enum(&mut self) -> &mut P4NamedType {
        if let ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::field_enum(_)) = self.type_spec {
        } else {
            self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::field_enum(P4NamedType::new()));
        }
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::field_enum(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_enum(&mut self) -> P4NamedType {
        if self.has_field_enum() {
            match self.type_spec.take() {
                ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::field_enum(v)) => v,
                _ => panic!(),
            }
        } else {
            P4NamedType::new()
        }
    }

    // .p4.config.v1.P4ErrorType error = 10;


    pub fn get_error(&self) -> &P4ErrorType {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::error(ref v)) => v,
            _ => <P4ErrorType as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_error(&mut self) {
        self.type_spec = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: P4ErrorType) {
        self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut P4ErrorType {
        if let ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::error(_)) = self.type_spec {
        } else {
            self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::error(P4ErrorType::new()));
        }
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> P4ErrorType {
        if self.has_error() {
            match self.type_spec.take() {
                ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::error(v)) => v,
                _ => panic!(),
            }
        } else {
            P4ErrorType::new()
        }
    }

    // .p4.config.v1.P4NamedType serializable_enum = 11;


    pub fn get_serializable_enum(&self) -> &P4NamedType {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::serializable_enum(ref v)) => v,
            _ => <P4NamedType as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_serializable_enum(&mut self) {
        self.type_spec = ::std::option::Option::None;
    }

    pub fn has_serializable_enum(&self) -> bool {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::serializable_enum(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_serializable_enum(&mut self, v: P4NamedType) {
        self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::serializable_enum(v))
    }

    // Mutable pointer to the field.
    pub fn mut_serializable_enum(&mut self) -> &mut P4NamedType {
        if let ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::serializable_enum(_)) = self.type_spec {
        } else {
            self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::serializable_enum(P4NamedType::new()));
        }
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::serializable_enum(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_serializable_enum(&mut self) -> P4NamedType {
        if self.has_serializable_enum() {
            match self.type_spec.take() {
                ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::serializable_enum(v)) => v,
                _ => panic!(),
            }
        } else {
            P4NamedType::new()
        }
    }

    // .p4.config.v1.P4NamedType new_type = 12;


    pub fn get_new_type(&self) -> &P4NamedType {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::new_type(ref v)) => v,
            _ => <P4NamedType as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_new_type(&mut self) {
        self.type_spec = ::std::option::Option::None;
    }

    pub fn has_new_type(&self) -> bool {
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::new_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_new_type(&mut self, v: P4NamedType) {
        self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::new_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_new_type(&mut self) -> &mut P4NamedType {
        if let ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::new_type(_)) = self.type_spec {
        } else {
            self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::new_type(P4NamedType::new()));
        }
        match self.type_spec {
            ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::new_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_new_type(&mut self) -> P4NamedType {
        if self.has_new_type() {
            match self.type_spec.take() {
                ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::new_type(v)) => v,
                _ => panic!(),
            }
        } else {
            P4NamedType::new()
        }
    }
}

impl ::protobuf::Message for P4DataTypeSpec {
    fn is_initialized(&self) -> bool {
        if let Some(P4DataTypeSpec_oneof_type_spec::bitstring(ref v)) = self.type_spec {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(P4DataTypeSpec_oneof_type_spec::bool(ref v)) = self.type_spec {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(P4DataTypeSpec_oneof_type_spec::tuple(ref v)) = self.type_spec {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(P4DataTypeSpec_oneof_type_spec::field_struct(ref v)) = self.type_spec {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(P4DataTypeSpec_oneof_type_spec::header(ref v)) = self.type_spec {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(P4DataTypeSpec_oneof_type_spec::header_union(ref v)) = self.type_spec {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(P4DataTypeSpec_oneof_type_spec::header_stack(ref v)) = self.type_spec {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(P4DataTypeSpec_oneof_type_spec::header_union_stack(ref v)) = self.type_spec {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(P4DataTypeSpec_oneof_type_spec::field_enum(ref v)) = self.type_spec {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(P4DataTypeSpec_oneof_type_spec::error(ref v)) = self.type_spec {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(P4DataTypeSpec_oneof_type_spec::serializable_enum(ref v)) = self.type_spec {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(P4DataTypeSpec_oneof_type_spec::new_type(ref v)) = self.type_spec {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::bitstring(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::bool(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::tuple(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::field_struct(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_union(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_stack(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::header_union_stack(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::field_enum(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::error(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::serializable_enum(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_spec = ::std::option::Option::Some(P4DataTypeSpec_oneof_type_spec::new_type(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.type_spec {
            match v {
                &P4DataTypeSpec_oneof_type_spec::bitstring(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &P4DataTypeSpec_oneof_type_spec::bool(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &P4DataTypeSpec_oneof_type_spec::tuple(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &P4DataTypeSpec_oneof_type_spec::field_struct(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &P4DataTypeSpec_oneof_type_spec::header(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &P4DataTypeSpec_oneof_type_spec::header_union(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &P4DataTypeSpec_oneof_type_spec::header_stack(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &P4DataTypeSpec_oneof_type_spec::header_union_stack(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &P4DataTypeSpec_oneof_type_spec::field_enum(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &P4DataTypeSpec_oneof_type_spec::error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &P4DataTypeSpec_oneof_type_spec::serializable_enum(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &P4DataTypeSpec_oneof_type_spec::new_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.type_spec {
            match v {
                &P4DataTypeSpec_oneof_type_spec::bitstring(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &P4DataTypeSpec_oneof_type_spec::bool(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &P4DataTypeSpec_oneof_type_spec::tuple(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &P4DataTypeSpec_oneof_type_spec::field_struct(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &P4DataTypeSpec_oneof_type_spec::header(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &P4DataTypeSpec_oneof_type_spec::header_union(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &P4DataTypeSpec_oneof_type_spec::header_stack(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &P4DataTypeSpec_oneof_type_spec::header_union_stack(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &P4DataTypeSpec_oneof_type_spec::field_enum(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &P4DataTypeSpec_oneof_type_spec::error(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &P4DataTypeSpec_oneof_type_spec::serializable_enum(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &P4DataTypeSpec_oneof_type_spec::new_type(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4DataTypeSpec {
        P4DataTypeSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, P4BitstringLikeTypeSpec>(
                "bitstring",
                P4DataTypeSpec::has_bitstring,
                P4DataTypeSpec::get_bitstring,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, P4BoolType>(
                "bool",
                P4DataTypeSpec::has_bool,
                P4DataTypeSpec::get_bool,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, P4TupleTypeSpec>(
                "tuple",
                P4DataTypeSpec::has_tuple,
                P4DataTypeSpec::get_tuple,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, P4NamedType>(
                "struct",
                P4DataTypeSpec::has_field_struct,
                P4DataTypeSpec::get_field_struct,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, P4NamedType>(
                "header",
                P4DataTypeSpec::has_header,
                P4DataTypeSpec::get_header,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, P4NamedType>(
                "header_union",
                P4DataTypeSpec::has_header_union,
                P4DataTypeSpec::get_header_union,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, P4HeaderStackTypeSpec>(
                "header_stack",
                P4DataTypeSpec::has_header_stack,
                P4DataTypeSpec::get_header_stack,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, P4HeaderUnionStackTypeSpec>(
                "header_union_stack",
                P4DataTypeSpec::has_header_union_stack,
                P4DataTypeSpec::get_header_union_stack,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, P4NamedType>(
                "enum",
                P4DataTypeSpec::has_field_enum,
                P4DataTypeSpec::get_field_enum,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, P4ErrorType>(
                "error",
                P4DataTypeSpec::has_error,
                P4DataTypeSpec::get_error,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, P4NamedType>(
                "serializable_enum",
                P4DataTypeSpec::has_serializable_enum,
                P4DataTypeSpec::get_serializable_enum,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, P4NamedType>(
                "new_type",
                P4DataTypeSpec::has_new_type,
                P4DataTypeSpec::get_new_type,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4DataTypeSpec>(
                "P4DataTypeSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4DataTypeSpec {
        static instance: ::protobuf::rt::LazyV2<P4DataTypeSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4DataTypeSpec::new)
    }
}

impl ::protobuf::Clear for P4DataTypeSpec {
    fn clear(&mut self) {
        self.type_spec = ::std::option::Option::None;
        self.type_spec = ::std::option::Option::None;
        self.type_spec = ::std::option::Option::None;
        self.type_spec = ::std::option::Option::None;
        self.type_spec = ::std::option::Option::None;
        self.type_spec = ::std::option::Option::None;
        self.type_spec = ::std::option::Option::None;
        self.type_spec = ::std::option::Option::None;
        self.type_spec = ::std::option::Option::None;
        self.type_spec = ::std::option::Option::None;
        self.type_spec = ::std::option::Option::None;
        self.type_spec = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4DataTypeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4DataTypeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4NamedType {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4NamedType {
    fn default() -> &'a P4NamedType {
        <P4NamedType as ::protobuf::Message>::default_instance()
    }
}

impl P4NamedType {
    pub fn new() -> P4NamedType {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for P4NamedType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4NamedType {
        P4NamedType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &P4NamedType| { &m.name },
                |m: &mut P4NamedType| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4NamedType>(
                "P4NamedType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4NamedType {
        static instance: ::protobuf::rt::LazyV2<P4NamedType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4NamedType::new)
    }
}

impl ::protobuf::Clear for P4NamedType {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4NamedType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4NamedType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4BoolType {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4BoolType {
    fn default() -> &'a P4BoolType {
        <P4BoolType as ::protobuf::Message>::default_instance()
    }
}

impl P4BoolType {
    pub fn new() -> P4BoolType {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for P4BoolType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4BoolType {
        P4BoolType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4BoolType>(
                "P4BoolType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4BoolType {
        static instance: ::protobuf::rt::LazyV2<P4BoolType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4BoolType::new)
    }
}

impl ::protobuf::Clear for P4BoolType {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4BoolType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4BoolType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4ErrorType {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4ErrorType {
    fn default() -> &'a P4ErrorType {
        <P4ErrorType as ::protobuf::Message>::default_instance()
    }
}

impl P4ErrorType {
    pub fn new() -> P4ErrorType {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for P4ErrorType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4ErrorType {
        P4ErrorType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4ErrorType>(
                "P4ErrorType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4ErrorType {
        static instance: ::protobuf::rt::LazyV2<P4ErrorType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4ErrorType::new)
    }
}

impl ::protobuf::Clear for P4ErrorType {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4ErrorType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4ErrorType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4BitstringLikeTypeSpec {
    // message fields
    pub annotations: ::protobuf::RepeatedField<::std::string::String>,
    pub annotation_locations: ::protobuf::RepeatedField<SourceLocation>,
    pub structured_annotations: ::protobuf::RepeatedField<StructuredAnnotation>,
    // message oneof groups
    pub type_spec: ::std::option::Option<P4BitstringLikeTypeSpec_oneof_type_spec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4BitstringLikeTypeSpec {
    fn default() -> &'a P4BitstringLikeTypeSpec {
        <P4BitstringLikeTypeSpec as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum P4BitstringLikeTypeSpec_oneof_type_spec {
    bit(P4BitTypeSpec),
    int(P4IntTypeSpec),
    varbit(P4VarbitTypeSpec),
}

impl P4BitstringLikeTypeSpec {
    pub fn new() -> P4BitstringLikeTypeSpec {
        ::std::default::Default::default()
    }

    // .p4.config.v1.P4BitTypeSpec bit = 1;


    pub fn get_bit(&self) -> &P4BitTypeSpec {
        match self.type_spec {
            ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::bit(ref v)) => v,
            _ => <P4BitTypeSpec as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_bit(&mut self) {
        self.type_spec = ::std::option::Option::None;
    }

    pub fn has_bit(&self) -> bool {
        match self.type_spec {
            ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::bit(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bit(&mut self, v: P4BitTypeSpec) {
        self.type_spec = ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::bit(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bit(&mut self) -> &mut P4BitTypeSpec {
        if let ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::bit(_)) = self.type_spec {
        } else {
            self.type_spec = ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::bit(P4BitTypeSpec::new()));
        }
        match self.type_spec {
            ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::bit(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bit(&mut self) -> P4BitTypeSpec {
        if self.has_bit() {
            match self.type_spec.take() {
                ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::bit(v)) => v,
                _ => panic!(),
            }
        } else {
            P4BitTypeSpec::new()
        }
    }

    // .p4.config.v1.P4IntTypeSpec int = 2;


    pub fn get_int(&self) -> &P4IntTypeSpec {
        match self.type_spec {
            ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::int(ref v)) => v,
            _ => <P4IntTypeSpec as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_int(&mut self) {
        self.type_spec = ::std::option::Option::None;
    }

    pub fn has_int(&self) -> bool {
        match self.type_spec {
            ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::int(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int(&mut self, v: P4IntTypeSpec) {
        self.type_spec = ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::int(v))
    }

    // Mutable pointer to the field.
    pub fn mut_int(&mut self) -> &mut P4IntTypeSpec {
        if let ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::int(_)) = self.type_spec {
        } else {
            self.type_spec = ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::int(P4IntTypeSpec::new()));
        }
        match self.type_spec {
            ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::int(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_int(&mut self) -> P4IntTypeSpec {
        if self.has_int() {
            match self.type_spec.take() {
                ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::int(v)) => v,
                _ => panic!(),
            }
        } else {
            P4IntTypeSpec::new()
        }
    }

    // .p4.config.v1.P4VarbitTypeSpec varbit = 3;


    pub fn get_varbit(&self) -> &P4VarbitTypeSpec {
        match self.type_spec {
            ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::varbit(ref v)) => v,
            _ => <P4VarbitTypeSpec as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_varbit(&mut self) {
        self.type_spec = ::std::option::Option::None;
    }

    pub fn has_varbit(&self) -> bool {
        match self.type_spec {
            ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::varbit(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_varbit(&mut self, v: P4VarbitTypeSpec) {
        self.type_spec = ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::varbit(v))
    }

    // Mutable pointer to the field.
    pub fn mut_varbit(&mut self) -> &mut P4VarbitTypeSpec {
        if let ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::varbit(_)) = self.type_spec {
        } else {
            self.type_spec = ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::varbit(P4VarbitTypeSpec::new()));
        }
        match self.type_spec {
            ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::varbit(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_varbit(&mut self) -> P4VarbitTypeSpec {
        if self.has_varbit() {
            match self.type_spec.take() {
                ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::varbit(v)) => v,
                _ => panic!(),
            }
        } else {
            P4VarbitTypeSpec::new()
        }
    }

    // repeated string annotations = 4;


    pub fn get_annotations(&self) -> &[::std::string::String] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.SourceLocation annotation_locations = 5;


    pub fn get_annotation_locations(&self) -> &[SourceLocation] {
        &self.annotation_locations
    }
    pub fn clear_annotation_locations(&mut self) {
        self.annotation_locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_locations(&mut self, v: ::protobuf::RepeatedField<SourceLocation>) {
        self.annotation_locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotation_locations(&mut self) -> &mut ::protobuf::RepeatedField<SourceLocation> {
        &mut self.annotation_locations
    }

    // Take field
    pub fn take_annotation_locations(&mut self) -> ::protobuf::RepeatedField<SourceLocation> {
        ::std::mem::replace(&mut self.annotation_locations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.StructuredAnnotation structured_annotations = 6;


    pub fn get_structured_annotations(&self) -> &[StructuredAnnotation] {
        &self.structured_annotations
    }
    pub fn clear_structured_annotations(&mut self) {
        self.structured_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_structured_annotations(&mut self, v: ::protobuf::RepeatedField<StructuredAnnotation>) {
        self.structured_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_structured_annotations(&mut self) -> &mut ::protobuf::RepeatedField<StructuredAnnotation> {
        &mut self.structured_annotations
    }

    // Take field
    pub fn take_structured_annotations(&mut self) -> ::protobuf::RepeatedField<StructuredAnnotation> {
        ::std::mem::replace(&mut self.structured_annotations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for P4BitstringLikeTypeSpec {
    fn is_initialized(&self) -> bool {
        if let Some(P4BitstringLikeTypeSpec_oneof_type_spec::bit(ref v)) = self.type_spec {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(P4BitstringLikeTypeSpec_oneof_type_spec::int(ref v)) = self.type_spec {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(P4BitstringLikeTypeSpec_oneof_type_spec::varbit(ref v)) = self.type_spec {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.annotation_locations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.structured_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_spec = ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::bit(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_spec = ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::int(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_spec = ::std::option::Option::Some(P4BitstringLikeTypeSpec_oneof_type_spec::varbit(is.read_message()?));
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.annotations)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotation_locations)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.structured_annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.annotations {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.annotation_locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.structured_annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.type_spec {
            match v {
                &P4BitstringLikeTypeSpec_oneof_type_spec::bit(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &P4BitstringLikeTypeSpec_oneof_type_spec::int(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &P4BitstringLikeTypeSpec_oneof_type_spec::varbit(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.annotations {
            os.write_string(4, &v)?;
        };
        for v in &self.annotation_locations {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.structured_annotations {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.type_spec {
            match v {
                &P4BitstringLikeTypeSpec_oneof_type_spec::bit(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &P4BitstringLikeTypeSpec_oneof_type_spec::int(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &P4BitstringLikeTypeSpec_oneof_type_spec::varbit(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4BitstringLikeTypeSpec {
        P4BitstringLikeTypeSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, P4BitTypeSpec>(
                "bit",
                P4BitstringLikeTypeSpec::has_bit,
                P4BitstringLikeTypeSpec::get_bit,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, P4IntTypeSpec>(
                "int",
                P4BitstringLikeTypeSpec::has_int,
                P4BitstringLikeTypeSpec::get_int,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, P4VarbitTypeSpec>(
                "varbit",
                P4BitstringLikeTypeSpec::has_varbit,
                P4BitstringLikeTypeSpec::get_varbit,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &P4BitstringLikeTypeSpec| { &m.annotations },
                |m: &mut P4BitstringLikeTypeSpec| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SourceLocation>>(
                "annotation_locations",
                |m: &P4BitstringLikeTypeSpec| { &m.annotation_locations },
                |m: &mut P4BitstringLikeTypeSpec| { &mut m.annotation_locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructuredAnnotation>>(
                "structured_annotations",
                |m: &P4BitstringLikeTypeSpec| { &m.structured_annotations },
                |m: &mut P4BitstringLikeTypeSpec| { &mut m.structured_annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4BitstringLikeTypeSpec>(
                "P4BitstringLikeTypeSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4BitstringLikeTypeSpec {
        static instance: ::protobuf::rt::LazyV2<P4BitstringLikeTypeSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4BitstringLikeTypeSpec::new)
    }
}

impl ::protobuf::Clear for P4BitstringLikeTypeSpec {
    fn clear(&mut self) {
        self.type_spec = ::std::option::Option::None;
        self.type_spec = ::std::option::Option::None;
        self.type_spec = ::std::option::Option::None;
        self.annotations.clear();
        self.annotation_locations.clear();
        self.structured_annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4BitstringLikeTypeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4BitstringLikeTypeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4BitTypeSpec {
    // message fields
    pub bitwidth: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4BitTypeSpec {
    fn default() -> &'a P4BitTypeSpec {
        <P4BitTypeSpec as ::protobuf::Message>::default_instance()
    }
}

impl P4BitTypeSpec {
    pub fn new() -> P4BitTypeSpec {
        ::std::default::Default::default()
    }

    // int32 bitwidth = 1;


    pub fn get_bitwidth(&self) -> i32 {
        self.bitwidth
    }
    pub fn clear_bitwidth(&mut self) {
        self.bitwidth = 0;
    }

    // Param is passed by value, moved
    pub fn set_bitwidth(&mut self, v: i32) {
        self.bitwidth = v;
    }
}

impl ::protobuf::Message for P4BitTypeSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bitwidth = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.bitwidth != 0 {
            my_size += ::protobuf::rt::value_size(1, self.bitwidth, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.bitwidth != 0 {
            os.write_int32(1, self.bitwidth)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4BitTypeSpec {
        P4BitTypeSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bitwidth",
                |m: &P4BitTypeSpec| { &m.bitwidth },
                |m: &mut P4BitTypeSpec| { &mut m.bitwidth },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4BitTypeSpec>(
                "P4BitTypeSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4BitTypeSpec {
        static instance: ::protobuf::rt::LazyV2<P4BitTypeSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4BitTypeSpec::new)
    }
}

impl ::protobuf::Clear for P4BitTypeSpec {
    fn clear(&mut self) {
        self.bitwidth = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4BitTypeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4BitTypeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4IntTypeSpec {
    // message fields
    pub bitwidth: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4IntTypeSpec {
    fn default() -> &'a P4IntTypeSpec {
        <P4IntTypeSpec as ::protobuf::Message>::default_instance()
    }
}

impl P4IntTypeSpec {
    pub fn new() -> P4IntTypeSpec {
        ::std::default::Default::default()
    }

    // int32 bitwidth = 1;


    pub fn get_bitwidth(&self) -> i32 {
        self.bitwidth
    }
    pub fn clear_bitwidth(&mut self) {
        self.bitwidth = 0;
    }

    // Param is passed by value, moved
    pub fn set_bitwidth(&mut self, v: i32) {
        self.bitwidth = v;
    }
}

impl ::protobuf::Message for P4IntTypeSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bitwidth = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.bitwidth != 0 {
            my_size += ::protobuf::rt::value_size(1, self.bitwidth, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.bitwidth != 0 {
            os.write_int32(1, self.bitwidth)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4IntTypeSpec {
        P4IntTypeSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bitwidth",
                |m: &P4IntTypeSpec| { &m.bitwidth },
                |m: &mut P4IntTypeSpec| { &mut m.bitwidth },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4IntTypeSpec>(
                "P4IntTypeSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4IntTypeSpec {
        static instance: ::protobuf::rt::LazyV2<P4IntTypeSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4IntTypeSpec::new)
    }
}

impl ::protobuf::Clear for P4IntTypeSpec {
    fn clear(&mut self) {
        self.bitwidth = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4IntTypeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4IntTypeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4VarbitTypeSpec {
    // message fields
    pub max_bitwidth: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4VarbitTypeSpec {
    fn default() -> &'a P4VarbitTypeSpec {
        <P4VarbitTypeSpec as ::protobuf::Message>::default_instance()
    }
}

impl P4VarbitTypeSpec {
    pub fn new() -> P4VarbitTypeSpec {
        ::std::default::Default::default()
    }

    // int32 max_bitwidth = 1;


    pub fn get_max_bitwidth(&self) -> i32 {
        self.max_bitwidth
    }
    pub fn clear_max_bitwidth(&mut self) {
        self.max_bitwidth = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_bitwidth(&mut self, v: i32) {
        self.max_bitwidth = v;
    }
}

impl ::protobuf::Message for P4VarbitTypeSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_bitwidth = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.max_bitwidth != 0 {
            my_size += ::protobuf::rt::value_size(1, self.max_bitwidth, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.max_bitwidth != 0 {
            os.write_int32(1, self.max_bitwidth)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4VarbitTypeSpec {
        P4VarbitTypeSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_bitwidth",
                |m: &P4VarbitTypeSpec| { &m.max_bitwidth },
                |m: &mut P4VarbitTypeSpec| { &mut m.max_bitwidth },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4VarbitTypeSpec>(
                "P4VarbitTypeSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4VarbitTypeSpec {
        static instance: ::protobuf::rt::LazyV2<P4VarbitTypeSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4VarbitTypeSpec::new)
    }
}

impl ::protobuf::Clear for P4VarbitTypeSpec {
    fn clear(&mut self) {
        self.max_bitwidth = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4VarbitTypeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4VarbitTypeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4TupleTypeSpec {
    // message fields
    pub members: ::protobuf::RepeatedField<P4DataTypeSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4TupleTypeSpec {
    fn default() -> &'a P4TupleTypeSpec {
        <P4TupleTypeSpec as ::protobuf::Message>::default_instance()
    }
}

impl P4TupleTypeSpec {
    pub fn new() -> P4TupleTypeSpec {
        ::std::default::Default::default()
    }

    // repeated .p4.config.v1.P4DataTypeSpec members = 1;


    pub fn get_members(&self) -> &[P4DataTypeSpec] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<P4DataTypeSpec>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<P4DataTypeSpec> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<P4DataTypeSpec> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for P4TupleTypeSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.members {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4TupleTypeSpec {
        P4TupleTypeSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<P4DataTypeSpec>>(
                "members",
                |m: &P4TupleTypeSpec| { &m.members },
                |m: &mut P4TupleTypeSpec| { &mut m.members },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4TupleTypeSpec>(
                "P4TupleTypeSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4TupleTypeSpec {
        static instance: ::protobuf::rt::LazyV2<P4TupleTypeSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4TupleTypeSpec::new)
    }
}

impl ::protobuf::Clear for P4TupleTypeSpec {
    fn clear(&mut self) {
        self.members.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4TupleTypeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4TupleTypeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4StructTypeSpec {
    // message fields
    pub members: ::protobuf::RepeatedField<P4StructTypeSpec_Member>,
    pub annotations: ::protobuf::RepeatedField<::std::string::String>,
    pub annotation_locations: ::protobuf::RepeatedField<SourceLocation>,
    pub structured_annotations: ::protobuf::RepeatedField<StructuredAnnotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4StructTypeSpec {
    fn default() -> &'a P4StructTypeSpec {
        <P4StructTypeSpec as ::protobuf::Message>::default_instance()
    }
}

impl P4StructTypeSpec {
    pub fn new() -> P4StructTypeSpec {
        ::std::default::Default::default()
    }

    // repeated .p4.config.v1.P4StructTypeSpec.Member members = 1;


    pub fn get_members(&self) -> &[P4StructTypeSpec_Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<P4StructTypeSpec_Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<P4StructTypeSpec_Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<P4StructTypeSpec_Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    // repeated string annotations = 2;


    pub fn get_annotations(&self) -> &[::std::string::String] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.SourceLocation annotation_locations = 3;


    pub fn get_annotation_locations(&self) -> &[SourceLocation] {
        &self.annotation_locations
    }
    pub fn clear_annotation_locations(&mut self) {
        self.annotation_locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_locations(&mut self, v: ::protobuf::RepeatedField<SourceLocation>) {
        self.annotation_locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotation_locations(&mut self) -> &mut ::protobuf::RepeatedField<SourceLocation> {
        &mut self.annotation_locations
    }

    // Take field
    pub fn take_annotation_locations(&mut self) -> ::protobuf::RepeatedField<SourceLocation> {
        ::std::mem::replace(&mut self.annotation_locations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.StructuredAnnotation structured_annotations = 4;


    pub fn get_structured_annotations(&self) -> &[StructuredAnnotation] {
        &self.structured_annotations
    }
    pub fn clear_structured_annotations(&mut self) {
        self.structured_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_structured_annotations(&mut self, v: ::protobuf::RepeatedField<StructuredAnnotation>) {
        self.structured_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_structured_annotations(&mut self) -> &mut ::protobuf::RepeatedField<StructuredAnnotation> {
        &mut self.structured_annotations
    }

    // Take field
    pub fn take_structured_annotations(&mut self) -> ::protobuf::RepeatedField<StructuredAnnotation> {
        ::std::mem::replace(&mut self.structured_annotations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for P4StructTypeSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotation_locations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.structured_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.annotations)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotation_locations)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.structured_annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.annotations {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.annotation_locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.structured_annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.members {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.annotations {
            os.write_string(2, &v)?;
        };
        for v in &self.annotation_locations {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.structured_annotations {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4StructTypeSpec {
        P4StructTypeSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<P4StructTypeSpec_Member>>(
                "members",
                |m: &P4StructTypeSpec| { &m.members },
                |m: &mut P4StructTypeSpec| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &P4StructTypeSpec| { &m.annotations },
                |m: &mut P4StructTypeSpec| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SourceLocation>>(
                "annotation_locations",
                |m: &P4StructTypeSpec| { &m.annotation_locations },
                |m: &mut P4StructTypeSpec| { &mut m.annotation_locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructuredAnnotation>>(
                "structured_annotations",
                |m: &P4StructTypeSpec| { &m.structured_annotations },
                |m: &mut P4StructTypeSpec| { &mut m.structured_annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4StructTypeSpec>(
                "P4StructTypeSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4StructTypeSpec {
        static instance: ::protobuf::rt::LazyV2<P4StructTypeSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4StructTypeSpec::new)
    }
}

impl ::protobuf::Clear for P4StructTypeSpec {
    fn clear(&mut self) {
        self.members.clear();
        self.annotations.clear();
        self.annotation_locations.clear();
        self.structured_annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4StructTypeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4StructTypeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4StructTypeSpec_Member {
    // message fields
    pub name: ::std::string::String,
    pub type_spec: ::protobuf::SingularPtrField<P4DataTypeSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4StructTypeSpec_Member {
    fn default() -> &'a P4StructTypeSpec_Member {
        <P4StructTypeSpec_Member as ::protobuf::Message>::default_instance()
    }
}

impl P4StructTypeSpec_Member {
    pub fn new() -> P4StructTypeSpec_Member {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .p4.config.v1.P4DataTypeSpec type_spec = 2;


    pub fn get_type_spec(&self) -> &P4DataTypeSpec {
        self.type_spec.as_ref().unwrap_or_else(|| <P4DataTypeSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_type_spec(&mut self) {
        self.type_spec.clear();
    }

    pub fn has_type_spec(&self) -> bool {
        self.type_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_spec(&mut self, v: P4DataTypeSpec) {
        self.type_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_spec(&mut self) -> &mut P4DataTypeSpec {
        if self.type_spec.is_none() {
            self.type_spec.set_default();
        }
        self.type_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_spec(&mut self) -> P4DataTypeSpec {
        self.type_spec.take().unwrap_or_else(|| P4DataTypeSpec::new())
    }
}

impl ::protobuf::Message for P4StructTypeSpec_Member {
    fn is_initialized(&self) -> bool {
        for v in &self.type_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.type_spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.type_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.type_spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4StructTypeSpec_Member {
        P4StructTypeSpec_Member::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &P4StructTypeSpec_Member| { &m.name },
                |m: &mut P4StructTypeSpec_Member| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<P4DataTypeSpec>>(
                "type_spec",
                |m: &P4StructTypeSpec_Member| { &m.type_spec },
                |m: &mut P4StructTypeSpec_Member| { &mut m.type_spec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4StructTypeSpec_Member>(
                "P4StructTypeSpec.Member",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4StructTypeSpec_Member {
        static instance: ::protobuf::rt::LazyV2<P4StructTypeSpec_Member> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4StructTypeSpec_Member::new)
    }
}

impl ::protobuf::Clear for P4StructTypeSpec_Member {
    fn clear(&mut self) {
        self.name.clear();
        self.type_spec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4StructTypeSpec_Member {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4StructTypeSpec_Member {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4HeaderTypeSpec {
    // message fields
    pub members: ::protobuf::RepeatedField<P4HeaderTypeSpec_Member>,
    pub annotations: ::protobuf::RepeatedField<::std::string::String>,
    pub annotation_locations: ::protobuf::RepeatedField<SourceLocation>,
    pub structured_annotations: ::protobuf::RepeatedField<StructuredAnnotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4HeaderTypeSpec {
    fn default() -> &'a P4HeaderTypeSpec {
        <P4HeaderTypeSpec as ::protobuf::Message>::default_instance()
    }
}

impl P4HeaderTypeSpec {
    pub fn new() -> P4HeaderTypeSpec {
        ::std::default::Default::default()
    }

    // repeated .p4.config.v1.P4HeaderTypeSpec.Member members = 1;


    pub fn get_members(&self) -> &[P4HeaderTypeSpec_Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<P4HeaderTypeSpec_Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<P4HeaderTypeSpec_Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<P4HeaderTypeSpec_Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    // repeated string annotations = 2;


    pub fn get_annotations(&self) -> &[::std::string::String] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.SourceLocation annotation_locations = 3;


    pub fn get_annotation_locations(&self) -> &[SourceLocation] {
        &self.annotation_locations
    }
    pub fn clear_annotation_locations(&mut self) {
        self.annotation_locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_locations(&mut self, v: ::protobuf::RepeatedField<SourceLocation>) {
        self.annotation_locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotation_locations(&mut self) -> &mut ::protobuf::RepeatedField<SourceLocation> {
        &mut self.annotation_locations
    }

    // Take field
    pub fn take_annotation_locations(&mut self) -> ::protobuf::RepeatedField<SourceLocation> {
        ::std::mem::replace(&mut self.annotation_locations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.StructuredAnnotation structured_annotations = 4;


    pub fn get_structured_annotations(&self) -> &[StructuredAnnotation] {
        &self.structured_annotations
    }
    pub fn clear_structured_annotations(&mut self) {
        self.structured_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_structured_annotations(&mut self, v: ::protobuf::RepeatedField<StructuredAnnotation>) {
        self.structured_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_structured_annotations(&mut self) -> &mut ::protobuf::RepeatedField<StructuredAnnotation> {
        &mut self.structured_annotations
    }

    // Take field
    pub fn take_structured_annotations(&mut self) -> ::protobuf::RepeatedField<StructuredAnnotation> {
        ::std::mem::replace(&mut self.structured_annotations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for P4HeaderTypeSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotation_locations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.structured_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.annotations)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotation_locations)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.structured_annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.annotations {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.annotation_locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.structured_annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.members {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.annotations {
            os.write_string(2, &v)?;
        };
        for v in &self.annotation_locations {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.structured_annotations {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4HeaderTypeSpec {
        P4HeaderTypeSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<P4HeaderTypeSpec_Member>>(
                "members",
                |m: &P4HeaderTypeSpec| { &m.members },
                |m: &mut P4HeaderTypeSpec| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &P4HeaderTypeSpec| { &m.annotations },
                |m: &mut P4HeaderTypeSpec| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SourceLocation>>(
                "annotation_locations",
                |m: &P4HeaderTypeSpec| { &m.annotation_locations },
                |m: &mut P4HeaderTypeSpec| { &mut m.annotation_locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructuredAnnotation>>(
                "structured_annotations",
                |m: &P4HeaderTypeSpec| { &m.structured_annotations },
                |m: &mut P4HeaderTypeSpec| { &mut m.structured_annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4HeaderTypeSpec>(
                "P4HeaderTypeSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4HeaderTypeSpec {
        static instance: ::protobuf::rt::LazyV2<P4HeaderTypeSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4HeaderTypeSpec::new)
    }
}

impl ::protobuf::Clear for P4HeaderTypeSpec {
    fn clear(&mut self) {
        self.members.clear();
        self.annotations.clear();
        self.annotation_locations.clear();
        self.structured_annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4HeaderTypeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4HeaderTypeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4HeaderTypeSpec_Member {
    // message fields
    pub name: ::std::string::String,
    pub type_spec: ::protobuf::SingularPtrField<P4BitstringLikeTypeSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4HeaderTypeSpec_Member {
    fn default() -> &'a P4HeaderTypeSpec_Member {
        <P4HeaderTypeSpec_Member as ::protobuf::Message>::default_instance()
    }
}

impl P4HeaderTypeSpec_Member {
    pub fn new() -> P4HeaderTypeSpec_Member {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .p4.config.v1.P4BitstringLikeTypeSpec type_spec = 2;


    pub fn get_type_spec(&self) -> &P4BitstringLikeTypeSpec {
        self.type_spec.as_ref().unwrap_or_else(|| <P4BitstringLikeTypeSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_type_spec(&mut self) {
        self.type_spec.clear();
    }

    pub fn has_type_spec(&self) -> bool {
        self.type_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_spec(&mut self, v: P4BitstringLikeTypeSpec) {
        self.type_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_spec(&mut self) -> &mut P4BitstringLikeTypeSpec {
        if self.type_spec.is_none() {
            self.type_spec.set_default();
        }
        self.type_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_spec(&mut self) -> P4BitstringLikeTypeSpec {
        self.type_spec.take().unwrap_or_else(|| P4BitstringLikeTypeSpec::new())
    }
}

impl ::protobuf::Message for P4HeaderTypeSpec_Member {
    fn is_initialized(&self) -> bool {
        for v in &self.type_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.type_spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.type_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.type_spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4HeaderTypeSpec_Member {
        P4HeaderTypeSpec_Member::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &P4HeaderTypeSpec_Member| { &m.name },
                |m: &mut P4HeaderTypeSpec_Member| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<P4BitstringLikeTypeSpec>>(
                "type_spec",
                |m: &P4HeaderTypeSpec_Member| { &m.type_spec },
                |m: &mut P4HeaderTypeSpec_Member| { &mut m.type_spec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4HeaderTypeSpec_Member>(
                "P4HeaderTypeSpec.Member",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4HeaderTypeSpec_Member {
        static instance: ::protobuf::rt::LazyV2<P4HeaderTypeSpec_Member> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4HeaderTypeSpec_Member::new)
    }
}

impl ::protobuf::Clear for P4HeaderTypeSpec_Member {
    fn clear(&mut self) {
        self.name.clear();
        self.type_spec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4HeaderTypeSpec_Member {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4HeaderTypeSpec_Member {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4HeaderUnionTypeSpec {
    // message fields
    pub members: ::protobuf::RepeatedField<P4HeaderUnionTypeSpec_Member>,
    pub annotations: ::protobuf::RepeatedField<::std::string::String>,
    pub annotation_locations: ::protobuf::RepeatedField<SourceLocation>,
    pub structured_annotations: ::protobuf::RepeatedField<StructuredAnnotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4HeaderUnionTypeSpec {
    fn default() -> &'a P4HeaderUnionTypeSpec {
        <P4HeaderUnionTypeSpec as ::protobuf::Message>::default_instance()
    }
}

impl P4HeaderUnionTypeSpec {
    pub fn new() -> P4HeaderUnionTypeSpec {
        ::std::default::Default::default()
    }

    // repeated .p4.config.v1.P4HeaderUnionTypeSpec.Member members = 1;


    pub fn get_members(&self) -> &[P4HeaderUnionTypeSpec_Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<P4HeaderUnionTypeSpec_Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<P4HeaderUnionTypeSpec_Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<P4HeaderUnionTypeSpec_Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    // repeated string annotations = 2;


    pub fn get_annotations(&self) -> &[::std::string::String] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.SourceLocation annotation_locations = 3;


    pub fn get_annotation_locations(&self) -> &[SourceLocation] {
        &self.annotation_locations
    }
    pub fn clear_annotation_locations(&mut self) {
        self.annotation_locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_locations(&mut self, v: ::protobuf::RepeatedField<SourceLocation>) {
        self.annotation_locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotation_locations(&mut self) -> &mut ::protobuf::RepeatedField<SourceLocation> {
        &mut self.annotation_locations
    }

    // Take field
    pub fn take_annotation_locations(&mut self) -> ::protobuf::RepeatedField<SourceLocation> {
        ::std::mem::replace(&mut self.annotation_locations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.StructuredAnnotation structured_annotations = 4;


    pub fn get_structured_annotations(&self) -> &[StructuredAnnotation] {
        &self.structured_annotations
    }
    pub fn clear_structured_annotations(&mut self) {
        self.structured_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_structured_annotations(&mut self, v: ::protobuf::RepeatedField<StructuredAnnotation>) {
        self.structured_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_structured_annotations(&mut self) -> &mut ::protobuf::RepeatedField<StructuredAnnotation> {
        &mut self.structured_annotations
    }

    // Take field
    pub fn take_structured_annotations(&mut self) -> ::protobuf::RepeatedField<StructuredAnnotation> {
        ::std::mem::replace(&mut self.structured_annotations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for P4HeaderUnionTypeSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotation_locations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.structured_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.annotations)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotation_locations)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.structured_annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.annotations {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.annotation_locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.structured_annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.members {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.annotations {
            os.write_string(2, &v)?;
        };
        for v in &self.annotation_locations {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.structured_annotations {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4HeaderUnionTypeSpec {
        P4HeaderUnionTypeSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<P4HeaderUnionTypeSpec_Member>>(
                "members",
                |m: &P4HeaderUnionTypeSpec| { &m.members },
                |m: &mut P4HeaderUnionTypeSpec| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &P4HeaderUnionTypeSpec| { &m.annotations },
                |m: &mut P4HeaderUnionTypeSpec| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SourceLocation>>(
                "annotation_locations",
                |m: &P4HeaderUnionTypeSpec| { &m.annotation_locations },
                |m: &mut P4HeaderUnionTypeSpec| { &mut m.annotation_locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructuredAnnotation>>(
                "structured_annotations",
                |m: &P4HeaderUnionTypeSpec| { &m.structured_annotations },
                |m: &mut P4HeaderUnionTypeSpec| { &mut m.structured_annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4HeaderUnionTypeSpec>(
                "P4HeaderUnionTypeSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4HeaderUnionTypeSpec {
        static instance: ::protobuf::rt::LazyV2<P4HeaderUnionTypeSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4HeaderUnionTypeSpec::new)
    }
}

impl ::protobuf::Clear for P4HeaderUnionTypeSpec {
    fn clear(&mut self) {
        self.members.clear();
        self.annotations.clear();
        self.annotation_locations.clear();
        self.structured_annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4HeaderUnionTypeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4HeaderUnionTypeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4HeaderUnionTypeSpec_Member {
    // message fields
    pub name: ::std::string::String,
    pub header: ::protobuf::SingularPtrField<P4NamedType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4HeaderUnionTypeSpec_Member {
    fn default() -> &'a P4HeaderUnionTypeSpec_Member {
        <P4HeaderUnionTypeSpec_Member as ::protobuf::Message>::default_instance()
    }
}

impl P4HeaderUnionTypeSpec_Member {
    pub fn new() -> P4HeaderUnionTypeSpec_Member {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .p4.config.v1.P4NamedType header = 2;


    pub fn get_header(&self) -> &P4NamedType {
        self.header.as_ref().unwrap_or_else(|| <P4NamedType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: P4NamedType) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut P4NamedType {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> P4NamedType {
        self.header.take().unwrap_or_else(|| P4NamedType::new())
    }
}

impl ::protobuf::Message for P4HeaderUnionTypeSpec_Member {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4HeaderUnionTypeSpec_Member {
        P4HeaderUnionTypeSpec_Member::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &P4HeaderUnionTypeSpec_Member| { &m.name },
                |m: &mut P4HeaderUnionTypeSpec_Member| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<P4NamedType>>(
                "header",
                |m: &P4HeaderUnionTypeSpec_Member| { &m.header },
                |m: &mut P4HeaderUnionTypeSpec_Member| { &mut m.header },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4HeaderUnionTypeSpec_Member>(
                "P4HeaderUnionTypeSpec.Member",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4HeaderUnionTypeSpec_Member {
        static instance: ::protobuf::rt::LazyV2<P4HeaderUnionTypeSpec_Member> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4HeaderUnionTypeSpec_Member::new)
    }
}

impl ::protobuf::Clear for P4HeaderUnionTypeSpec_Member {
    fn clear(&mut self) {
        self.name.clear();
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4HeaderUnionTypeSpec_Member {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4HeaderUnionTypeSpec_Member {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4HeaderStackTypeSpec {
    // message fields
    pub header: ::protobuf::SingularPtrField<P4NamedType>,
    pub size: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4HeaderStackTypeSpec {
    fn default() -> &'a P4HeaderStackTypeSpec {
        <P4HeaderStackTypeSpec as ::protobuf::Message>::default_instance()
    }
}

impl P4HeaderStackTypeSpec {
    pub fn new() -> P4HeaderStackTypeSpec {
        ::std::default::Default::default()
    }

    // .p4.config.v1.P4NamedType header = 1;


    pub fn get_header(&self) -> &P4NamedType {
        self.header.as_ref().unwrap_or_else(|| <P4NamedType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: P4NamedType) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut P4NamedType {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> P4NamedType {
        self.header.take().unwrap_or_else(|| P4NamedType::new())
    }

    // int32 size = 2;


    pub fn get_size(&self) -> i32 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i32) {
        self.size = v;
    }
}

impl ::protobuf::Message for P4HeaderStackTypeSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.size != 0 {
            os.write_int32(2, self.size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4HeaderStackTypeSpec {
        P4HeaderStackTypeSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<P4NamedType>>(
                "header",
                |m: &P4HeaderStackTypeSpec| { &m.header },
                |m: &mut P4HeaderStackTypeSpec| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "size",
                |m: &P4HeaderStackTypeSpec| { &m.size },
                |m: &mut P4HeaderStackTypeSpec| { &mut m.size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4HeaderStackTypeSpec>(
                "P4HeaderStackTypeSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4HeaderStackTypeSpec {
        static instance: ::protobuf::rt::LazyV2<P4HeaderStackTypeSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4HeaderStackTypeSpec::new)
    }
}

impl ::protobuf::Clear for P4HeaderStackTypeSpec {
    fn clear(&mut self) {
        self.header.clear();
        self.size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4HeaderStackTypeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4HeaderStackTypeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4HeaderUnionStackTypeSpec {
    // message fields
    pub header_union: ::protobuf::SingularPtrField<P4NamedType>,
    pub size: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4HeaderUnionStackTypeSpec {
    fn default() -> &'a P4HeaderUnionStackTypeSpec {
        <P4HeaderUnionStackTypeSpec as ::protobuf::Message>::default_instance()
    }
}

impl P4HeaderUnionStackTypeSpec {
    pub fn new() -> P4HeaderUnionStackTypeSpec {
        ::std::default::Default::default()
    }

    // .p4.config.v1.P4NamedType header_union = 1;


    pub fn get_header_union(&self) -> &P4NamedType {
        self.header_union.as_ref().unwrap_or_else(|| <P4NamedType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header_union(&mut self) {
        self.header_union.clear();
    }

    pub fn has_header_union(&self) -> bool {
        self.header_union.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header_union(&mut self, v: P4NamedType) {
        self.header_union = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header_union(&mut self) -> &mut P4NamedType {
        if self.header_union.is_none() {
            self.header_union.set_default();
        }
        self.header_union.as_mut().unwrap()
    }

    // Take field
    pub fn take_header_union(&mut self) -> P4NamedType {
        self.header_union.take().unwrap_or_else(|| P4NamedType::new())
    }

    // int32 size = 2;


    pub fn get_size(&self) -> i32 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i32) {
        self.size = v;
    }
}

impl ::protobuf::Message for P4HeaderUnionStackTypeSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.header_union {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header_union)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header_union.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header_union.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.size != 0 {
            os.write_int32(2, self.size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4HeaderUnionStackTypeSpec {
        P4HeaderUnionStackTypeSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<P4NamedType>>(
                "header_union",
                |m: &P4HeaderUnionStackTypeSpec| { &m.header_union },
                |m: &mut P4HeaderUnionStackTypeSpec| { &mut m.header_union },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "size",
                |m: &P4HeaderUnionStackTypeSpec| { &m.size },
                |m: &mut P4HeaderUnionStackTypeSpec| { &mut m.size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4HeaderUnionStackTypeSpec>(
                "P4HeaderUnionStackTypeSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4HeaderUnionStackTypeSpec {
        static instance: ::protobuf::rt::LazyV2<P4HeaderUnionStackTypeSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4HeaderUnionStackTypeSpec::new)
    }
}

impl ::protobuf::Clear for P4HeaderUnionStackTypeSpec {
    fn clear(&mut self) {
        self.header_union.clear();
        self.size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4HeaderUnionStackTypeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4HeaderUnionStackTypeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyValuePair {
    // message fields
    pub key: ::std::string::String,
    pub value: ::protobuf::SingularPtrField<Expression>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyValuePair {
    fn default() -> &'a KeyValuePair {
        <KeyValuePair as ::protobuf::Message>::default_instance()
    }
}

impl KeyValuePair {
    pub fn new() -> KeyValuePair {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // .p4.config.v1.Expression value = 2;


    pub fn get_value(&self) -> &Expression {
        self.value.as_ref().unwrap_or_else(|| <Expression as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: Expression) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut Expression {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> Expression {
        self.value.take().unwrap_or_else(|| Expression::new())
    }
}

impl ::protobuf::Message for KeyValuePair {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyValuePair {
        KeyValuePair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &KeyValuePair| { &m.key },
                |m: &mut KeyValuePair| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expression>>(
                "value",
                |m: &KeyValuePair| { &m.value },
                |m: &mut KeyValuePair| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyValuePair>(
                "KeyValuePair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyValuePair {
        static instance: ::protobuf::rt::LazyV2<KeyValuePair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyValuePair::new)
    }
}

impl ::protobuf::Clear for KeyValuePair {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyValuePair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyValuePair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyValuePairList {
    // message fields
    pub kv_pairs: ::protobuf::RepeatedField<KeyValuePair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyValuePairList {
    fn default() -> &'a KeyValuePairList {
        <KeyValuePairList as ::protobuf::Message>::default_instance()
    }
}

impl KeyValuePairList {
    pub fn new() -> KeyValuePairList {
        ::std::default::Default::default()
    }

    // repeated .p4.config.v1.KeyValuePair kv_pairs = 1;


    pub fn get_kv_pairs(&self) -> &[KeyValuePair] {
        &self.kv_pairs
    }
    pub fn clear_kv_pairs(&mut self) {
        self.kv_pairs.clear();
    }

    // Param is passed by value, moved
    pub fn set_kv_pairs(&mut self, v: ::protobuf::RepeatedField<KeyValuePair>) {
        self.kv_pairs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kv_pairs(&mut self) -> &mut ::protobuf::RepeatedField<KeyValuePair> {
        &mut self.kv_pairs
    }

    // Take field
    pub fn take_kv_pairs(&mut self) -> ::protobuf::RepeatedField<KeyValuePair> {
        ::std::mem::replace(&mut self.kv_pairs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for KeyValuePairList {
    fn is_initialized(&self) -> bool {
        for v in &self.kv_pairs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.kv_pairs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.kv_pairs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.kv_pairs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyValuePairList {
        KeyValuePairList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyValuePair>>(
                "kv_pairs",
                |m: &KeyValuePairList| { &m.kv_pairs },
                |m: &mut KeyValuePairList| { &mut m.kv_pairs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyValuePairList>(
                "KeyValuePairList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyValuePairList {
        static instance: ::protobuf::rt::LazyV2<KeyValuePairList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyValuePairList::new)
    }
}

impl ::protobuf::Clear for KeyValuePairList {
    fn clear(&mut self) {
        self.kv_pairs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyValuePairList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyValuePairList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expression {
    // message oneof groups
    pub value: ::std::option::Option<Expression_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Expression {
    fn default() -> &'a Expression {
        <Expression as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Expression_oneof_value {
    string_value(::std::string::String),
    int64_value(i64),
    bool_value(bool),
}

impl Expression {
    pub fn new() -> Expression {
        ::std::default::Default::default()
    }

    // string string_value = 1;


    pub fn get_string_value(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(Expression_oneof_value::string_value(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_string_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Expression_oneof_value::string_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(Expression_oneof_value::string_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Expression_oneof_value::string_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Expression_oneof_value::string_value(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(Expression_oneof_value::string_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        if self.has_string_value() {
            match self.value.take() {
                ::std::option::Option::Some(Expression_oneof_value::string_value(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // int64 int64_value = 2;


    pub fn get_int64_value(&self) -> i64 {
        match self.value {
            ::std::option::Option::Some(Expression_oneof_value::int64_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_int64_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_int64_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Expression_oneof_value::int64_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int64_value(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(Expression_oneof_value::int64_value(v))
    }

    // bool bool_value = 3;


    pub fn get_bool_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Expression_oneof_value::bool_value(v)) => v,
            _ => false,
        }
    }
    pub fn clear_bool_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_bool_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Expression_oneof_value::bool_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bool_value(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(Expression_oneof_value::bool_value(v))
    }
}

impl ::protobuf::Message for Expression {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Expression_oneof_value::string_value(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Expression_oneof_value::int64_value(is.read_int64()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Expression_oneof_value::bool_value(is.read_bool()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Expression_oneof_value::string_value(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &Expression_oneof_value::int64_value(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Expression_oneof_value::bool_value(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Expression_oneof_value::string_value(ref v) => {
                    os.write_string(1, v)?;
                },
                &Expression_oneof_value::int64_value(v) => {
                    os.write_int64(2, v)?;
                },
                &Expression_oneof_value::bool_value(v) => {
                    os.write_bool(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expression {
        Expression::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "string_value",
                Expression::has_string_value,
                Expression::get_string_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                "int64_value",
                Expression::has_int64_value,
                Expression::get_int64_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "bool_value",
                Expression::has_bool_value,
                Expression::get_bool_value,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Expression>(
                "Expression",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Expression {
        static instance: ::protobuf::rt::LazyV2<Expression> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Expression::new)
    }
}

impl ::protobuf::Clear for Expression {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expression {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expression {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExpressionList {
    // message fields
    pub expressions: ::protobuf::RepeatedField<Expression>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExpressionList {
    fn default() -> &'a ExpressionList {
        <ExpressionList as ::protobuf::Message>::default_instance()
    }
}

impl ExpressionList {
    pub fn new() -> ExpressionList {
        ::std::default::Default::default()
    }

    // repeated .p4.config.v1.Expression expressions = 1;


    pub fn get_expressions(&self) -> &[Expression] {
        &self.expressions
    }
    pub fn clear_expressions(&mut self) {
        self.expressions.clear();
    }

    // Param is passed by value, moved
    pub fn set_expressions(&mut self, v: ::protobuf::RepeatedField<Expression>) {
        self.expressions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_expressions(&mut self) -> &mut ::protobuf::RepeatedField<Expression> {
        &mut self.expressions
    }

    // Take field
    pub fn take_expressions(&mut self) -> ::protobuf::RepeatedField<Expression> {
        ::std::mem::replace(&mut self.expressions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExpressionList {
    fn is_initialized(&self) -> bool {
        for v in &self.expressions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.expressions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.expressions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.expressions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExpressionList {
        ExpressionList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expression>>(
                "expressions",
                |m: &ExpressionList| { &m.expressions },
                |m: &mut ExpressionList| { &mut m.expressions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExpressionList>(
                "ExpressionList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExpressionList {
        static instance: ::protobuf::rt::LazyV2<ExpressionList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExpressionList::new)
    }
}

impl ::protobuf::Clear for ExpressionList {
    fn clear(&mut self) {
        self.expressions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExpressionList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExpressionList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructuredAnnotation {
    // message fields
    pub name: ::std::string::String,
    pub source_location: ::protobuf::SingularPtrField<SourceLocation>,
    // message oneof groups
    pub body: ::std::option::Option<StructuredAnnotation_oneof_body>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StructuredAnnotation {
    fn default() -> &'a StructuredAnnotation {
        <StructuredAnnotation as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum StructuredAnnotation_oneof_body {
    expression_list(ExpressionList),
    kv_pair_list(KeyValuePairList),
}

impl StructuredAnnotation {
    pub fn new() -> StructuredAnnotation {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .p4.config.v1.ExpressionList expression_list = 2;


    pub fn get_expression_list(&self) -> &ExpressionList {
        match self.body {
            ::std::option::Option::Some(StructuredAnnotation_oneof_body::expression_list(ref v)) => v,
            _ => <ExpressionList as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_expression_list(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_expression_list(&self) -> bool {
        match self.body {
            ::std::option::Option::Some(StructuredAnnotation_oneof_body::expression_list(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_expression_list(&mut self, v: ExpressionList) {
        self.body = ::std::option::Option::Some(StructuredAnnotation_oneof_body::expression_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_expression_list(&mut self) -> &mut ExpressionList {
        if let ::std::option::Option::Some(StructuredAnnotation_oneof_body::expression_list(_)) = self.body {
        } else {
            self.body = ::std::option::Option::Some(StructuredAnnotation_oneof_body::expression_list(ExpressionList::new()));
        }
        match self.body {
            ::std::option::Option::Some(StructuredAnnotation_oneof_body::expression_list(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_expression_list(&mut self) -> ExpressionList {
        if self.has_expression_list() {
            match self.body.take() {
                ::std::option::Option::Some(StructuredAnnotation_oneof_body::expression_list(v)) => v,
                _ => panic!(),
            }
        } else {
            ExpressionList::new()
        }
    }

    // .p4.config.v1.KeyValuePairList kv_pair_list = 3;


    pub fn get_kv_pair_list(&self) -> &KeyValuePairList {
        match self.body {
            ::std::option::Option::Some(StructuredAnnotation_oneof_body::kv_pair_list(ref v)) => v,
            _ => <KeyValuePairList as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_kv_pair_list(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_kv_pair_list(&self) -> bool {
        match self.body {
            ::std::option::Option::Some(StructuredAnnotation_oneof_body::kv_pair_list(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_kv_pair_list(&mut self, v: KeyValuePairList) {
        self.body = ::std::option::Option::Some(StructuredAnnotation_oneof_body::kv_pair_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_kv_pair_list(&mut self) -> &mut KeyValuePairList {
        if let ::std::option::Option::Some(StructuredAnnotation_oneof_body::kv_pair_list(_)) = self.body {
        } else {
            self.body = ::std::option::Option::Some(StructuredAnnotation_oneof_body::kv_pair_list(KeyValuePairList::new()));
        }
        match self.body {
            ::std::option::Option::Some(StructuredAnnotation_oneof_body::kv_pair_list(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_kv_pair_list(&mut self) -> KeyValuePairList {
        if self.has_kv_pair_list() {
            match self.body.take() {
                ::std::option::Option::Some(StructuredAnnotation_oneof_body::kv_pair_list(v)) => v,
                _ => panic!(),
            }
        } else {
            KeyValuePairList::new()
        }
    }

    // .p4.config.v1.SourceLocation source_location = 4;


    pub fn get_source_location(&self) -> &SourceLocation {
        self.source_location.as_ref().unwrap_or_else(|| <SourceLocation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source_location(&mut self) {
        self.source_location.clear();
    }

    pub fn has_source_location(&self) -> bool {
        self.source_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_location(&mut self, v: SourceLocation) {
        self.source_location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_location(&mut self) -> &mut SourceLocation {
        if self.source_location.is_none() {
            self.source_location.set_default();
        }
        self.source_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_source_location(&mut self) -> SourceLocation {
        self.source_location.take().unwrap_or_else(|| SourceLocation::new())
    }
}

impl ::protobuf::Message for StructuredAnnotation {
    fn is_initialized(&self) -> bool {
        if let Some(StructuredAnnotation_oneof_body::expression_list(ref v)) = self.body {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StructuredAnnotation_oneof_body::kv_pair_list(ref v)) = self.body {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.source_location {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.body = ::std::option::Option::Some(StructuredAnnotation_oneof_body::expression_list(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.body = ::std::option::Option::Some(StructuredAnnotation_oneof_body::kv_pair_list(is.read_message()?));
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source_location)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.source_location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.body {
            match v {
                &StructuredAnnotation_oneof_body::expression_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StructuredAnnotation_oneof_body::kv_pair_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.source_location.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.body {
            match v {
                &StructuredAnnotation_oneof_body::expression_list(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StructuredAnnotation_oneof_body::kv_pair_list(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructuredAnnotation {
        StructuredAnnotation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &StructuredAnnotation| { &m.name },
                |m: &mut StructuredAnnotation| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ExpressionList>(
                "expression_list",
                StructuredAnnotation::has_expression_list,
                StructuredAnnotation::get_expression_list,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, KeyValuePairList>(
                "kv_pair_list",
                StructuredAnnotation::has_kv_pair_list,
                StructuredAnnotation::get_kv_pair_list,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SourceLocation>>(
                "source_location",
                |m: &StructuredAnnotation| { &m.source_location },
                |m: &mut StructuredAnnotation| { &mut m.source_location },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StructuredAnnotation>(
                "StructuredAnnotation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StructuredAnnotation {
        static instance: ::protobuf::rt::LazyV2<StructuredAnnotation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StructuredAnnotation::new)
    }
}

impl ::protobuf::Clear for StructuredAnnotation {
    fn clear(&mut self) {
        self.name.clear();
        self.body = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.source_location.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructuredAnnotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructuredAnnotation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SourceLocation {
    // message fields
    pub file: ::std::string::String,
    pub line: i32,
    pub column: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SourceLocation {
    fn default() -> &'a SourceLocation {
        <SourceLocation as ::protobuf::Message>::default_instance()
    }
}

impl SourceLocation {
    pub fn new() -> SourceLocation {
        ::std::default::Default::default()
    }

    // string file = 1;


    pub fn get_file(&self) -> &str {
        &self.file
    }
    pub fn clear_file(&mut self) {
        self.file.clear();
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: ::std::string::String) {
        self.file = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file(&mut self) -> &mut ::std::string::String {
        &mut self.file
    }

    // Take field
    pub fn take_file(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file, ::std::string::String::new())
    }

    // int32 line = 2;


    pub fn get_line(&self) -> i32 {
        self.line
    }
    pub fn clear_line(&mut self) {
        self.line = 0;
    }

    // Param is passed by value, moved
    pub fn set_line(&mut self, v: i32) {
        self.line = v;
    }

    // int32 column = 3;


    pub fn get_column(&self) -> i32 {
        self.column
    }
    pub fn clear_column(&mut self) {
        self.column = 0;
    }

    // Param is passed by value, moved
    pub fn set_column(&mut self, v: i32) {
        self.column = v;
    }
}

impl ::protobuf::Message for SourceLocation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.line = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.column = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.file.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file);
        }
        if self.line != 0 {
            my_size += ::protobuf::rt::value_size(2, self.line, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.column != 0 {
            my_size += ::protobuf::rt::value_size(3, self.column, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.file.is_empty() {
            os.write_string(1, &self.file)?;
        }
        if self.line != 0 {
            os.write_int32(2, self.line)?;
        }
        if self.column != 0 {
            os.write_int32(3, self.column)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SourceLocation {
        SourceLocation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file",
                |m: &SourceLocation| { &m.file },
                |m: &mut SourceLocation| { &mut m.file },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "line",
                |m: &SourceLocation| { &m.line },
                |m: &mut SourceLocation| { &mut m.line },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "column",
                |m: &SourceLocation| { &m.column },
                |m: &mut SourceLocation| { &mut m.column },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SourceLocation>(
                "SourceLocation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SourceLocation {
        static instance: ::protobuf::rt::LazyV2<SourceLocation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SourceLocation::new)
    }
}

impl ::protobuf::Clear for SourceLocation {
    fn clear(&mut self) {
        self.file.clear();
        self.line = 0;
        self.column = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SourceLocation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SourceLocation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4EnumTypeSpec {
    // message fields
    pub members: ::protobuf::RepeatedField<P4EnumTypeSpec_Member>,
    pub annotations: ::protobuf::RepeatedField<::std::string::String>,
    pub annotation_locations: ::protobuf::RepeatedField<SourceLocation>,
    pub structured_annotations: ::protobuf::RepeatedField<StructuredAnnotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4EnumTypeSpec {
    fn default() -> &'a P4EnumTypeSpec {
        <P4EnumTypeSpec as ::protobuf::Message>::default_instance()
    }
}

impl P4EnumTypeSpec {
    pub fn new() -> P4EnumTypeSpec {
        ::std::default::Default::default()
    }

    // repeated .p4.config.v1.P4EnumTypeSpec.Member members = 1;


    pub fn get_members(&self) -> &[P4EnumTypeSpec_Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<P4EnumTypeSpec_Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<P4EnumTypeSpec_Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<P4EnumTypeSpec_Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    // repeated string annotations = 2;


    pub fn get_annotations(&self) -> &[::std::string::String] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.SourceLocation annotation_locations = 4;


    pub fn get_annotation_locations(&self) -> &[SourceLocation] {
        &self.annotation_locations
    }
    pub fn clear_annotation_locations(&mut self) {
        self.annotation_locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_locations(&mut self, v: ::protobuf::RepeatedField<SourceLocation>) {
        self.annotation_locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotation_locations(&mut self) -> &mut ::protobuf::RepeatedField<SourceLocation> {
        &mut self.annotation_locations
    }

    // Take field
    pub fn take_annotation_locations(&mut self) -> ::protobuf::RepeatedField<SourceLocation> {
        ::std::mem::replace(&mut self.annotation_locations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.StructuredAnnotation structured_annotations = 3;


    pub fn get_structured_annotations(&self) -> &[StructuredAnnotation] {
        &self.structured_annotations
    }
    pub fn clear_structured_annotations(&mut self) {
        self.structured_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_structured_annotations(&mut self, v: ::protobuf::RepeatedField<StructuredAnnotation>) {
        self.structured_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_structured_annotations(&mut self) -> &mut ::protobuf::RepeatedField<StructuredAnnotation> {
        &mut self.structured_annotations
    }

    // Take field
    pub fn take_structured_annotations(&mut self) -> ::protobuf::RepeatedField<StructuredAnnotation> {
        ::std::mem::replace(&mut self.structured_annotations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for P4EnumTypeSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotation_locations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.structured_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.annotations)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotation_locations)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.structured_annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.annotations {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.annotation_locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.structured_annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.members {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.annotations {
            os.write_string(2, &v)?;
        };
        for v in &self.annotation_locations {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.structured_annotations {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4EnumTypeSpec {
        P4EnumTypeSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<P4EnumTypeSpec_Member>>(
                "members",
                |m: &P4EnumTypeSpec| { &m.members },
                |m: &mut P4EnumTypeSpec| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &P4EnumTypeSpec| { &m.annotations },
                |m: &mut P4EnumTypeSpec| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SourceLocation>>(
                "annotation_locations",
                |m: &P4EnumTypeSpec| { &m.annotation_locations },
                |m: &mut P4EnumTypeSpec| { &mut m.annotation_locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructuredAnnotation>>(
                "structured_annotations",
                |m: &P4EnumTypeSpec| { &m.structured_annotations },
                |m: &mut P4EnumTypeSpec| { &mut m.structured_annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4EnumTypeSpec>(
                "P4EnumTypeSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4EnumTypeSpec {
        static instance: ::protobuf::rt::LazyV2<P4EnumTypeSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4EnumTypeSpec::new)
    }
}

impl ::protobuf::Clear for P4EnumTypeSpec {
    fn clear(&mut self) {
        self.members.clear();
        self.annotations.clear();
        self.annotation_locations.clear();
        self.structured_annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4EnumTypeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4EnumTypeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4EnumTypeSpec_Member {
    // message fields
    pub name: ::std::string::String,
    pub annotations: ::protobuf::RepeatedField<::std::string::String>,
    pub annotation_locations: ::protobuf::RepeatedField<SourceLocation>,
    pub structured_annotations: ::protobuf::RepeatedField<StructuredAnnotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4EnumTypeSpec_Member {
    fn default() -> &'a P4EnumTypeSpec_Member {
        <P4EnumTypeSpec_Member as ::protobuf::Message>::default_instance()
    }
}

impl P4EnumTypeSpec_Member {
    pub fn new() -> P4EnumTypeSpec_Member {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated string annotations = 2;


    pub fn get_annotations(&self) -> &[::std::string::String] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.SourceLocation annotation_locations = 4;


    pub fn get_annotation_locations(&self) -> &[SourceLocation] {
        &self.annotation_locations
    }
    pub fn clear_annotation_locations(&mut self) {
        self.annotation_locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_locations(&mut self, v: ::protobuf::RepeatedField<SourceLocation>) {
        self.annotation_locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotation_locations(&mut self) -> &mut ::protobuf::RepeatedField<SourceLocation> {
        &mut self.annotation_locations
    }

    // Take field
    pub fn take_annotation_locations(&mut self) -> ::protobuf::RepeatedField<SourceLocation> {
        ::std::mem::replace(&mut self.annotation_locations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.StructuredAnnotation structured_annotations = 3;


    pub fn get_structured_annotations(&self) -> &[StructuredAnnotation] {
        &self.structured_annotations
    }
    pub fn clear_structured_annotations(&mut self) {
        self.structured_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_structured_annotations(&mut self, v: ::protobuf::RepeatedField<StructuredAnnotation>) {
        self.structured_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_structured_annotations(&mut self) -> &mut ::protobuf::RepeatedField<StructuredAnnotation> {
        &mut self.structured_annotations
    }

    // Take field
    pub fn take_structured_annotations(&mut self) -> ::protobuf::RepeatedField<StructuredAnnotation> {
        ::std::mem::replace(&mut self.structured_annotations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for P4EnumTypeSpec_Member {
    fn is_initialized(&self) -> bool {
        for v in &self.annotation_locations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.structured_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.annotations)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotation_locations)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.structured_annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.annotations {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.annotation_locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.structured_annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.annotations {
            os.write_string(2, &v)?;
        };
        for v in &self.annotation_locations {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.structured_annotations {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4EnumTypeSpec_Member {
        P4EnumTypeSpec_Member::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &P4EnumTypeSpec_Member| { &m.name },
                |m: &mut P4EnumTypeSpec_Member| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &P4EnumTypeSpec_Member| { &m.annotations },
                |m: &mut P4EnumTypeSpec_Member| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SourceLocation>>(
                "annotation_locations",
                |m: &P4EnumTypeSpec_Member| { &m.annotation_locations },
                |m: &mut P4EnumTypeSpec_Member| { &mut m.annotation_locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructuredAnnotation>>(
                "structured_annotations",
                |m: &P4EnumTypeSpec_Member| { &m.structured_annotations },
                |m: &mut P4EnumTypeSpec_Member| { &mut m.structured_annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4EnumTypeSpec_Member>(
                "P4EnumTypeSpec.Member",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4EnumTypeSpec_Member {
        static instance: ::protobuf::rt::LazyV2<P4EnumTypeSpec_Member> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4EnumTypeSpec_Member::new)
    }
}

impl ::protobuf::Clear for P4EnumTypeSpec_Member {
    fn clear(&mut self) {
        self.name.clear();
        self.annotations.clear();
        self.annotation_locations.clear();
        self.structured_annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4EnumTypeSpec_Member {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4EnumTypeSpec_Member {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4SerializableEnumTypeSpec {
    // message fields
    pub underlying_type: ::protobuf::SingularPtrField<P4BitTypeSpec>,
    pub members: ::protobuf::RepeatedField<P4SerializableEnumTypeSpec_Member>,
    pub annotations: ::protobuf::RepeatedField<::std::string::String>,
    pub annotation_locations: ::protobuf::RepeatedField<SourceLocation>,
    pub structured_annotations: ::protobuf::RepeatedField<StructuredAnnotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4SerializableEnumTypeSpec {
    fn default() -> &'a P4SerializableEnumTypeSpec {
        <P4SerializableEnumTypeSpec as ::protobuf::Message>::default_instance()
    }
}

impl P4SerializableEnumTypeSpec {
    pub fn new() -> P4SerializableEnumTypeSpec {
        ::std::default::Default::default()
    }

    // .p4.config.v1.P4BitTypeSpec underlying_type = 1;


    pub fn get_underlying_type(&self) -> &P4BitTypeSpec {
        self.underlying_type.as_ref().unwrap_or_else(|| <P4BitTypeSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_underlying_type(&mut self) {
        self.underlying_type.clear();
    }

    pub fn has_underlying_type(&self) -> bool {
        self.underlying_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_underlying_type(&mut self, v: P4BitTypeSpec) {
        self.underlying_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_underlying_type(&mut self) -> &mut P4BitTypeSpec {
        if self.underlying_type.is_none() {
            self.underlying_type.set_default();
        }
        self.underlying_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_underlying_type(&mut self) -> P4BitTypeSpec {
        self.underlying_type.take().unwrap_or_else(|| P4BitTypeSpec::new())
    }

    // repeated .p4.config.v1.P4SerializableEnumTypeSpec.Member members = 2;


    pub fn get_members(&self) -> &[P4SerializableEnumTypeSpec_Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<P4SerializableEnumTypeSpec_Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<P4SerializableEnumTypeSpec_Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<P4SerializableEnumTypeSpec_Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    // repeated string annotations = 3;


    pub fn get_annotations(&self) -> &[::std::string::String] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.SourceLocation annotation_locations = 5;


    pub fn get_annotation_locations(&self) -> &[SourceLocation] {
        &self.annotation_locations
    }
    pub fn clear_annotation_locations(&mut self) {
        self.annotation_locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_locations(&mut self, v: ::protobuf::RepeatedField<SourceLocation>) {
        self.annotation_locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotation_locations(&mut self) -> &mut ::protobuf::RepeatedField<SourceLocation> {
        &mut self.annotation_locations
    }

    // Take field
    pub fn take_annotation_locations(&mut self) -> ::protobuf::RepeatedField<SourceLocation> {
        ::std::mem::replace(&mut self.annotation_locations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.StructuredAnnotation structured_annotations = 4;


    pub fn get_structured_annotations(&self) -> &[StructuredAnnotation] {
        &self.structured_annotations
    }
    pub fn clear_structured_annotations(&mut self) {
        self.structured_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_structured_annotations(&mut self, v: ::protobuf::RepeatedField<StructuredAnnotation>) {
        self.structured_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_structured_annotations(&mut self) -> &mut ::protobuf::RepeatedField<StructuredAnnotation> {
        &mut self.structured_annotations
    }

    // Take field
    pub fn take_structured_annotations(&mut self) -> ::protobuf::RepeatedField<StructuredAnnotation> {
        ::std::mem::replace(&mut self.structured_annotations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for P4SerializableEnumTypeSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.underlying_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotation_locations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.structured_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.underlying_type)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.annotations)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotation_locations)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.structured_annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.underlying_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.annotations {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.annotation_locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.structured_annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.underlying_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.members {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.annotations {
            os.write_string(3, &v)?;
        };
        for v in &self.annotation_locations {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.structured_annotations {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4SerializableEnumTypeSpec {
        P4SerializableEnumTypeSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<P4BitTypeSpec>>(
                "underlying_type",
                |m: &P4SerializableEnumTypeSpec| { &m.underlying_type },
                |m: &mut P4SerializableEnumTypeSpec| { &mut m.underlying_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<P4SerializableEnumTypeSpec_Member>>(
                "members",
                |m: &P4SerializableEnumTypeSpec| { &m.members },
                |m: &mut P4SerializableEnumTypeSpec| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &P4SerializableEnumTypeSpec| { &m.annotations },
                |m: &mut P4SerializableEnumTypeSpec| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SourceLocation>>(
                "annotation_locations",
                |m: &P4SerializableEnumTypeSpec| { &m.annotation_locations },
                |m: &mut P4SerializableEnumTypeSpec| { &mut m.annotation_locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructuredAnnotation>>(
                "structured_annotations",
                |m: &P4SerializableEnumTypeSpec| { &m.structured_annotations },
                |m: &mut P4SerializableEnumTypeSpec| { &mut m.structured_annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4SerializableEnumTypeSpec>(
                "P4SerializableEnumTypeSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4SerializableEnumTypeSpec {
        static instance: ::protobuf::rt::LazyV2<P4SerializableEnumTypeSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4SerializableEnumTypeSpec::new)
    }
}

impl ::protobuf::Clear for P4SerializableEnumTypeSpec {
    fn clear(&mut self) {
        self.underlying_type.clear();
        self.members.clear();
        self.annotations.clear();
        self.annotation_locations.clear();
        self.structured_annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4SerializableEnumTypeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4SerializableEnumTypeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4SerializableEnumTypeSpec_Member {
    // message fields
    pub name: ::std::string::String,
    pub value: ::std::vec::Vec<u8>,
    pub annotations: ::protobuf::RepeatedField<::std::string::String>,
    pub annotation_locations: ::protobuf::RepeatedField<SourceLocation>,
    pub structured_annotations: ::protobuf::RepeatedField<StructuredAnnotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4SerializableEnumTypeSpec_Member {
    fn default() -> &'a P4SerializableEnumTypeSpec_Member {
        <P4SerializableEnumTypeSpec_Member as ::protobuf::Message>::default_instance()
    }
}

impl P4SerializableEnumTypeSpec_Member {
    pub fn new() -> P4SerializableEnumTypeSpec_Member {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // repeated string annotations = 3;


    pub fn get_annotations(&self) -> &[::std::string::String] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.SourceLocation annotation_locations = 5;


    pub fn get_annotation_locations(&self) -> &[SourceLocation] {
        &self.annotation_locations
    }
    pub fn clear_annotation_locations(&mut self) {
        self.annotation_locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_locations(&mut self, v: ::protobuf::RepeatedField<SourceLocation>) {
        self.annotation_locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotation_locations(&mut self) -> &mut ::protobuf::RepeatedField<SourceLocation> {
        &mut self.annotation_locations
    }

    // Take field
    pub fn take_annotation_locations(&mut self) -> ::protobuf::RepeatedField<SourceLocation> {
        ::std::mem::replace(&mut self.annotation_locations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.StructuredAnnotation structured_annotations = 4;


    pub fn get_structured_annotations(&self) -> &[StructuredAnnotation] {
        &self.structured_annotations
    }
    pub fn clear_structured_annotations(&mut self) {
        self.structured_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_structured_annotations(&mut self, v: ::protobuf::RepeatedField<StructuredAnnotation>) {
        self.structured_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_structured_annotations(&mut self) -> &mut ::protobuf::RepeatedField<StructuredAnnotation> {
        &mut self.structured_annotations
    }

    // Take field
    pub fn take_structured_annotations(&mut self) -> ::protobuf::RepeatedField<StructuredAnnotation> {
        ::std::mem::replace(&mut self.structured_annotations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for P4SerializableEnumTypeSpec_Member {
    fn is_initialized(&self) -> bool {
        for v in &self.annotation_locations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.structured_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.annotations)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotation_locations)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.structured_annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        for value in &self.annotations {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.annotation_locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.structured_annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        for v in &self.annotations {
            os.write_string(3, &v)?;
        };
        for v in &self.annotation_locations {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.structured_annotations {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4SerializableEnumTypeSpec_Member {
        P4SerializableEnumTypeSpec_Member::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &P4SerializableEnumTypeSpec_Member| { &m.name },
                |m: &mut P4SerializableEnumTypeSpec_Member| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &P4SerializableEnumTypeSpec_Member| { &m.value },
                |m: &mut P4SerializableEnumTypeSpec_Member| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &P4SerializableEnumTypeSpec_Member| { &m.annotations },
                |m: &mut P4SerializableEnumTypeSpec_Member| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SourceLocation>>(
                "annotation_locations",
                |m: &P4SerializableEnumTypeSpec_Member| { &m.annotation_locations },
                |m: &mut P4SerializableEnumTypeSpec_Member| { &mut m.annotation_locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructuredAnnotation>>(
                "structured_annotations",
                |m: &P4SerializableEnumTypeSpec_Member| { &m.structured_annotations },
                |m: &mut P4SerializableEnumTypeSpec_Member| { &mut m.structured_annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4SerializableEnumTypeSpec_Member>(
                "P4SerializableEnumTypeSpec.Member",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4SerializableEnumTypeSpec_Member {
        static instance: ::protobuf::rt::LazyV2<P4SerializableEnumTypeSpec_Member> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4SerializableEnumTypeSpec_Member::new)
    }
}

impl ::protobuf::Clear for P4SerializableEnumTypeSpec_Member {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.annotations.clear();
        self.annotation_locations.clear();
        self.structured_annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4SerializableEnumTypeSpec_Member {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4SerializableEnumTypeSpec_Member {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4ErrorTypeSpec {
    // message fields
    pub members: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4ErrorTypeSpec {
    fn default() -> &'a P4ErrorTypeSpec {
        <P4ErrorTypeSpec as ::protobuf::Message>::default_instance()
    }
}

impl P4ErrorTypeSpec {
    pub fn new() -> P4ErrorTypeSpec {
        ::std::default::Default::default()
    }

    // repeated string members = 1;


    pub fn get_members(&self) -> &[::std::string::String] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for P4ErrorTypeSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.members)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.members {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.members {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4ErrorTypeSpec {
        P4ErrorTypeSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "members",
                |m: &P4ErrorTypeSpec| { &m.members },
                |m: &mut P4ErrorTypeSpec| { &mut m.members },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4ErrorTypeSpec>(
                "P4ErrorTypeSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4ErrorTypeSpec {
        static instance: ::protobuf::rt::LazyV2<P4ErrorTypeSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4ErrorTypeSpec::new)
    }
}

impl ::protobuf::Clear for P4ErrorTypeSpec {
    fn clear(&mut self) {
        self.members.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4ErrorTypeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4ErrorTypeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4NewTypeTranslation {
    // message fields
    pub uri: ::std::string::String,
    // message oneof groups
    pub sdn_type: ::std::option::Option<P4NewTypeTranslation_oneof_sdn_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4NewTypeTranslation {
    fn default() -> &'a P4NewTypeTranslation {
        <P4NewTypeTranslation as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum P4NewTypeTranslation_oneof_sdn_type {
    sdn_bitwidth(i32),
    sdn_string(P4NewTypeTranslation_SdnString),
}

impl P4NewTypeTranslation {
    pub fn new() -> P4NewTypeTranslation {
        ::std::default::Default::default()
    }

    // string uri = 1;


    pub fn get_uri(&self) -> &str {
        &self.uri
    }
    pub fn clear_uri(&mut self) {
        self.uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        &mut self.uri
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uri, ::std::string::String::new())
    }

    // int32 sdn_bitwidth = 2;


    pub fn get_sdn_bitwidth(&self) -> i32 {
        match self.sdn_type {
            ::std::option::Option::Some(P4NewTypeTranslation_oneof_sdn_type::sdn_bitwidth(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_sdn_bitwidth(&mut self) {
        self.sdn_type = ::std::option::Option::None;
    }

    pub fn has_sdn_bitwidth(&self) -> bool {
        match self.sdn_type {
            ::std::option::Option::Some(P4NewTypeTranslation_oneof_sdn_type::sdn_bitwidth(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sdn_bitwidth(&mut self, v: i32) {
        self.sdn_type = ::std::option::Option::Some(P4NewTypeTranslation_oneof_sdn_type::sdn_bitwidth(v))
    }

    // .p4.config.v1.P4NewTypeTranslation.SdnString sdn_string = 3;


    pub fn get_sdn_string(&self) -> &P4NewTypeTranslation_SdnString {
        match self.sdn_type {
            ::std::option::Option::Some(P4NewTypeTranslation_oneof_sdn_type::sdn_string(ref v)) => v,
            _ => <P4NewTypeTranslation_SdnString as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_sdn_string(&mut self) {
        self.sdn_type = ::std::option::Option::None;
    }

    pub fn has_sdn_string(&self) -> bool {
        match self.sdn_type {
            ::std::option::Option::Some(P4NewTypeTranslation_oneof_sdn_type::sdn_string(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sdn_string(&mut self, v: P4NewTypeTranslation_SdnString) {
        self.sdn_type = ::std::option::Option::Some(P4NewTypeTranslation_oneof_sdn_type::sdn_string(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sdn_string(&mut self) -> &mut P4NewTypeTranslation_SdnString {
        if let ::std::option::Option::Some(P4NewTypeTranslation_oneof_sdn_type::sdn_string(_)) = self.sdn_type {
        } else {
            self.sdn_type = ::std::option::Option::Some(P4NewTypeTranslation_oneof_sdn_type::sdn_string(P4NewTypeTranslation_SdnString::new()));
        }
        match self.sdn_type {
            ::std::option::Option::Some(P4NewTypeTranslation_oneof_sdn_type::sdn_string(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sdn_string(&mut self) -> P4NewTypeTranslation_SdnString {
        if self.has_sdn_string() {
            match self.sdn_type.take() {
                ::std::option::Option::Some(P4NewTypeTranslation_oneof_sdn_type::sdn_string(v)) => v,
                _ => panic!(),
            }
        } else {
            P4NewTypeTranslation_SdnString::new()
        }
    }
}

impl ::protobuf::Message for P4NewTypeTranslation {
    fn is_initialized(&self) -> bool {
        if let Some(P4NewTypeTranslation_oneof_sdn_type::sdn_string(ref v)) = self.sdn_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uri)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sdn_type = ::std::option::Option::Some(P4NewTypeTranslation_oneof_sdn_type::sdn_bitwidth(is.read_int32()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sdn_type = ::std::option::Option::Some(P4NewTypeTranslation_oneof_sdn_type::sdn_string(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uri.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uri);
        }
        if let ::std::option::Option::Some(ref v) = self.sdn_type {
            match v {
                &P4NewTypeTranslation_oneof_sdn_type::sdn_bitwidth(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &P4NewTypeTranslation_oneof_sdn_type::sdn_string(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uri.is_empty() {
            os.write_string(1, &self.uri)?;
        }
        if let ::std::option::Option::Some(ref v) = self.sdn_type {
            match v {
                &P4NewTypeTranslation_oneof_sdn_type::sdn_bitwidth(v) => {
                    os.write_int32(2, v)?;
                },
                &P4NewTypeTranslation_oneof_sdn_type::sdn_string(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4NewTypeTranslation {
        P4NewTypeTranslation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uri",
                |m: &P4NewTypeTranslation| { &m.uri },
                |m: &mut P4NewTypeTranslation| { &mut m.uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "sdn_bitwidth",
                P4NewTypeTranslation::has_sdn_bitwidth,
                P4NewTypeTranslation::get_sdn_bitwidth,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, P4NewTypeTranslation_SdnString>(
                "sdn_string",
                P4NewTypeTranslation::has_sdn_string,
                P4NewTypeTranslation::get_sdn_string,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4NewTypeTranslation>(
                "P4NewTypeTranslation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4NewTypeTranslation {
        static instance: ::protobuf::rt::LazyV2<P4NewTypeTranslation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4NewTypeTranslation::new)
    }
}

impl ::protobuf::Clear for P4NewTypeTranslation {
    fn clear(&mut self) {
        self.uri.clear();
        self.sdn_type = ::std::option::Option::None;
        self.sdn_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4NewTypeTranslation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4NewTypeTranslation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4NewTypeTranslation_SdnString {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4NewTypeTranslation_SdnString {
    fn default() -> &'a P4NewTypeTranslation_SdnString {
        <P4NewTypeTranslation_SdnString as ::protobuf::Message>::default_instance()
    }
}

impl P4NewTypeTranslation_SdnString {
    pub fn new() -> P4NewTypeTranslation_SdnString {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for P4NewTypeTranslation_SdnString {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4NewTypeTranslation_SdnString {
        P4NewTypeTranslation_SdnString::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4NewTypeTranslation_SdnString>(
                "P4NewTypeTranslation.SdnString",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4NewTypeTranslation_SdnString {
        static instance: ::protobuf::rt::LazyV2<P4NewTypeTranslation_SdnString> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4NewTypeTranslation_SdnString::new)
    }
}

impl ::protobuf::Clear for P4NewTypeTranslation_SdnString {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4NewTypeTranslation_SdnString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4NewTypeTranslation_SdnString {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct P4NewTypeSpec {
    // message fields
    pub annotations: ::protobuf::RepeatedField<::std::string::String>,
    pub annotation_locations: ::protobuf::RepeatedField<SourceLocation>,
    pub structured_annotations: ::protobuf::RepeatedField<StructuredAnnotation>,
    // message oneof groups
    pub representation: ::std::option::Option<P4NewTypeSpec_oneof_representation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a P4NewTypeSpec {
    fn default() -> &'a P4NewTypeSpec {
        <P4NewTypeSpec as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum P4NewTypeSpec_oneof_representation {
    original_type(P4DataTypeSpec),
    translated_type(P4NewTypeTranslation),
}

impl P4NewTypeSpec {
    pub fn new() -> P4NewTypeSpec {
        ::std::default::Default::default()
    }

    // .p4.config.v1.P4DataTypeSpec original_type = 1;


    pub fn get_original_type(&self) -> &P4DataTypeSpec {
        match self.representation {
            ::std::option::Option::Some(P4NewTypeSpec_oneof_representation::original_type(ref v)) => v,
            _ => <P4DataTypeSpec as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_original_type(&mut self) {
        self.representation = ::std::option::Option::None;
    }

    pub fn has_original_type(&self) -> bool {
        match self.representation {
            ::std::option::Option::Some(P4NewTypeSpec_oneof_representation::original_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_original_type(&mut self, v: P4DataTypeSpec) {
        self.representation = ::std::option::Option::Some(P4NewTypeSpec_oneof_representation::original_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_original_type(&mut self) -> &mut P4DataTypeSpec {
        if let ::std::option::Option::Some(P4NewTypeSpec_oneof_representation::original_type(_)) = self.representation {
        } else {
            self.representation = ::std::option::Option::Some(P4NewTypeSpec_oneof_representation::original_type(P4DataTypeSpec::new()));
        }
        match self.representation {
            ::std::option::Option::Some(P4NewTypeSpec_oneof_representation::original_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_original_type(&mut self) -> P4DataTypeSpec {
        if self.has_original_type() {
            match self.representation.take() {
                ::std::option::Option::Some(P4NewTypeSpec_oneof_representation::original_type(v)) => v,
                _ => panic!(),
            }
        } else {
            P4DataTypeSpec::new()
        }
    }

    // .p4.config.v1.P4NewTypeTranslation translated_type = 2;


    pub fn get_translated_type(&self) -> &P4NewTypeTranslation {
        match self.representation {
            ::std::option::Option::Some(P4NewTypeSpec_oneof_representation::translated_type(ref v)) => v,
            _ => <P4NewTypeTranslation as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_translated_type(&mut self) {
        self.representation = ::std::option::Option::None;
    }

    pub fn has_translated_type(&self) -> bool {
        match self.representation {
            ::std::option::Option::Some(P4NewTypeSpec_oneof_representation::translated_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_translated_type(&mut self, v: P4NewTypeTranslation) {
        self.representation = ::std::option::Option::Some(P4NewTypeSpec_oneof_representation::translated_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_translated_type(&mut self) -> &mut P4NewTypeTranslation {
        if let ::std::option::Option::Some(P4NewTypeSpec_oneof_representation::translated_type(_)) = self.representation {
        } else {
            self.representation = ::std::option::Option::Some(P4NewTypeSpec_oneof_representation::translated_type(P4NewTypeTranslation::new()));
        }
        match self.representation {
            ::std::option::Option::Some(P4NewTypeSpec_oneof_representation::translated_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_translated_type(&mut self) -> P4NewTypeTranslation {
        if self.has_translated_type() {
            match self.representation.take() {
                ::std::option::Option::Some(P4NewTypeSpec_oneof_representation::translated_type(v)) => v,
                _ => panic!(),
            }
        } else {
            P4NewTypeTranslation::new()
        }
    }

    // repeated string annotations = 3;


    pub fn get_annotations(&self) -> &[::std::string::String] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.SourceLocation annotation_locations = 5;


    pub fn get_annotation_locations(&self) -> &[SourceLocation] {
        &self.annotation_locations
    }
    pub fn clear_annotation_locations(&mut self) {
        self.annotation_locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_locations(&mut self, v: ::protobuf::RepeatedField<SourceLocation>) {
        self.annotation_locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotation_locations(&mut self) -> &mut ::protobuf::RepeatedField<SourceLocation> {
        &mut self.annotation_locations
    }

    // Take field
    pub fn take_annotation_locations(&mut self) -> ::protobuf::RepeatedField<SourceLocation> {
        ::std::mem::replace(&mut self.annotation_locations, ::protobuf::RepeatedField::new())
    }

    // repeated .p4.config.v1.StructuredAnnotation structured_annotations = 4;


    pub fn get_structured_annotations(&self) -> &[StructuredAnnotation] {
        &self.structured_annotations
    }
    pub fn clear_structured_annotations(&mut self) {
        self.structured_annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_structured_annotations(&mut self, v: ::protobuf::RepeatedField<StructuredAnnotation>) {
        self.structured_annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_structured_annotations(&mut self) -> &mut ::protobuf::RepeatedField<StructuredAnnotation> {
        &mut self.structured_annotations
    }

    // Take field
    pub fn take_structured_annotations(&mut self) -> ::protobuf::RepeatedField<StructuredAnnotation> {
        ::std::mem::replace(&mut self.structured_annotations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for P4NewTypeSpec {
    fn is_initialized(&self) -> bool {
        if let Some(P4NewTypeSpec_oneof_representation::original_type(ref v)) = self.representation {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(P4NewTypeSpec_oneof_representation::translated_type(ref v)) = self.representation {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.annotation_locations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.structured_annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.representation = ::std::option::Option::Some(P4NewTypeSpec_oneof_representation::original_type(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.representation = ::std::option::Option::Some(P4NewTypeSpec_oneof_representation::translated_type(is.read_message()?));
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.annotations)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotation_locations)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.structured_annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.annotations {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.annotation_locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.structured_annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.representation {
            match v {
                &P4NewTypeSpec_oneof_representation::original_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &P4NewTypeSpec_oneof_representation::translated_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.annotations {
            os.write_string(3, &v)?;
        };
        for v in &self.annotation_locations {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.structured_annotations {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.representation {
            match v {
                &P4NewTypeSpec_oneof_representation::original_type(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &P4NewTypeSpec_oneof_representation::translated_type(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> P4NewTypeSpec {
        P4NewTypeSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, P4DataTypeSpec>(
                "original_type",
                P4NewTypeSpec::has_original_type,
                P4NewTypeSpec::get_original_type,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, P4NewTypeTranslation>(
                "translated_type",
                P4NewTypeSpec::has_translated_type,
                P4NewTypeSpec::get_translated_type,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &P4NewTypeSpec| { &m.annotations },
                |m: &mut P4NewTypeSpec| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SourceLocation>>(
                "annotation_locations",
                |m: &P4NewTypeSpec| { &m.annotation_locations },
                |m: &mut P4NewTypeSpec| { &mut m.annotation_locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructuredAnnotation>>(
                "structured_annotations",
                |m: &P4NewTypeSpec| { &m.structured_annotations },
                |m: &mut P4NewTypeSpec| { &mut m.structured_annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<P4NewTypeSpec>(
                "P4NewTypeSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static P4NewTypeSpec {
        static instance: ::protobuf::rt::LazyV2<P4NewTypeSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(P4NewTypeSpec::new)
    }
}

impl ::protobuf::Clear for P4NewTypeSpec {
    fn clear(&mut self) {
        self.representation = ::std::option::Option::None;
        self.representation = ::std::option::Option::None;
        self.annotations.clear();
        self.annotation_locations.clear();
        self.structured_annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for P4NewTypeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for P4NewTypeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1ap4/config/v1/p4types.proto\x12\x0cp4.config.v1\"\xb4\x08\n\nP4Type\
    Info\x12?\n\x07structs\x18\x01\x20\x03(\x0b2%.p4.config.v1.P4TypeInfo.St\
    ructsEntryR\x07structs\x12?\n\x07headers\x18\x02\x20\x03(\x0b2%.p4.confi\
    g.v1.P4TypeInfo.HeadersEntryR\x07headers\x12O\n\rheader_unions\x18\x03\
    \x20\x03(\x0b2*.p4.config.v1.P4TypeInfo.HeaderUnionsEntryR\x0cheaderUnio\
    ns\x129\n\x05enums\x18\x04\x20\x03(\x0b2#.p4.config.v1.P4TypeInfo.EnumsE\
    ntryR\x05enums\x123\n\x05error\x18\x05\x20\x01(\x0b2\x1d.p4.config.v1.P4\
    ErrorTypeSpecR\x05error\x12^\n\x12serializable_enums\x18\x06\x20\x03(\
    \x0b2/.p4.config.v1.P4TypeInfo.SerializableEnumsEntryR\x11serializableEn\
    ums\x12C\n\tnew_types\x18\x07\x20\x03(\x0b2&.p4.config.v1.P4TypeInfo.New\
    TypesEntryR\x08newTypes\x1aZ\n\x0cStructsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x124\n\x05value\x18\x02\x20\x01(\x0b2\x1e.p4.config.\
    v1.P4StructTypeSpecR\x05value:\x028\x01\x1aZ\n\x0cHeadersEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x124\n\x05value\x18\x02\x20\x01(\x0b2\
    \x1e.p4.config.v1.P4HeaderTypeSpecR\x05value:\x028\x01\x1ad\n\x11HeaderU\
    nionsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x129\n\x05value\
    \x18\x02\x20\x01(\x0b2#.p4.config.v1.P4HeaderUnionTypeSpecR\x05value:\
    \x028\x01\x1aV\n\nEnumsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x122\n\x05value\x18\x02\x20\x01(\x0b2\x1c.p4.config.v1.P4EnumTypeSpecR\
    \x05value:\x028\x01\x1an\n\x16SerializableEnumsEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12>\n\x05value\x18\x02\x20\x01(\x0b2(.p4.co\
    nfig.v1.P4SerializableEnumTypeSpecR\x05value:\x028\x01\x1aX\n\rNewTypesE\
    ntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x121\n\x05value\x18\x02\
    \x20\x01(\x0b2\x1b.p4.config.v1.P4NewTypeSpecR\x05value:\x028\x01\"\xff\
    \x05\n\x0eP4DataTypeSpec\x12E\n\tbitstring\x18\x01\x20\x01(\x0b2%.p4.con\
    fig.v1.P4BitstringLikeTypeSpecH\0R\tbitstring\x12.\n\x04bool\x18\x02\x20\
    \x01(\x0b2\x18.p4.config.v1.P4BoolTypeH\0R\x04bool\x125\n\x05tuple\x18\
    \x03\x20\x01(\x0b2\x1d.p4.config.v1.P4TupleTypeSpecH\0R\x05tuple\x123\n\
    \x06struct\x18\x04\x20\x01(\x0b2\x19.p4.config.v1.P4NamedTypeH\0R\x06str\
    uct\x123\n\x06header\x18\x05\x20\x01(\x0b2\x19.p4.config.v1.P4NamedTypeH\
    \0R\x06header\x12>\n\x0cheader_union\x18\x06\x20\x01(\x0b2\x19.p4.config\
    .v1.P4NamedTypeH\0R\x0bheaderUnion\x12H\n\x0cheader_stack\x18\x07\x20\
    \x01(\x0b2#.p4.config.v1.P4HeaderStackTypeSpecH\0R\x0bheaderStack\x12X\n\
    \x12header_union_stack\x18\x08\x20\x01(\x0b2(.p4.config.v1.P4HeaderUnion\
    StackTypeSpecH\0R\x10headerUnionStack\x12/\n\x04enum\x18\t\x20\x01(\x0b2\
    \x19.p4.config.v1.P4NamedTypeH\0R\x04enum\x121\n\x05error\x18\n\x20\x01(\
    \x0b2\x19.p4.config.v1.P4ErrorTypeH\0R\x05error\x12H\n\x11serializable_e\
    num\x18\x0b\x20\x01(\x0b2\x19.p4.config.v1.P4NamedTypeH\0R\x10serializab\
    leEnum\x126\n\x08new_type\x18\x0c\x20\x01(\x0b2\x19.p4.config.v1.P4Named\
    TypeH\0R\x07newTypeB\x0b\n\ttype_spec\"!\n\x0bP4NamedType\x12\x12\n\x04n\
    ame\x18\x01\x20\x01(\tR\x04name\"\x0c\n\nP4BoolType\"\r\n\x0bP4ErrorType\
    \"\x90\x03\n\x17P4BitstringLikeTypeSpec\x12/\n\x03bit\x18\x01\x20\x01(\
    \x0b2\x1b.p4.config.v1.P4BitTypeSpecH\0R\x03bit\x12/\n\x03int\x18\x02\
    \x20\x01(\x0b2\x1b.p4.config.v1.P4IntTypeSpecH\0R\x03int\x128\n\x06varbi\
    t\x18\x03\x20\x01(\x0b2\x1e.p4.config.v1.P4VarbitTypeSpecH\0R\x06varbit\
    \x12\x20\n\x0bannotations\x18\x04\x20\x03(\tR\x0bannotations\x12O\n\x14a\
    nnotation_locations\x18\x05\x20\x03(\x0b2\x1c.p4.config.v1.SourceLocatio\
    nR\x13annotationLocations\x12Y\n\x16structured_annotations\x18\x06\x20\
    \x03(\x0b2\".p4.config.v1.StructuredAnnotationR\x15structuredAnnotations\
    B\x0b\n\ttype_spec\"+\n\rP4BitTypeSpec\x12\x1a\n\x08bitwidth\x18\x01\x20\
    \x01(\x05R\x08bitwidth\"+\n\rP4IntTypeSpec\x12\x1a\n\x08bitwidth\x18\x01\
    \x20\x01(\x05R\x08bitwidth\"5\n\x10P4VarbitTypeSpec\x12!\n\x0cmax_bitwid\
    th\x18\x01\x20\x01(\x05R\x0bmaxBitwidth\"I\n\x0fP4TupleTypeSpec\x126\n\
    \x07members\x18\x01\x20\x03(\x0b2\x1c.p4.config.v1.P4DataTypeSpecR\x07me\
    mbers\"\xfa\x02\n\x10P4StructTypeSpec\x12?\n\x07members\x18\x01\x20\x03(\
    \x0b2%.p4.config.v1.P4StructTypeSpec.MemberR\x07members\x12\x20\n\x0bann\
    otations\x18\x02\x20\x03(\tR\x0bannotations\x12O\n\x14annotation_locatio\
    ns\x18\x03\x20\x03(\x0b2\x1c.p4.config.v1.SourceLocationR\x13annotationL\
    ocations\x12Y\n\x16structured_annotations\x18\x04\x20\x03(\x0b2\".p4.con\
    fig.v1.StructuredAnnotationR\x15structuredAnnotations\x1aW\n\x06Member\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x129\n\ttype_spec\x18\x02\
    \x20\x01(\x0b2\x1c.p4.config.v1.P4DataTypeSpecR\x08typeSpec\"\x83\x03\n\
    \x10P4HeaderTypeSpec\x12?\n\x07members\x18\x01\x20\x03(\x0b2%.p4.config.\
    v1.P4HeaderTypeSpec.MemberR\x07members\x12\x20\n\x0bannotations\x18\x02\
    \x20\x03(\tR\x0bannotations\x12O\n\x14annotation_locations\x18\x03\x20\
    \x03(\x0b2\x1c.p4.config.v1.SourceLocationR\x13annotationLocations\x12Y\
    \n\x16structured_annotations\x18\x04\x20\x03(\x0b2\".p4.config.v1.Struct\
    uredAnnotationR\x15structuredAnnotations\x1a`\n\x06Member\x12\x12\n\x04n\
    ame\x18\x01\x20\x01(\tR\x04name\x12B\n\ttype_spec\x18\x02\x20\x01(\x0b2%\
    .p4.config.v1.P4BitstringLikeTypeSpecR\x08typeSpec\"\xfc\x02\n\x15P4Head\
    erUnionTypeSpec\x12D\n\x07members\x18\x01\x20\x03(\x0b2*.p4.config.v1.P4\
    HeaderUnionTypeSpec.MemberR\x07members\x12\x20\n\x0bannotations\x18\x02\
    \x20\x03(\tR\x0bannotations\x12O\n\x14annotation_locations\x18\x03\x20\
    \x03(\x0b2\x1c.p4.config.v1.SourceLocationR\x13annotationLocations\x12Y\
    \n\x16structured_annotations\x18\x04\x20\x03(\x0b2\".p4.config.v1.Struct\
    uredAnnotationR\x15structuredAnnotations\x1aO\n\x06Member\x12\x12\n\x04n\
    ame\x18\x01\x20\x01(\tR\x04name\x121\n\x06header\x18\x02\x20\x01(\x0b2\
    \x19.p4.config.v1.P4NamedTypeR\x06header\"^\n\x15P4HeaderStackTypeSpec\
    \x121\n\x06header\x18\x01\x20\x01(\x0b2\x19.p4.config.v1.P4NamedTypeR\
    \x06header\x12\x12\n\x04size\x18\x02\x20\x01(\x05R\x04size\"n\n\x1aP4Hea\
    derUnionStackTypeSpec\x12<\n\x0cheader_union\x18\x01\x20\x01(\x0b2\x19.p\
    4.config.v1.P4NamedTypeR\x0bheaderUnion\x12\x12\n\x04size\x18\x02\x20\
    \x01(\x05R\x04size\"P\n\x0cKeyValuePair\x12\x10\n\x03key\x18\x01\x20\x01\
    (\tR\x03key\x12.\n\x05value\x18\x02\x20\x01(\x0b2\x18.p4.config.v1.Expre\
    ssionR\x05value\"I\n\x10KeyValuePairList\x125\n\x08kv_pairs\x18\x01\x20\
    \x03(\x0b2\x1a.p4.config.v1.KeyValuePairR\x07kvPairs\"~\n\nExpression\
    \x12#\n\x0cstring_value\x18\x01\x20\x01(\tH\0R\x0bstringValue\x12!\n\x0b\
    int64_value\x18\x02\x20\x01(\x03H\0R\nint64Value\x12\x1f\n\nbool_value\
    \x18\x03\x20\x01(\x08H\0R\tboolValueB\x07\n\x05value\"L\n\x0eExpressionL\
    ist\x12:\n\x0bexpressions\x18\x01\x20\x03(\x0b2\x18.p4.config.v1.Express\
    ionR\x0bexpressions\"\x86\x02\n\x14StructuredAnnotation\x12\x12\n\x04nam\
    e\x18\x01\x20\x01(\tR\x04name\x12G\n\x0fexpression_list\x18\x02\x20\x01(\
    \x0b2\x1c.p4.config.v1.ExpressionListH\0R\x0eexpressionList\x12B\n\x0ckv\
    _pair_list\x18\x03\x20\x01(\x0b2\x1e.p4.config.v1.KeyValuePairListH\0R\n\
    kvPairList\x12E\n\x0fsource_location\x18\x04\x20\x01(\x0b2\x1c.p4.config\
    .v1.SourceLocationR\x0esourceLocationB\x06\n\x04body\"P\n\x0eSourceLocat\
    ion\x12\x12\n\x04file\x18\x01\x20\x01(\tR\x04file\x12\x12\n\x04line\x18\
    \x02\x20\x01(\x05R\x04line\x12\x16\n\x06column\x18\x03\x20\x01(\x05R\x06\
    column\"\x8a\x04\n\x0eP4EnumTypeSpec\x12=\n\x07members\x18\x01\x20\x03(\
    \x0b2#.p4.config.v1.P4EnumTypeSpec.MemberR\x07members\x12\x20\n\x0bannot\
    ations\x18\x02\x20\x03(\tR\x0bannotations\x12O\n\x14annotation_locations\
    \x18\x04\x20\x03(\x0b2\x1c.p4.config.v1.SourceLocationR\x13annotationLoc\
    ations\x12Y\n\x16structured_annotations\x18\x03\x20\x03(\x0b2\".p4.confi\
    g.v1.StructuredAnnotationR\x15structuredAnnotations\x1a\xea\x01\n\x06Mem\
    ber\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x20\n\x0bannotatio\
    ns\x18\x02\x20\x03(\tR\x0bannotations\x12O\n\x14annotation_locations\x18\
    \x04\x20\x03(\x0b2\x1c.p4.config.v1.SourceLocationR\x13annotationLocatio\
    ns\x12Y\n\x16structured_annotations\x18\x03\x20\x03(\x0b2\".p4.config.v1\
    .StructuredAnnotationR\x15structuredAnnotations\"\xfe\x04\n\x1aP4Seriali\
    zableEnumTypeSpec\x12D\n\x0funderlying_type\x18\x01\x20\x01(\x0b2\x1b.p4\
    .config.v1.P4BitTypeSpecR\x0eunderlyingType\x12I\n\x07members\x18\x02\
    \x20\x03(\x0b2/.p4.config.v1.P4SerializableEnumTypeSpec.MemberR\x07membe\
    rs\x12\x20\n\x0bannotations\x18\x03\x20\x03(\tR\x0bannotations\x12O\n\
    \x14annotation_locations\x18\x05\x20\x03(\x0b2\x1c.p4.config.v1.SourceLo\
    cationR\x13annotationLocations\x12Y\n\x16structured_annotations\x18\x04\
    \x20\x03(\x0b2\".p4.config.v1.StructuredAnnotationR\x15structuredAnnotat\
    ions\x1a\x80\x02\n\x06Member\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04na\
    me\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value\x12\x20\n\x0bannota\
    tions\x18\x03\x20\x03(\tR\x0bannotations\x12O\n\x14annotation_locations\
    \x18\x05\x20\x03(\x0b2\x1c.p4.config.v1.SourceLocationR\x13annotationLoc\
    ations\x12Y\n\x16structured_annotations\x18\x04\x20\x03(\x0b2\".p4.confi\
    g.v1.StructuredAnnotationR\x15structuredAnnotations\"+\n\x0fP4ErrorTypeS\
    pec\x12\x18\n\x07members\x18\x01\x20\x03(\tR\x07members\"\xb5\x01\n\x14P\
    4NewTypeTranslation\x12\x10\n\x03uri\x18\x01\x20\x01(\tR\x03uri\x12#\n\
    \x0csdn_bitwidth\x18\x02\x20\x01(\x05H\0R\x0bsdnBitwidth\x12M\n\nsdn_str\
    ing\x18\x03\x20\x01(\x0b2,.p4.config.v1.P4NewTypeTranslation.SdnStringH\
    \0R\tsdnString\x1a\x0b\n\tSdnStringB\n\n\x08sdn_type\"\x83\x03\n\rP4NewT\
    ypeSpec\x12C\n\roriginal_type\x18\x01\x20\x01(\x0b2\x1c.p4.config.v1.P4D\
    ataTypeSpecH\0R\x0coriginalType\x12M\n\x0ftranslated_type\x18\x02\x20\
    \x01(\x0b2\".p4.config.v1.P4NewTypeTranslationH\0R\x0etranslatedType\x12\
    \x20\n\x0bannotations\x18\x03\x20\x03(\tR\x0bannotations\x12O\n\x14annot\
    ation_locations\x18\x05\x20\x03(\x0b2\x1c.p4.config.v1.SourceLocationR\
    \x13annotationLocations\x12Y\n\x16structured_annotations\x18\x04\x20\x03\
    (\x0b2\".p4.config.v1.StructuredAnnotationR\x15structuredAnnotationsB\
    \x10\n\x0erepresentationB-Z+github.com/p4lang/p4runtime/go/p4/config/v1b\
    \x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
